<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="referrer" content="no-referrer">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="源码学习,Redis,">





  <link rel="alternate" href="/atom.xml" title="黑白之院" type="application/atom+xml">






<meta name="description" content="引言 Redis 底层的基础数据结构包括：动态字符串（sds）、跳表（skiplist）、压缩列表（ziplist）、字典（dict）、整数集合（intset），快速链表（quicklist）等，t_hash，t_set, t_zset, t_list 等对外类型的内部实现都依赖于这些数据结构，所以非常值得学习。">
<meta name="keywords" content="源码学习,Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 源码学习之基本数据结构">
<meta property="og:url" content="/2019/12/15/redis-low-level-data-structures/index.html">
<meta property="og:site_name" content="黑白之院">
<meta property="og:description" content="引言 Redis 底层的基础数据结构包括：动态字符串（sds）、跳表（skiplist）、压缩列表（ziplist）、字典（dict）、整数集合（intset），快速链表（quicklist）等，t_hash，t_set, t_zset, t_list 等对外类型的内部实现都依赖于这些数据结构，所以非常值得学习。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic4.zhimg.com/v2-1d46ebdc21d0364fefecf710d01f473d.jpeg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-102788cac4f586778ffbf6767eb99d4f.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-0da8094f90661a53f47145881faf3315.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-84cb4d8cd05b321b4f611a492471c88a.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-74aa62891936d8a5ebd929fe2fcf4656.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-c3ed9fd26f9d28528282d51827b76e91.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c565192165aad2be79d17ae7e6517bc1.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-5eace6803426c11a9f2b27a83ff5d94f.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-1f634fd2892ebc00aef8aeb8f03ceb09.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-82b204f0b41afb79e21e84d76a4806ef.png">
<meta property="og:updated_time" content="2019-12-15T06:17:36.398Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis 源码学习之基本数据结构">
<meta name="twitter:description" content="引言 Redis 底层的基础数据结构包括：动态字符串（sds）、跳表（skiplist）、压缩列表（ziplist）、字典（dict）、整数集合（intset），快速链表（quicklist）等，t_hash，t_set, t_zset, t_list 等对外类型的内部实现都依赖于这些数据结构，所以非常值得学习。">
<meta name="twitter:image" content="https://pic4.zhimg.com/v2-1d46ebdc21d0364fefecf710d01f473d.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="/2019/12/15/redis-low-level-data-structures/">





  <title>Redis 源码学习之基本数据结构 | 黑白之院</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黑白之院</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Valar Morghulis</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-收藏">
          <a href="/collection" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-star"></i> <br>
            
            收藏
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/12/15/redis-low-level-data-structures/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iFaceless">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑白之院">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Redis 源码学习之基本数据结构</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-15T14:11:14+08:00">
                2019-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://pic4.zhimg.com/v2-1d46ebdc21d0364fefecf710d01f473d.jpeg" alt=""></p>
<p>Redis 底层的基础数据结构包括：动态字符串（sds）、跳表（skiplist）、压缩列表（ziplist）、字典（dict）、整数集合（intset），快速链表（quicklist）等，<code>t_hash</code>，<code>t_set</code>, <code>t_zset</code>, <code>t_list</code> 等对外类型的内部实现都依赖于这些数据结构，所以非常值得学习。</p>
<a id="more"></a>
<p>在学习每种数据结构时，需要重点关注如下几个问题：</p>
<ol>
<li>为什么这样设计，做了什么样的权衡？比如，有些数据结构是为了节约内存而设计的，所以会牺牲一定的查找效率；</li>
<li>每种数据结构的基本特点是什么？具体在什么场景下应用到？</li>
<li>一些数据结构接口的平均时间复杂度是什么？</li>
<li>很多数据结构在上层使用时，会根据需要选择，必要时会进行转换。需要了解转换的时机和触发的条件是什么？</li>
<li>某些数据结构内部会按需扩容或者缩容，需要关注它们扩容或者缩容的策略如何？什么情况下触发？</li>
</ol>
<p>本文的源码学习笔记是基于 Redis 5.0.7 版本做的，自己做了些中文注释，推送到了 <a href="https://github.com/iFaceless/redis/blob/comment-src/src" target="_blank" rel="noopener">redis comment-src 分支</a>，参考书籍为《Redis 5 源码设计与分析》。</p>
<p><strong>做了一个简单的思维导图，简单总结了各个数据结构的基本特点和一些值得阅读源码的 APIs</strong>，如果想要快速了解的话，可以直接跳到本文最后一节查看~</p>
<h1 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h1><p>动态字符串（SDS, Simple Dynamic String）是 Redis 中最常用的数据类型之一，可以用来存储字符串和整数。并且它是二进制安全的，还兼容 C 语言字符串的结束符 ‘\0’，所以部分 C 标准库中的字符串函数也可以对 SDS 进行操作。</p>
<p>动态字符串元信息及存储字符串的 buf 是由 sdshdr* 维护的，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __attribute__ ((__packed__)) 使用这种方式，要求编译器编译时，按照实际的字节数进行对齐。</span></span><br><span class="line"><span class="comment">// 这样做的好处有两个：</span></span><br><span class="line"><span class="comment">// 1. 节约内存（否则不同的 sdshdr* 因为不同的字节对齐方式，而导致占据较多内存）</span></span><br><span class="line"><span class="comment">// 2. 通过 header 获得 buf 地址时，不用考虑繁琐的字节对齐问题而导致计算复杂</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="comment">// flags 的低三位表示类型，高三位表示字符串长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="comment">// len 字符串长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="comment">// alloc 表示柔性数组分配的长度（不包含 header 和字符串终止符号）</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="comment">// flags 低三位表示类型，高 5 位保留</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外还有 sdshdr16, sdshdr32, sdshdr64，区别仅在于 len, alloc 使用的整数字节长度</span></span><br></pre></td></tr></table></figure>
<p>关于 SDS 的几个问题：</p>
<ol>
<li><strong>如何兼容 C 语言字符串标准？</strong> SDS 返回的就是指向存储字符串 buf 的指针，且以 ‘\0’ 结尾。</li>
<li><strong>如何节约内存？</strong> SDS 中根据字符串长度，提供了不同类型的结构体表示（sdshdr5, sdshdr8, sdshdr16, sdshdr32, sdshdr64），并且结构体中的字段按照单字节对齐（<code>((__packed__))</code>）进一步减少因默认字节对齐方式带来了内存消耗；同时按照单字节对齐，也方便基于 header 指针计算出柔性数组的指针。</li>
<li><strong>如何做到二进制安全？</strong> SDS Header 结构体中拥有 <code>len</code> 字段，记录了实际字符串的长度（不含结束符），因此在读取的时候可以确切地知道在哪儿停止，不会受到中间的 ‘\0’ 影响。</li>
<li><strong>SDS 在创建空字符串时，为何将 sdshdr5 转成 sdshdr8？</strong> 考虑到 sdshdr5 可能需要频繁扩容，导致内存复制开销。使用 sdshdr8 可以有效缓解。</li>
<li><strong>SDS 对于短字符串为何使用 sdshdr5？</strong> 很简单，还是为了节省内存空间，多数的字符串可能都是短字符串（长度 32 以内）。</li>
<li><strong>SDS 在写入时可能会扩容，那么它的扩容策略是怎样的？</strong>它的策略比较简单，如果 buf 剩余空间（alloc-len）能够放下新增的字符串长度，则不会有实质的扩容发生；如果剩余空间不够，则需要看 len+newLen 的长度值，如果小于 1MB，则按照 2 倍扩容；否则每次增加 1MB。在扩容后，还要看新的 header 类型（flags 字段表示）是否和之前一样，如果一样，则直接使用 realloc 原地扩容即可；否则需要使用 malloc 开辟新空间，并使用 <code>memcopy</code> 复制数据。完成扩容后，需要更新 SDS 的一些统计信息，并返回新的 buf 指针（也可能指向原来位置，具体看扩容时的策略执行）。</li>
</ol>
<h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><p>详细的源码注释参见 <a href="https://github.com/iFaceless/redis/blob/9366cba9171ea96f54b96f7d83e654958fe9b71f/src/sds.c#L90" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sdsnewlen 创建一个新的 sds 对象，并使用 init 指向的内容初始化</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">// 空字符串创建通常都需要执行 append 追加字符串。使用 type 8 比较适合，</span></span><br><span class="line">    <span class="comment">// type 5 可能空间不足，还需要执行扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type); <span class="comment">// 根据数据类型确定 header 长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 分配 sds 内存，+1 为了存储 '\0'</span></span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 内存初始化为 0</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen; <span class="comment">// 拿到指向 buf 的指针</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// point to flag, 注意 flag 其实是 unsigned char 类型</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="comment">// type 5 的 flag 比较特殊，类型保留在低 3 位</span></span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// SDS_TYPE_16, SDS_TYPE_32, SDS_TYPE_64...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 将用户指定区域的数据拷贝过来，不考虑 \0，二进制安全</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>; <span class="comment">// C 语言字符串以 '\0' 结尾</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// s 实际指向的是 buf 位置，这里需要计算出 header 指针</span></span><br><span class="line">    <span class="comment">// flag 始终位于 buf 前面，所以 s[-1] 可以得到 flag，进而</span></span><br><span class="line">    <span class="comment">// 确定 type，从而可以计算出 header 长度</span></span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s); <span class="comment">// 确定 buf 剩余的空间（alloc-len）</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="comment">// 如果剩余空间足够，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 确定现有字符串长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">// 获得字符串对应的 sdshdr 指针</span></span><br><span class="line">    sh = (<span class="keyword">char</span> *)s - sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">// 这里的新长度是后面扩容策略执行的依据</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 目前是 1MB 以内，2 倍扩容</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则都是加 1MB</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5)</span><br><span class="line">        type = SDS_TYPE_8;</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype == type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果类型不变，则执行扩容</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen + newlen + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 获取新的 sds 指向</span></span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        <span class="comment">// 由于 header 大小发生了变化，这里需要使用 malloc 开辟空间了</span></span><br><span class="line">        newsh = s_malloc(hdrlen + newlen + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 将 sds 中的内容拷贝到新的空间，包括 \0</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放旧的内存</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        <span class="comment">// 获取新的 sds 指针</span></span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">        <span class="comment">// 更新 flags</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        <span class="comment">// 更新长度信息</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新分配的空间大小</span></span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="跳表（skiplist）"><a href="#跳表（skiplist）" class="headerlink" title="跳表（skiplist）"></a>跳表（skiplist）</h1><p>跳表是 Redis 集合（zset）底层的实现方式之一（另一种是 ziplist）。跳表的特点如下：</p>
<ol>
<li>原理简单，实现难度远低于平衡树（红黑树）；</li>
<li>对于查找、插入和删除，平均 O(logN) 时间复杂度，效率和红黑树相当；</li>
<li>内存开销相对平衡树并没有特别大；</li>
<li>特别容易实现 Redis zset 中范围查询。</li>
</ol>
<p>跳表核心要素：<strong>分层</strong> + <strong>有序链表</strong>。</p>
<p>跳表查找过程描述：从最上层依次向后查找，如果本层的 next 节点大于要查找的值，或者 next 节点为 NULL，则从本节点开始，降低一层继续往后查找。如果找到目标节点，则返回；否则返回 NULL。</p>
<p><em>此前使用 Go 语言尝试实现了下 Redis 跳表，相关文章参见 <a href="https://zhuanlan.zhihu.com/p/96849002" target="_blank" rel="noopener">Go 语言实现 Redis 跳表</a>，源码及注释参见 <a href="https://link.zhihu.com/?target=https%3A//gitee.com/ifaceless/goskiplist/tree/master" target="_blank" rel="noopener">此处</a>。感兴趣的童鞋可以阅读下~</em></p>
<h2 id="Redis-跳表实现特点"><a href="#Redis-跳表实现特点" class="headerlink" title="Redis 跳表实现特点"></a>Redis 跳表实现特点</h2><p><img src="https://pic1.zhimg.com/80/v2-102788cac4f586778ffbf6767eb99d4f.png" alt=""></p>
<ol start="0">
<li>最多有 64 层，可以表示 2^64 个元素；</li>
<li>拥有 backward 后退指针，方便反向遍历；</li>
<li>添加了 span 字段，记录 forward 指向的节点和当前节点的间隔。span 越大，跳过的节点会越多。在计算排名（rank）时，就可以通过 span 计算得到；</li>
<li>新增节点时，层高是通过 <code>zlsRandomLevel()</code> 函数随机生成的，范围是 [1, 64]。但是该函数会保证越高 level 值的出现的概率越低。节点的层高确定后，将不会改边；</li>
<li>节点中的 score 允许重复。</li>
</ol>
<h2 id="跳表的具体应用"><a href="#跳表的具体应用" class="headerlink" title="跳表的具体应用"></a>跳表的具体应用</h2><p>zset 会使用跳表存储数据，但是它会根据配置 <code>zset-max-ziplist-entries 128</code> 和 <code>zset-max-ziplist-value 64</code> 值来确定该使用跳表还是 ziplist。另外，在新增元素时，如果原先是 ziplist，当临界条件达到时，会被转换成 skiplist，而且转变后就不可逆了。</p>
<h2 id="核心源码-1"><a href="#核心源码-1" class="headerlink" title="核心源码"></a>核心源码</h2><p>与跳表相关的几个重要的函数作了注释，参见 <a href="https://github.com/iFaceless/redis/blob/9366cba9171ea96f54b96f7d83e654958fe9b71f/src/t_zset.c#L144" target="_blank" rel="noopener">此处</a>。需要重点关注的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span></span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在看源码时，会经常看到 <code>update[]</code> 数组，这个数组是用来存放每一层需要被更新的节点（在增加、删除节点时会用到），把它看成 <code>pending_update_nodes</code> 或许会更好理解点。<br>另外，在增、删、改的时候，都会涉及到 <code>span</code> 的更新，需要仔细斟酌计算逻辑，一不小心就算错了。</p>
<h1 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h1><p>压缩表本质上就是一个字节数组，是一种为节约内存而设计的数据结构。可以存储多个元素，且每个元素可以是整数或者字符串（这里其实也可以理解为二进制安全的字节数组）。两端操作（pop/push）时间复杂度为 O(1)，但考虑到它每次插入或删除元素时，都需要调整内存（扩容或者缩小内存占用），所以实际的时间复杂度和它占用的内存有关。</p>
<p>ziplist 在<strong>散列表、列表和有序集合</strong>中均有（直接或间接地）应用。我们可以通过 <code>object encoding &lt;key&gt;</code> 来查看具体的使用的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd visitors 1.0 a</span><br><span class="line">&gt; object encoding visitors</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>在 Redis 的 <code>ziplist.c</code> 中，作者在注释中给出了压缩列表存储布局，并且给出了非常详细的说明和示例，值得阅读。整体来看，压缩列表的内存布局如下：<br><img src="https://pic4.zhimg.com/80/v2-0da8094f90661a53f47145881faf3315.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>压缩表字节长度（包括 <code>zlbytes</code> 自己）</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>尾元素相对于压缩列表起始地址的偏移，如此方便快速 pop 最后一个元素</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>表示 entries 的个数，最大有效值为 <code>2^16-2</code>，一旦超出，该值固定为 <code>2^16-1</code>，并且需要遍历整个列表才能得到准确的长度</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>固定为 <code>0xff</code>，表示压缩列表的结尾</td>
</tr>
</tbody>
</table>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>接下来，我们看看每个 entry 究竟是什么样子的，如下所示：<br><img src="https://pic4.zhimg.com/80/v2-84cb4d8cd05b321b4f611a492471c88a.png" alt=""></p>
<p>其中，<code>prevlen</code> 表示前一个 <code>entry</code> 的字节数，便于从后向前遍历；<code>encoding</code> 则表示当前 <code>entry</code> 的编码（整数类型？字符串类型？）；而 <code>entry-data</code> 则是真实存储内容的部分。当然，为了节约内存，这里的 <code>prevlen</code> 和 <code>encoding</code> 都是变长的，而 <code>entry-data</code> 则可能没有（比如存储小整数 0~12 时）。</p>
<p>默认情况下，<code>prevlen</code> 采用 <code>uint8_t</code> 类型，可表示最多 253 字节长度，超出 253 后，将会使用 5 个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 常规情况下</span><br><span class="line">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;</span><br><span class="line">// 长度超过 253 后</span><br><span class="line">0xFE &lt;4 字节，小端序 prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</span><br></pre></td></tr></table></figure>
<p><code>encoding</code> 字段也比较有趣，它占用多少个字节，和实际要存储的内容有关：</p>
<ul>
<li>如果是字符串类型，则 <code>encoding</code> 的前两位表示类型，剩下的则表示字符串的长度：<ul>
<li><code>|00pppppp|</code>：表示长度小于 64 字节的字符串，<code>pppppp</code> 表示 6 位无符号整数</li>
<li><code>|01pppppp|qqqqqqqq| - 2 字节</code>：表示长度小于 2^14 字节的字符串</li>
<li><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 字节</code>：表示长度小于 2^32 的字符串 </li>
</ul>
</li>
<li>如果是整数类型，则 <code>encoding</code> 的前两位总是 1，紧接着的两位则表示具体的整数类型：<ul>
<li><code>|11000000|</code>：int16</li>
<li><code>|11010000|</code>：int32</li>
<li><code>|11100000|</code>：int64</li>
<li><code>|11110000|</code>：24 位有符号整数</li>
<li><code>|11111110|</code>：8 位有符号整数</li>
<li><code>|1111xxxx|</code>：表示 4 位立即整数（imediate integer），0~12 无符号整数，此时没有 <code>entry-data</code> 字段了</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据上面描述的 ziplist 编码，我们来看看什么条件下它会占用较多内存？为什么说 ziplist 适合存储个数较少，且长度较短的元素呢？</p>
<ol>
<li>通过 <code>zzlen</code> 可知，如果元素个数超出 <code>2^16-2</code> 时，需要遍历整个 ziplist 元素才可以知道具体的长度，效率自然会降低很多；</li>
<li>通过 <code>prevlen</code> 可知，如果前一个 <code>entry</code> 超出其表示的范围时（253 字节），就需要由原来的 1 个字节变成 5 字节表示；</li>
<li>通过 <code>encoding</code> 可知，对于字符串类型元素，长度越长，<code>encoding</code> 需要占用的字节越多。尤其是在超出 <code>2^14-1</code>  时，新的 <code>encoding</code> 还要浪费第一个字节中的后 6 位，而使用后面的 32 位整数来表示字符串长度。</li>
</ol>
<p>综上所述，影响内存占用和执行效率的主要因素如下：</p>
<ol>
<li>元素个数；</li>
<li>元素类型；</li>
<li>元素长度。</li>
</ol>
<h2 id="核心源码-2"><a href="#核心源码-2" class="headerlink" title="核心源码"></a>核心源码</h2><p>为了方便获得每个 entry 相关的元信息，在 <code>ziplist.c</code> 中定义了一个 <code>zlentry</code> 结构体，但需要注意的是该结构体并非 entry 实际编码的布局。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zlentry 存在的目的就是保存每个 entry 解码后的元信息。因为实际每次对 length, encoding</span></span><br><span class="line"><span class="comment">// 等进行解码是比较复杂的运算，这里缓存下来也便于后续操作。</span></span><br><span class="line"><span class="comment">// 所以，需要注意的是，zlentry 并非真实的 entry 编码结构。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">// prevrawlensize 表示 `prevlen` 占用了几个字节来表示前一个 entry 的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="comment">// prevrawlen 表示前一个 entry 的实际长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen; <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="comment">// lensize 表示 `encoding` 占用了几个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize; <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="comment">// len 表示 entry 内容真正的长度。如果是字符串，就表示字符串长度；如果是整数</span></span><br><span class="line">    <span class="comment">// 则可能的值为 0（4 位小整数），1，2，3，4，8（和具体的 int 类型有关）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len; <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="comment">// headersize 表示整个 header 部分长度：&lt;prevlen&gt; + &lt;encoding&gt;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize; <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="comment">// encoding 表示具体的编码方式，如果 `ZIP_STR_*`,`ZIP_INT_*`</span></span><br><span class="line">    <span class="comment">// 这里需要注意的是，如果是小整数，还要做范围检查</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding; <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="comment">// p 指向元素开头的指针，实际指向的就是 `prevlen` 位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p; <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure></p>
<p>为了方便理解，画一个示例图如下：<br><img src="https://pic2.zhimg.com/v2-74aa62891936d8a5ebd929fe2fcf4656.jpg" alt=""></p>
<p>ziplist 相关的源码参见 <a href="https://github.com/iFaceless/redis/blob/comment-src/src/ziplist.c" target="_blank" rel="noopener">此处</a>。值得重点关注的几个函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ziplist 中比较晦涩或者枯燥的部分是编码、解码操作；其次，每次增加或者移除元素时，都涉及到很多内存操作（分配空间、内存拷贝）以及 entry header 的调整。想要写出可靠的代码来，还是需要心思缜密，逻辑清晰才可以，大佬们的编码能力实在是太强悍了！</p>
<p>这里需要提一点的是，元素的插入和删除，可能会产生<strong>连锁更新</strong>问题。也就是说，可能会导致自插入点（或删除点）后续的 entry prevlen 都需要修改（还记得前面提到的 entry prevlen 是变长的吗，所以可能需要将 prevlen 增长到 5 字节容纳更大的值；但是反过来，并没有允许缩容）。不过这种情况，只有在后续元素的大小接近于 <code>ZIP_BIG_PREVLEN</code> 才可能发生，概率比较低，所以实际上也没做什么优化。具体策略的实现可以参考 <code>__ziplistCascadeUpdate()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line">    <span class="comment">// 遍历所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算当前 entry 长度存储需要的字节数：rawlensize</span></span><br><span class="line">        zipEntry(p, &amp;cur);</span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        rawlensize = zipStorePrevEntryLength(<span class="literal">NULL</span>, rawlen);</span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        zipEntry(p + rawlen, &amp;next);</span><br><span class="line">        <span class="comment">// 如果长度不变，则直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            <span class="comment">// 下一个元素的 prevlen 需要更多字节来存储 prevrawlen 值</span></span><br><span class="line">            offset = p - zl;</span><br><span class="line">            extra = rawlensize - next.prevrawlensize;</span><br><span class="line">            <span class="comment">// 扩容以支持存储更长的 rawlen</span></span><br><span class="line">            zl = ziplistResize(zl, curlen + extra); <span class="comment">// 增加 extra 空间</span></span><br><span class="line">            p = zl + offset;</span><br><span class="line">            np = p + rawlen;</span><br><span class="line">            noffset = np - zl;</span><br><span class="line">            <span class="comment">// 更新 tail 偏移，最后一个元素会被移动到新的位置</span></span><br><span class="line">            <span class="keyword">if</span> ((zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np)</span><br><span class="line">            &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + extra);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将后续 entry 搬移，腾挪出空间存放新的长度值</span></span><br><span class="line">            memmove(np + rawlensize,</span><br><span class="line">                    np + next.prevrawlensize,</span><br><span class="line">                    curlen - noffset - next.prevrawlensize - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// next entry prevlen 记录下之前 entry 的长度值        </span></span><br><span class="line">            zipStorePrevEntryLength(np, rawlen);</span><br><span class="line">            <span class="comment">// ...继续下一个元素，每次都可能涉及到内存的扩容和元素的 memmove 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 阻止进行缩容，目的是为了防止后续插入时，可能频繁地 shrink 或者 grow 导致</span></span><br><span class="line">            <span class="comment">// 更多地开销。</span></span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                zipStorePrevEntryLengthLarge(p + rawlen, rawlen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                zipStorePrevEntryLength(p + rawlen, rawlen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h1><p>字典在 Redis 中是一个非常重要的数据结构，因为 Redis 本身就是一个 Key-Value 数据库。Redis 中的字典实现特点如下：</p>
<ol>
<li>可以支持海量的 key-value 映射；</li>
<li>key 的类型可以是字符串、整数等类型（<code>void *</code>）；value 可以是复杂的数据类型（string, hash, list, set, sorted set）或者是整数、浮点数等；</li>
<li>为了避免哈希冲突，采用了链地址法，将冲突的 Entry 串联了起来；</li>
<li>为了避免在进行扩容或者缩容时，需要对海量 keys 进行 rehash 而导致阻塞时间过久，采用了渐进式 rehash 策略；</li>
<li>提供了安全和非安全的迭代器，方便对整个字典进行迭代；</li>
<li>对于 keys 非常大的字典，提供了 <code>dictScan</code> 方法，间断迭代，避免因为普通迭代时阻塞其它操作。</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表真正的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// sizemask = size-1，这里用于 hash &amp; sizemask 计算出 slot</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 哈希表中的 keys 个数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// 依赖数据抽象的操作接口</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 私有数据，配合 type 字段指向的函数使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 有两个 hash table</span></span><br><span class="line">    <span class="comment">// rehashidx 表示 rehash 的进度</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// iterators 当前正在运行的迭代器数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>字典整体结构可以用下图来表示：<br><img src="https://pic3.zhimg.com/80/v2-c3ed9fd26f9d28528282d51827b76e91.png" alt=""></p>
<h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>在执行 <code>dictAddRaw()</code> 时，会尝试进行扩容，调用流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dictAddRaw()</span><br><span class="line">  _dictKeyIndex()</span><br><span class="line">    _dictExpandIfNeeded()</span><br><span class="line">      dictExpand()</span><br><span class="line">        _dictNextPower()</span><br></pre></td></tr></table></figure>
<p>所以扩容或者缩容的核心逻辑在 <code>dictExpand()</code> 函数，我们来看看该函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确保我们要扩容的大小可以容纳目前的元素</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 得到目标扩容大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="comment">// 扩容时比较耗时的操作，避免无效扩容</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 初始化新的哈希表</span></span><br><span class="line">    dictht n;</span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ht[1] 指向的哈希表供渐进式 rehash 使用。</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// 表示 rehash 准备完毕，进度为 0</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容策略：4 -&gt; 4 * 2 -&gt; 4 * 2 * 2 -&gt; ...</span></span><br><span class="line"><span class="comment">// 按照 2 的倍数增加，直到第一个可以容纳 size 大小的数找到为止</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX)</span><br><span class="line">        <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要的时候，Redis 可以对字典执行缩容操作，具体可以调用 <code>dictResize()</code> 函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="渐进式-Rehash"><a href="#渐进式-Rehash" class="headerlink" title="渐进式 Rehash"></a>渐进式 Rehash</h2><p>为了避免在 rehash 期间，因为要迁移的 keys 太多，导致阻塞其它操作时间太久，Redis 的字典实现中，使用了渐进式 rehash 的策略，从而将对大量 keys 的迁移分散在 N 次操作中，直到最终完成，具体实现参见 <a href="https://github.com/iFaceless/redis/blob/4c5a6f422b60500816e9c507bb0265495f483dda/src/dict.c#L206" target="_blank" rel="noopener">dictRehash()</a>。</p>
<p>采用了渐进式 rehash 策略后，每次在执行查找、插入、更新、删除以及 Redis 服务器空闲时，可以执行一部分 keys 的 rehash 操作。具体执行时机如下：</p>
<ol>
<li><p><code>_dictRehashStep() -&gt; dictRehash(d, 1)</code>：</p>
<ol>
<li><code>dictAddRaw()</code></li>
<li><code>dictDelete()</code></li>
<li><code>dictUnlink()</code></li>
<li><code>dictFind()</code></li>
<li><code>dictGetRandomKey()</code></li>
<li><code>dictGetSomeKeys()</code></li>
</ol>
</li>
<li><p><code>incrementallyRehash() -&gt; dictRehashMilliseconds(d, 1) -&gt; dictRehash(d, 100)</code>：Server 处于空闲时执行 1ms 的 rehash 工作。</p>
</li>
</ol>
<h2 id="普通迭代器与安全迭代器"><a href="#普通迭代器与安全迭代器" class="headerlink" title="普通迭代器与安全迭代器"></a>普通迭代器与安全迭代器</h2><p>迭代器是一种常见的设计模式，它可以方便我们对容器中的元素进行遍历，但不需要了解容器内部实现细节。Redis 的字典也我们提供了迭代器数据结构，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="comment">// table 指向的当前在迭代 table，safe 表明是否为安全的迭代器</span></span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">// fingerprint 用来检查非安全迭代器在使用期间是否执行了不允许的操作</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>;</span><br></pre></td></tr></table></figure>
<p>安全迭代器和普通迭代器的区别：</p>
<ul>
<li>安全迭代器允许我们在迭代期间，执行查找、删除、新增等对 dict 有副作用的操作（如执行 <code>keys *</code> 命令时会创建安全迭代器）；</li>
<li>普通迭代器则只能允许我们执行 <code>dictNext()</code> 进行迭代，其它操作是不允许的（如执行 <code>sort</code> 会创建非安全迭代器）。</li>
</ul>
<p>那么，为什么会有这样的限制呢？这主要是因为在迭代期间，如果有执行查找、添加、删除等操作，可能会发生 rehash，进而导致扫描到重复的 entry。</p>
<p>普通迭代器在迭代开始时，计算出当前 dict 的指纹，并在迭代结束时再次计算 dict 的指纹，从而确定 dict 在此期间是否发生过修改过，相关实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 开始迭代，计算下 fp</span></span><br><span class="line">                iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，安全迭代器又是如何做到安全的呢？其实策略很简单，就是在执行对 dict 有副作用的操作时，阻止其进行 rehash 即可，这样可以保证底层的 hash tables 不会有 keys 的迁移。具体实现如下：</p>
<ul>
<li>迭代器初始化时，<code>safe</code> 字段置 1；</li>
<li>初次迭代时，执行 <code>iter-&gt;d-&gt;iterators++</code>，告诉 <code>dict</code> 当前存在安全的迭代器在运行；</li>
<li><code>_dictRehashStep</code> 时，如果 <code>dict-&gt;iterators != 0</code> 则不会执行 rehash。</li>
</ul>
<h2 id="间断迭代器"><a href="#间断迭代器" class="headerlink" title="间断迭代器"></a>间断迭代器</h2><p>为了避免扫描所有的 keys 而造成长时间的阻塞（事实上，我们的生产环境是禁用 <code>keys</code> 命令的），Redis 在 2.8 之后加入了 <code>scan</code> 操作，从而能够间断地迭代整个字典。<code>zscan</code> 和 <code>hscan</code> 底层都会执行间断迭代操作，它的具体实现参见 <a href="https://github.com/iFaceless/redis/blob/4c5a6f422b60500816e9c507bb0265495f483dda/src/dict.c#L878" target="_blank" rel="noopener">dictScan</a>，核心是围绕一个游标进行的，关于它的具体策略可以参见源码的详细描述。</p>
<p>这里总结下 <code>dictScan</code> 算法的主要特点：</p>
<ol>
<li><strong>迭代器本身是无状态的（和上面的两个相比）</strong>，迭代位置是基于游标计算的，而游标会返回给用户，由用户保存，并在迭代时传入；</li>
<li><strong>可能会迭代到重复的元素</strong>，但由于采用了 <em>reverse binary iteration</em> 算法，能够保证不漏遍历且尽可能不重复遍历；</li>
<li><strong>每次迭代会返回多个元素</strong>，这主要是因为避免 rehash 的影响，每次会将一个 bucket 上所有的 keys 都返回出去。</li>
</ol>
<h1 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h1><p>顾名思义，intset 是转门用于<strong>存储整数</strong>的集合。它实际上也是为了节约内存而设计的，随着元素中最大的元素的类型发生变化，它也会按需扩容。intset 还有个特点是<strong>有序且不重复</strong>（可以想到查找时就可以光明正大地利用二分算法了）。</p>
<p>intset 实际上是 Redis 集合类型底层使用的数据结构之一，<strong>当元素为 64 位以内有符号整数（支持 <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>），且元素个数不多</strong>（取决于 <code>set_max_intset_entries</code> 设置）时使用。当元素个数超出设定值，或者新增元素类型非整数，<strong>intset 就会被转换成 hashtable</strong>，也就是使用 dict 来存储。具体可以看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">setTypeCreate</span><span class="params">(sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value, &amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr, llval, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 元素个数超出范围，需要转换成字典存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject, OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非整数类型，转换成字典</span></span><br><span class="line">            setTypeConvert(subject, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 整数长度：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 整数个数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>简单画了个内存布局图如下，相信可以直观地表达这个数据结构的特点：<br><img src="https://pic1.zhimg.com/80/v2-c565192165aad2be79d17ae7e6517bc1.png" alt=""></p>
<h2 id="核心源码-3"><a href="#核心源码-3" class="headerlink" title="核心源码"></a>核心源码</h2><p>intset 的核心 API 比较少，且实现比较简单，很容易看懂，所以在这里不多赘述了，相关源码中文注释直接看 <a href="https://github.com/iFaceless/redis/blob/c4e3ab7aa976ff1bde948803a6212c1cb2764b76/src/intset.c#L97" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span></span>; <span class="comment">// O(N)</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span></span>; <span class="comment">// O(N)</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value); <span class="comment">// O(logN)</span></span><br><span class="line"><span class="keyword">int64_t</span> intsetRandom(intset *is); <span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetGet(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value); <span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">uint32_t</span> intsetLen(<span class="keyword">const</span> intset *is); <span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">size_t</span> intsetBlobLen(intset *is); <span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
<h1 id="快速链表（quicklist）"><a href="#快速链表（quicklist）" class="headerlink" title="快速链表（quicklist）"></a>快速链表（quicklist）</h1><p>快速链表（quicklist）本质上也是一个双向链表，但是它的每个节点存储的元素位于 ziplist 中，并且中间节点的 ziplist 还可以使用 LZF 算法进行压缩，进一步节省内存。总的来说，quicklist 是一个综合了双向链表和 ziplist 优点的数据结构。ziplist 最大的特点是节约内存，但不适宜存储过多的元素；而链表则便于从头部或者尾部执行插入或查找。</p>
<p>因此，quicklist 算是为 Redis 列表类型 <code>t_list</code> 特别定制的数据结构，兼顾了时间和空间效率。我们通常使用的 <code>LPUSH</code>, <code>LPOP</code>, <code>RPUSH</code>, <code>RPOP</code> 命令，实际上只需要操作列表两端即可，而 qucklist 恰好维护了 head 和 tail 的节点指针，方便快速定位。</p>
<p><img src="https://pic2.zhimg.com/80/v2-5eace6803426c11a9f2b27a83ff5d94f.png" alt=""></p>
<h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quicklist 是对快速链表这种数据结构的抽象，其中存储了一些元信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// head, tail 指向链表的头尾</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// count 记录了所有 ziplists 的元素个数之和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count; <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="comment">// len 记录了有多少个 Nodes</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="comment">// fill 表示每个节点最多可以包含的数据项，正数表示最多可以含有的元素个数</span></span><br><span class="line">    <span class="comment">// 负数则表示每个节点 ziplist 的最大长度（字节数）：</span></span><br><span class="line">    <span class="comment">// -1, 4KB</span></span><br><span class="line">    <span class="comment">// -2, 8KB</span></span><br><span class="line">    <span class="comment">// -3, 16KB</span></span><br><span class="line">    <span class="comment">// -4, 32KB</span></span><br><span class="line">    <span class="comment">// -5, 64KB</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>; <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="comment">// compress 表示两端不被压缩的节点个数。一般对于 list 的操作通常是在两端进行的</span></span><br><span class="line">    <span class="comment">// 所以，为了方便 LPUSH/LPOP/RPUSH/RPOP 命令，这里可以选择对两端不做压缩。</span></span><br><span class="line">    <span class="comment">// 但是为了节约内存，会对中间节点进行压缩（ziplist 已经够节约内存了，但是还是要压缩</span></span><br><span class="line">    <span class="comment">// 更进一步地节约内存），代价就是消耗点 CPU 时间用于压缩或者解压缩。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistNode 实际上是对 ziplist 的描述，元素存储于 ziplist 中。</span></span><br><span class="line"><span class="comment">// 为什么需要在 quicklistNode 中位于 ziplist 的一些元信息呢？这主要是因为</span></span><br><span class="line"><span class="comment">// 节点指向的 ziplist 可以被压缩，这样就不能快速获取一些元信息了（元素个数等）。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 双向链表，自然需要前后关联</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 指向 ziplist 指针（如果是压缩节点，实际指向的是 quicklistLZF）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="comment">// ziplist 的大小（bytes）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="comment">// ziplist 中存储的元素个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>; <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="comment">// 表示 ziplist 进行了压缩编码，RAW=1 表示没有压缩；2 表示使用了 LZF 算法压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>; <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="comment">// 容器类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>; <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="comment">// 当前节点是否被压缩过？如果压缩过还需要在使用前进行解压</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="comment">// 当前节点太小了，无法压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistLZF 表示 ziplist 压缩后的数据结构，它是一个 4+N 字节大小的结构体。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="comment">// sz 表示 LZF 压缩后的数据大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="comment">// compressed 存储压缩后的数据</span></span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistEntry 是对 quicklistNode 下 ziplist 某个元素的抽象，</span></span><br><span class="line"><span class="comment">// 方便我们获取元素的内容。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// quicklist 指向 quicklist 的指针</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist;</span><br><span class="line">    <span class="comment">// quicklistNode 当前 entry 关联的节点</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="comment">// zi 关联的 ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;</span><br><span class="line">    <span class="comment">// value 指向 string 类型的元素位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value;</span><br><span class="line">    <span class="comment">// longvalue 元素转换为整数的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval;</span><br><span class="line">    <span class="comment">// sz 表示 value 的有效长度（string 类型编码时，encoding 中的长度部分就是这个）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="comment">// offset 表示在当前 ziplist 中的偏移量</span></span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure>
<p>通过下图可以对 quicklist 有个直观的感受，便于理解这种数据结构：<br><img src="https://pic1.zhimg.com/80/v2-1f634fd2892ebc00aef8aeb8f03ceb09.png" alt=""></p>
<h2 id="核心源码-4"><a href="#核心源码-4" class="headerlink" title="核心源码"></a>核心源码</h2><p>quicklist 的源码比较多，就不再本文中赘述了，详细的源码注释可以在 <a href="https://github.com/iFaceless/redis/blob/152cb8a4be4ce107a34135314020ec69bca93216/src/quicklist.c#L94" target="_blank" rel="noopener">此处</a> 查看。值得重点关注的几个函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 为 quicklist 节点个数，m 表示内部 ziplist 的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="keyword">int</span> where)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *node, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *node, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistIndex</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> index, quicklistEntry *entry)</span></span>; <span class="comment">// O(n+m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data, <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span></span>;  <span class="comment">// O(m)</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里就不多废话了，对于基本的数据结构做了点总结，放在下面的思维导图中。其中 APIs 分支并非每个数据结构全部的接口，而是一些比较有趣，值得阅读源码的接口，有兴趣地话可以欣赏下它们的内部实现。如果有任何问题，欢迎留言指正~</p>
<p><img src="https://pic2.zhimg.com/80/v2-82b204f0b41afb79e21e84d76a4806ef.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">Redis 为什么用跳表而不用平衡树？</a></li>
<li><a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">《Redis 5 设计与源码分析》</a></li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    iFaceless
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="/2019/12/15/redis-low-level-data-structures/" title="Redis 源码学习之基本数据结构">/2019/12/15/redis-low-level-data-structures/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码学习/" rel="tag"><i class="fa fa-tag"></i> 源码学习</a>
          
            <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/11/implement-redis-skiplist-in-go/" rel="next" title="Go 语言实现 Redis 跳表">
                <i class="fa fa-chevron-left"></i> Go 语言实现 Redis 跳表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/17/implement-redis-dict-in-go/" rel="prev" title="Go 语言实现 Redis 字典">
                Go 语言实现 Redis 字典 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="iFaceless">
            
              <p class="site-author-name" itemprop="name">iFaceless</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ifaceless" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:me#ifaceless.space" target="_blank" title="邮箱">
                      邮箱</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://zhuanlan.zhihu.com/0xe8551ccb" target="_blank" title="专栏">
                      专栏</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                常用链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xieyuanpeng.com" title="Lingering Fragments" target="_blank">Lingering Fragments</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.acolyer.org/" title="The Morning Paper" target="_blank">The Morning Paper</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.freecodecamp.org" title="freeCodeCamp" target="_blank">freeCodeCamp</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://draveness.me/" title="Draveness's Blog" target="_blank">Draveness's Blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态字符串"><span class="nav-number">2.</span> <span class="nav-text">动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心源码"><span class="nav-number">2.1.</span> <span class="nav-text">核心源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跳表（skiplist）"><span class="nav-number">3.</span> <span class="nav-text">跳表（skiplist）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-跳表实现特点"><span class="nav-number">3.1.</span> <span class="nav-text">Redis 跳表实现特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表的具体应用"><span class="nav-number">3.2.</span> <span class="nav-text">跳表的具体应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心源码-1"><span class="nav-number">3.3.</span> <span class="nav-text">核心源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#压缩列表（ziplist）"><span class="nav-number">4.</span> <span class="nav-text">压缩列表（ziplist）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存布局"><span class="nav-number">4.1.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Entry"><span class="nav-number">4.2.</span> <span class="nav-text">Entry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">4.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心源码-2"><span class="nav-number">4.4.</span> <span class="nav-text">核心源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字典（dict）"><span class="nav-number">5.</span> <span class="nav-text">字典（dict）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">5.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩容与缩容"><span class="nav-number">5.2.</span> <span class="nav-text">扩容与缩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渐进式-Rehash"><span class="nav-number">5.3.</span> <span class="nav-text">渐进式 Rehash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#普通迭代器与安全迭代器"><span class="nav-number">5.4.</span> <span class="nav-text">普通迭代器与安全迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#间断迭代器"><span class="nav-number">5.5.</span> <span class="nav-text">间断迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#整数集合（intset）"><span class="nav-number">6.</span> <span class="nav-text">整数集合（intset）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构-1"><span class="nav-number">6.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心源码-3"><span class="nav-number">6.2.</span> <span class="nav-text">核心源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#快速链表（quicklist）"><span class="nav-number">7.</span> <span class="nav-text">快速链表（quicklist）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构-2"><span class="nav-number">7.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心源码-4"><span class="nav-number">7.2.</span> <span class="nav-text">核心源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黑白之院（iFaceless）</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
