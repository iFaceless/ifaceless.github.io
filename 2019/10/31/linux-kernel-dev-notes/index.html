<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="referrer" content="no-referrer">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,操作系统,调度器,内存管理,文件系统,">





  <link rel="alternate" href="/atom.xml" title="黑白之院" type="application/atom+xml">






<meta name="description" content="引言最近抽时间把 Operating Systems: Three Easy Pieces 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年末 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（Linux">
<meta name="keywords" content="Linux,操作系统,调度器,内存管理,文件系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Kernel Development 学习与总结">
<meta property="og:url" content="http://ifaceless.space/2019/10/31/linux-kernel-dev-notes/index.html">
<meta property="og:site_name" content="黑白之院">
<meta property="og:description" content="引言最近抽时间把 Operating Systems: Three Easy Pieces 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年末 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（Linux">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e0c1aced72034fd29160b2a0dbc73fa5_r.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-ad2075f3f165ab1ab983605446be9b28_r.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-2bbaf34ff51ed6c19c0390d1fd118b40_hd.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-78cb6999358bdd22b1a00c221f1d606e_r.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-de0df74c2c0f79723ab558d3b2727e71.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-1540217805cb1d2ee083d293209bbbaf_r.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-5f2b9c321b7100a11e2dae9e48bce81f_r.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e7ae1f0fcc4b3a1d0af4e65a1ca04101_r.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ff24fef84f1c136922f8bf1f5679ea99_hd.png">
<meta property="og:updated_time" content="2019-11-24T10:07:26.745Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Kernel Development 学习与总结">
<meta name="twitter:description" content="引言最近抽时间把 Operating Systems: Three Easy Pieces 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年末 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（Linux">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-e0c1aced72034fd29160b2a0dbc73fa5_r.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ifaceless.space/2019/10/31/linux-kernel-dev-notes/">





  <title>Linux Kernel Development 学习与总结 | 黑白之院</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黑白之院</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Valar Morghulis</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-收藏">
          <a href="/collection" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-star"></i> <br>
            
            收藏
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifaceless.space/2019/10/31/linux-kernel-dev-notes/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iFaceless">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑白之院">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Linux Kernel Development 学习与总结</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-31T17:47:22+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近抽时间把 <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener"><em>Operating Systems: Three Easy Pieces</em></a> 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年末 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（<em>Linux Kernel Development</em>）后找到想要的答案。当然，在学习中也针对很多部分搜集了不少学习资料，整理在文后，方便加深理解。</p>
<p>在学习之前，思考了一些问题，可以在学习中探索这些问题的答案：</p>
<ol>
<li>Linux 中进程、线程是如何实现的？各种调度策略是什么样的？又是怎么实现的呢？</li>
<li>并发问题肯定需要注意，Linux 中如何应对竞态条件 &amp; 数据竞争呢？各种常见的同步原语又是如何实现的？</li>
<li>Linux 的内存虚拟化是如何实现的？内存布局？虚拟地址空间？</li>
<li>文件系统有很多，操作系统是怎么进行抽象，并对用户提供一致优雅的系统调用接口的呢？</li>
<li>Linux 内核中有哪些非常经典的算法和数据结构的应用？它们使用场景是什么？怎么实现的呢？</li>
</ol>
<h1 id="Linux-内核简介"><a href="#Linux-内核简介" class="headerlink" title="Linux 内核简介"></a>Linux 内核简介</h1><p><img src="https://pic4.zhimg.com/80/v2-e0c1aced72034fd29160b2a0dbc73fa5_r.png" alt=""></p>
<p>说到 Linux，就不得不提到它的祖先 Unix 系统。Unix 在 1970 年左右被 Ken Thompson 首先在一台 PDP-7 机型上实现，而后移植到 PDP-11 机器上，1973 年它被使用 C 语言重写，提供了更加强大的可移植性。</p>
<p>经过多年发展，Unix 系统成为了一个强大、健壮且稳定的操作系统。其强大的根本原因如下：</p>
<ol>
<li>简洁，仅提供数百个设计目标明确的系统调用；</li>
<li>所有的东西都被当作文件看待</li>
<li>很强的移植能力</li>
<li>进程创建非常迅速，拥有独特的 <code>fork()</code> 系统调用</li>
<li>拥有简单且稳定的进程间通信原语</li>
</ol>
<p>Linux 是类 Unix 系统，它的实现和 Unix 也有一些大相径庭的方面，但是它依然继承了 Unix 的设计目标，保证了 API 的一致性（有品位的程序员都应该要学习这一思想）。</p>
<p>Linux 词汇一般用来指代内核。它的基础包括：</p>
<ol>
<li>内核</li>
<li>C 库</li>
<li>工具集</li>
<li>系统的基本工具，如 Shell</li>
</ol>
<p>什么是操作系统？宽泛的操作系统是指整个系统中负责完成最基本功能和系统管理的部分，包括<strong>内核、设备驱动、启动引导程序、命令行 Shell 或用户界面、文件管理工具和系统工具</strong>。内核则是那个最亮的仔，它通常由如下几个重要部分组成：</p>
<ol>
<li>中断服务</li>
<li>任务调度程序</li>
<li>内存管理程序</li>
<li>网络</li>
<li>进程间通信等系统服务</li>
</ol>
<p>Linux 的中断服务是不在进程上下文执行的，而是在一个与所有进程无关、专门的中断上下文执行。这样可以保证第一时间能够响应和处理中断请求，然后快速退出。</p>
<p>处理器在任意时间点活动可概括为以下三种之一：</p>
<ol>
<li>运行在用户空间，执行用户进程</li>
<li>运行在内核空间，处于进程上下文，代表某个特定的进程执行（如某个系统调用）</li>
<li>运行在内核空间，处于中断上下文，与进程无关，处理特定的中断</li>
</ol>
<h2 id="微内核和宏内核"><a href="#微内核和宏内核" class="headerlink" title="微内核和宏内核"></a>微内核和宏内核</h2><p>这个是比较有趣的历史了，操作系统设计有两大主要阵营：微内核和宏内核。</p>
<p>微内核的功能划分成多个独立的过程，每个过程都是一个服务（C/S 模型，服务与内核交互）。系统采用 IPC 禁止互通消息，互换「服务」。服务的独立性可以避免一个服务失败殃及其它服务。模块化设计也非常适合热插拔。但是缺点就是 IPC 的开销多于函数调用（类比微服务的网络开销和在本地调用函数的开销）。</p>
<p>宏内核则是实用主义者喜欢的设计，它是比较简单的设计，整体上就是一个单独的过程，运行在一个单独的地址空间。内核之间的通信微不足道，性能高。</p>
<p>Linux 自然是宏内核设计，Linux 内核运行在单独的内核地址空间上。同时它也采纳了微内核的精华，使它成为模块化的、多线程的以及内核本身可调度的操作系统。</p>
<h2 id="与传统-Unix-区别"><a href="#与传统-Unix-区别" class="headerlink" title="与传统 Unix 区别"></a>与传统 Unix 区别</h2><ol>
<li>支持动态加载内核模块（这个不是微内核宣称的好处吗？咱也有）</li>
<li>支持对称多处理机制（SMP）</li>
<li>内核可以抢占（preemptive）：任务可以有优先级</li>
<li>对多线程的支持很特别：内核不区分线程和一般的进程，对于内核而言，所有的进程都一样，只是其中的一些共享资源而已</li>
<li>具有设备类的面向对象的设备模型、热插拔事件，用户空间的设备文件系统（sysfs）</li>
<li>忽略了一些拙劣特性</li>
<li>自由：任何改变都必须要能通过简洁的设计及正确可靠的实现来解决现实中确实存在的问题</li>
</ol>
<h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p><code>&lt;主版本&gt;.&lt;从版本&gt;.&lt;修订&gt;[.&lt;稳定版本号&gt;]</code>，其中<strong>从版本号</strong>为偶数，则为稳定版本，否则为开发版本。</p>
<h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以使用的配置方式如下：</p>
<ol>
<li><code>make config</code></li>
<li><code>make menuconfig1</code></li>
<li><code>make gconfig</code></li>
<li>默认配置：<code>make defconfig</code></li>
</ol>
<p>验证和更新配置：<code>make oldconfig</code></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol>
<li>直接编译：<code>make</code></li>
<li>导出不关心的 info：<code>make &gt;/dev/null</code></li>
<li>指定并行编译数量：<code>make -j4 &gt;/dev/null</code></li>
</ol>
<h2 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h2><ol>
<li>不能使用标准 C 库</li>
<li><p>必须使用 GNU C（需要用到它的一些扩展特性）</p>
<ol>
<li><code>inline</code>：通常将对时间要求比较高，函数本身比较短的定义成内联函数。在内核中，为了类型安全和易读性，优先使用 inline 函数，而非复杂的宏</li>
<li>内联编译：支持使用 <code>asm()</code> 嵌入汇编代码</li>
<li>分支声明：可以使用 <code>likely()</code> 和 <code>unlikely()</code> 声明分支是否经常出现或很少出现，指导编译器进行优化（要搞清楚，否则优化反而变成了拖累）</li>
</ol>
</li>
<li><p>缺乏像用户空间中的内存保护机制</p>
<ol>
<li>内核中发生内存错误会导致 oops，内核可能会死掉</li>
<li>内核中的内存是<strong>不分页</strong>的，每用掉一个字节，物理内存就减少一个字节</li>
</ol>
</li>
<li><p>难以执行浮点数计算</p>
<ol>
<li>不能像用户空间执行浮点数计算那样，可以通过 trap 的方式将整数模式转换到浮点数模式计算</li>
<li>内核不能完美支持浮点数计算，本身也无法陷入。非要执行的话，就需要手动保存和恢复浮点寄存器，非常麻烦</li>
</ol>
</li>
<li><p>内核给每个进程<strong>只有一个很小的定长堆栈</strong></p>
<ol>
<li>用户空间的栈可以动态增长，可支持非常大的数据结构</li>
<li>内核栈的大小和体系结构有关（如 x86 可以是 4KB/8KB）</li>
<li>历史上来说，内核栈大小是两页，32 位是 8KB，64 位是 16KB；每个处理器都有自己的栈</li>
</ol>
</li>
<li><p>由于要支持异步中断、抢占和 SMP，时刻需要注意并发安全和同步</p>
</li>
<li>考虑可移植性<ol>
<li>保持字节序</li>
<li>64 位对齐</li>
<li>不假定字长和页面长度</li>
</ol>
</li>
</ol>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><ol>
<li>内核把进程的列表存放在 task list 双向链表中，每个 entry 的类型是 <code>task_struct</code>，被称为 <code>process descriptor</code></li>
<li>通过 slab（更新的应该是 SLUB） 分配器分配 task_struct 结构体（对象复用和缓存着色），每个任务的 <code>thread_info</code> 位于内核栈的尾端，其中包含指向 <code>task_struct</code> 的指针及其它信息</li>
<li>进程通过 PID 进行区分，其值存放在 <code>process descriptor</code> 中。由于进程处理代码需要频繁访问 <code>task_struct</code> 信息，所以在 PowerPC 等机器上，有专门的寄存器存储了相应的指针；而在 x86 体系下，则是利用内核栈尾创建的 <code>thread_info</code>，并借助偏移计算间接查找 <code>task_struct</code> 结构体</li>
<li><p>进程状态：</p>
<ol>
<li>TASK_RUNNING</li>
<li>TASK_INTERRUPTABLE</li>
<li>TASK_UNINTERRUPTABLE</li>
<li>__TASK_TRACED: 被其它进程跟踪的进程（如 ptrace 对调试程序进行跟踪）</li>
<li><p>__TASK_STOPPED: 进程停止执行，没有投入运行也无法投入运行</p>
<p><img src="https://pic2.zhimg.com/80/v2-ad2075f3f165ab1ab983605446be9b28_r.png" alt=""></p>
</li>
</ol>
</li>
<li><p>所有的进程都是 PID 为 1 的 init 进程的后代，init 进程的描述符是作为 init_task 静态分配的（比较特殊）</p>
</li>
<li><p>Unix 系统进程创建：</p>
<ol>
<li>通过 <code>fork()</code> 拷贝当前进程创建一个子进程（区别父进程：有新的 PID，有某些资源和统计量）</li>
<li><code>exec()</code> 函数负责读取可执行文件并将其载入地址空间开始运行</li>
</ol>
</li>
<li><p>写时拷贝：内核并非开始就复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝，只有在需要写入的时候，数据才会被复制，从而拥有各自的拷贝。<code>fork()</code> 实际开销：复制父进程的页表，给子进程创建唯一的进程描述符</p>
</li>
<li>Linux 中的 <code>fork()</code> 和 <code>vfork()</code> 都是通过 <code>clone()</code> 系统调用实现的。<code>vfork()</code> 的特点是：不拷贝父进程的页表，且子进程作为父进程的单独线程在它的地址空间执行，父进程阻塞直到子进程退出或执行 <code>exec()</code></li>
<li><p>Linux 中的线程实现：</p>
<ol>
<li>从内核角度看，没有线程的概念，所有的线程都当作进程看待，只是与其它进程共享某些资源。每个线程都拥有属于自己的 task_struct</li>
<li>其它系统中，线程被抽象成一种耗费资源较少的资源，运行迅速的执行单元</li>
<li>通过 <code>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</code> 创建线程</li>
<li>对比 <code>fork()</code> 实现：<code>clone(SIGCHLD, 0)</code></li>
<li>对比 <code>vfork()</code> 实现：<code>clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)</code></li>
</ol>
</li>
<li><p>内核线程：</p>
<ol>
<li>内核通常需要在后台执行一些操作，这些任务可通过 kernel thread 完成。这种是运行在内核空间的标准进程</li>
<li>内核线程没有独立的地址空间，可被调度，可被抢占</li>
</ol>
</li>
<li><p>进程终结：</p>
<ol>
<li>通常通过 <code>do_exit()</code> 完成退出，期间会释放相关的资源，最终将进程状态设置为 <code>EXIT_ZOMBIE</code>，但是此时的内核栈、thread_info 和 task_struct 结构体还是存在的，从而给父进程提供信息</li>
<li>父进程获得已终结的子进程信息后（父进程可通过 <code>wait()</code> 系统调用收集信息），或者通知内核它不关注这些信息，才会释放剩余的内存空间</li>
</ol>
</li>
<li><p>孤儿进程：</p>
<ol>
<li>退出时永远处于僵死状态，白白浪费内存</li>
<li>解决办法就是在当前线程组寻找某个线程作为父亲，实在不行，就让 init 接盘</li>
</ol>
</li>
</ol>
<h2 id="调度进程"><a href="#调度进程" class="headerlink" title="调度进程"></a>调度进程</h2><ol>
<li><p>多任务系统分为两类：</p>
<ol>
<li>非抢占式多任务（cooperative multitasking）</li>
<li>抢占式多任务（preemptive multitasking）</li>
</ol>
</li>
<li><p>进程调度策略会关心进程的优先级、时间片</p>
</li>
<li>Linux 中的进程分为普通进程和实时进程，其中前者的优先级在 (-20, +19），而后者则是 (0, 99)。此外，实时进程的优先级总是高于普通进程优先级的，所以普通进程的优先级映射过来就是 (100, 139)</li>
<li>Linux 中可以通过 <code>nice</code> 调整进程的优先级，越小的值拥有越高的权重；反之，则权重越低（体现在时间片上）</li>
</ol>
<h3 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h3><ol>
<li>Linux 2.6 内核引入了 CFS 调度器（位于 <code>sched/fair.c</code>）作为普通进程的调度器，它是一个近乎完美的公平调度器（权衡周转时间和响应时间）。并非采用时间片进行分配，而是给进程分配了处理器使用的比重，从而确保进程调度中能够有恒定的公平性，从而将切换频率置于不断变动中</li>
<li>CFS 基于一个简单的理念：进程调度的效果应该等同于系统拥有一个完美的多任务处理器，每个进程都能获得 1/n_running 处理器时间</li>
<li>CFS 允许每个进程运行一段时间，循环轮转，总是选择 vruntime 最小的进程作为下一个执行。也就是说，是通过所有可运行经常总数为基础来计算出进程应该运行多久，而非依靠 nice 值来计算时间片（传统的做法就是这种）</li>
<li>调度器实现概要：<ol>
<li><code>sched_entity</code> 结构体跟踪运行记账（其中包含 vruntime）</li>
<li>所有可运行的进程都位于一棵黑红树中（O(logN) 时间复杂度查找），并且每次都会从树的最左叶子节点上（leftmost）找到 vruntime 最小的那个进程运行（实时上，这个值是提前缓存好的）</li>
<li>调度器入口处会找到最高优先级的调度类，然后获取到谁是下一个该运行的进程</li>
<li>睡眠：进程会把自己标记成休眠状态，从可执行红黑树中溢出，并放入等待队列，调用 <code>schedule()</code> 执行一个其他进程</li>
<li>唤醒：进程被设置为可执行状态，从等待队列移除，添加到可执行红黑树</li>
</ol>
</li>
<li>CFS 实现了如下几种调度策略：<ol>
<li>SCHED_NORMAL（以前叫做 SCHED_OTHER）：用于普通任务调度</li>
<li>SCHED_BATCH：并非像普通任务那样被频繁抢占，会尽可能允许任务运行足够长时间，从而利用上 CPU 亲和性以及更好地复用缓存</li>
<li>SCHED_IDLE：这种任务优先级比 nice 19 还要低</li>
</ol>
</li>
</ol>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ol>
<li>用户抢占（检查 need_resched 标识符）：从系统调用返回用户空间时；从中断处理返回用户空间时</li>
<li>内核抢占（thread_info 中存在 preemt_count 计数器，表示有没有锁被持有）：就是调度程序能够在内核任务执行期间被执行<ol>
<li>只要重新调度是安全的（没有持有锁），内核就可以在任何时间抢占正在执行的任务</li>
<li>内核抢占时机：<ol>
<li>中断处理程序正在执行，且返回内核空间之前</li>
<li>内核代码再次具有可抢占性时</li>
<li>内核任务显式调用 <code>schedule()</code></li>
<li>内核中的任务阻塞（此时会导致调用 <code>schedule()</code>）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="实时调度器"><a href="#实时调度器" class="headerlink" title="实时调度器"></a>实时调度器</h3><ol>
<li>实时调度器是在 <code>sched/rt.c</code> 中实现的，它使用了 100 个运行队列（对应 1~99 任务优先级），实现了 SCHED_FIFO 和 SCHED_RR 策略。</li>
<li><p>SCHED_FIFO:</p>
<ol>
<li>简单的先入先出调度算法，不依赖时间片</li>
<li>该级别任务比 SCHED_NORMAL 级别的进程先得到调度</li>
<li>一旦任务处于执行期间，就会一直执行下去；只有更高优先级的 SCHED_FIFO/SCHED_RR 任务才可以抢占</li>
</ol>
</li>
<li><p>SCHED_RR:</p>
<ol>
<li>类似 FIFO，但是每个任务会有分配的时间片，时间片耗尽后就要换其它任务执行</li>
<li>对于 FIFO 进程，高优先级始终抢占低优先级进程；低优先级进程不能抢占 SCHED_RR 进程，即便其耗尽了时间片</li>
</ol>
</li>
<li><p>Linux 提供的是软实时工作方式，尽力使得进程能够在限定的时间到来前执行，但内核不保证总能满足这些进程的要求</p>
</li>
</ol>
<h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>调度器类需要实现一些 hooks，这样可以在需要的时候做合适的操作。部分 hooks 如下：</p>
<ul>
<li><code>enqueue_task</code></li>
<li><code>dequeue_task</code></li>
<li><code>yield_task</code></li>
<li><code>check_preempt_cur</code></li>
<li><code>pick_next_task</code></li>
<li><code>set_curr_task</code></li>
<li><code>task_tick</code></li>
</ul>
<h3 id="调度相关的-syscall"><a href="#调度相关的-syscall" class="headerlink" title="调度相关的 syscall"></a>调度相关的 syscall</h3><table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nice()</td>
<td>设置进程的 nice 值</td>
</tr>
<tr>
<td>sched_setscheduler()</td>
<td>设置调度策略</td>
</tr>
<tr>
<td>sched_getscheduler()</td>
<td>获取调度策略</td>
</tr>
<tr>
<td>sched_setparam()</td>
<td>设置实时优先级</td>
</tr>
<tr>
<td>sched_getparam()</td>
<td></td>
</tr>
<tr>
<td>sched_rr_get_interval()</td>
<td>时间片值</td>
</tr>
<tr>
<td>sched_setaffinity()</td>
<td>设置处理器亲和力</td>
</tr>
<tr>
<td>sched_getaffinity()</td>
<td>获取进程处理器亲和力</td>
</tr>
<tr>
<td>shced_yield()</td>
<td>暂时让出处理器</td>
</tr>
</tbody>
</table>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>众所周知，进程是在操作系统提供的用户空间运行的，而如果需要打开文件等操作，需要通过系统调用，陷入到内核态，由操作系统代替完成和硬件的交互，从而为进程提供服务。所以说，系统调用时在用户空间和进程和硬件设备之间的一个中间层。这个中间层的主要作用如下：</p>
<ol>
<li>为用户空间提供硬件接口抽象</li>
<li>系统调用保证系统的安全和稳定</li>
<li>操作系统可以掌控进程的硬件访问意图，并且代劳</li>
</ol>
<p>那么系统调用又是如何实现的呢？一句话总结为：<strong>当系统调用执行时，会陷入到内核，传递系统调用号和参数，执行正确的系统调用函数，并且把返回值带回用户空间。</strong>可见，系统调用非常特殊，完全不同于常规的函数调用，看起来非常 Hack。</p>
<p>接下来，通过几个问题，加深对上述描述的理解：</p>
<ol>
<li><strong>如何陷入到内核？</strong>通过软中断的方式实现，通过引发一个异常触发系统切换到内核态执行异常处理程序。</li>
<li><strong>什么是系统调用号？</strong>在 Linux 中，每个系统调用都被赋予了一个编号，进程其实是通过系统调用号而不是名称来告知内核自己中意哪个系统调用的。</li>
<li><strong>如何传递系统调用号？</strong>通过寄存器传递，在 x86 中，就是将系统调用号放在 eax 寄存器传递给内核的。</li>
<li><strong>参数是如何传递的？</strong>    <ol>
<li>第一种方式就是将参数放在寄存器中，一般来说系统调用参数不会很多。在 x86 中，可以用 ebx, ecx, edx, esi 和 edi 按顺序存放五个参数。</li>
<li>第二种方式就是将参数存放在用户空间内存中，并将参数指针存放在寄存器中。这种是为了应付参数超过 6 个情况。</li>
</ol>
</li>
<li><strong>返回值如何带给用户空间？</strong>当然也是通过寄存器来传递的，在 x86 中，可以使用 eax 寄存器。</li>
</ol>
<h1 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h1><p><img src="https://pic1.zhimg.com/80/v2-2bbaf34ff51ed6c19c0390d1fd118b40_hd.png" alt="内核数据结构"></p>
<p>Linux 内核链表实现独树一帜。它是将链表塞入到数据结构，而非常规的那种在数据结构中塞入链表。</p>
<p>可以看下对比就知道为何特别了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规定义方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux 内核链表定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 所有的 node 形成链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，通用的链表操作就可以基于 <code>struct list_head</code> 来实现了。那如何和根据链表指针获得对应的 <code>node</code> 呢？答案是通过 <code>container_of()</code> 宏，实际上 C 语言中，一个给定结构体中的变量偏移在编译时就已经确定了，所以可以借此获得父结构中的任意变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(ptr, type, member) (&#123; \</span><br><span class="line">    const typeof( ((type *)0)-&gt;member) *__mptr = (ptr); \</span><br><span class="line">    (type *)( (char *)__mptr - offsetof(type, member) );&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h1><p><img src="https://pic4.zhimg.com/80/v2-78cb6999358bdd22b1a00c221f1d606e_r.png" alt=""></p>
<p>中断是各种硬件设备与处理器协同高效工作的方式之一。处理器执行指令的速度非常快，而一些外部设备则会慢很多；为了能够保证 CPU 不浪费时间轮询设备状态，而降低利用率，所以需要中断机制来通知 CPU。当处理器接收到中断后，会去执行已注册的相关中断处理程序。</p>
<p>需要注意的是，中断和前面提到的异常（Fault）是不同的：</p>
<ol>
<li>中断通常是异步发生的，不考虑时钟同步；</li>
<li>异常则必须与处理器时钟同步，所以也被称为同步中断（如除 0 错误、缺页）。</li>
</ol>
<p>Linux 中对于中断的响应和处理分成<strong>上半部</strong>和<strong>下半部</strong>。其中上半部会在接收到中断信号后快速完成必要工作的（有严格的时限），而更加繁重的任务则会在下半部执行。在上半部需要快速执行，且无法睡眠；但下半部则没有这样的限制。</p>
<h2 id="无须重入"><a href="#无须重入" class="headerlink" title="无须重入"></a>无须重入</h2><p>Linux 中的中断处理不用考虑重入，因为当给定中断处理程序在执行时，对应中断线在所有处理器上被屏蔽，避免同一中断线接收另外的中断。这样做简化了中断处理程序的编写。</p>
<h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>所谓的中断上下文（interrupt context），就是在执行中断处理程序时，内核所处的上下文。中断上下文和进程上下文没有半毛钱关系，我们可以把它和进程上下文进行一番对比：</p>
<table>
<thead>
<tr>
<th>中断上下文</th>
<th>进程上下文</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行中断处理程序时，内核所处的上下文</td>
<td>内核代表进程执行（系统调用、运行内核线程）时，所处的操作模式</td>
</tr>
<tr>
<td>与进程无瓜，与 current 宏无瓜</td>
<td>可通过 current 宏关联当前进程</td>
</tr>
<tr>
<td>没有后备进程，无法睡眠，也不能调用会导致睡眠的函数</td>
<td>可睡眠，可调用调度程序</td>
</tr>
<tr>
<td>有严格的执行时限</td>
<td>没有非常严格的要求</td>
</tr>
</tbody>
</table>
<h2 id="下半部及推后执行的工作"><a href="#下半部及推后执行的工作" class="headerlink" title="下半部及推后执行的工作"></a>下半部及推后执行的工作</h2><p>下半部就是执行和中断处理相关，但是中断处理程序中不会执行的工作。引入下半部的目的就是让中断处理程序尽可能地简短、快速，避免屏蔽中断太久，导致系统的响应能力和性能受到影响；而比较繁重的工作可以在下半部执行。</p>
<p>下半部主要实现方式：</p>
<ol>
<li><strong>软中断</strong><ol>
<li>对于时间要求严格，且能自己高效完成加锁的工作，可使用软中断（如网络、SCSI）</li>
<li>软中断执行期间，允许响应中断，但它自身<strong>不能睡眠</strong></li>
</ol>
</li>
<li><strong>tasklet</strong><ol>
<li>基于软中断实现，同一个处理程序的多个实例不能再多个处理器同时运行</li>
<li>用途广泛，接口简单，性能不错</li>
<li>不能睡眠</li>
</ol>
</li>
<li><strong>工作队列</strong>中的工作可以交给内核线程推后执行（会在进程上下文执行），可以利用进程上下文的优势，且可以重新调度和睡眠</li>
</ol>
<h1 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h1><p>在进行内核编程时，时刻需要注意并发带来的问题，需要能够正确识别临界区，正确加锁、解锁，保证关键数据结构不被错误修改。那么有哪些情况能造成并发问题呢？</p>
<ol>
<li><strong>中断</strong>：异步发生，会中断当前正在执行的代码</li>
<li><strong>软中断和 tasklet</strong>：内核会在任意时刻唤醒软中断和 tasklet，打断当前正在执行的代码</li>
<li><strong>内核抢占</strong>：内核中的任务可能被其它任务抢占</li>
<li><strong>睡眠及与用户空间同步</strong>：在内核中执行的进程可能会睡眠，从而导致调度程序被唤醒，并运行新的用户进程</li>
<li><strong>SMP</strong>：多个处理器会并行执行</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-de0df74c2c0f79723ab558d3b2727e71.png" alt=""></p>
<h1 id="定时器和时间管理"><a href="#定时器和时间管理" class="headerlink" title="定时器和时间管理"></a>定时器和时间管理</h1><p>内核需要在硬件（RTC 和 Timer）的帮助下才能计算和管理时间，内核通过<strong>已知的</strong>（这个时钟周期是可编程的，可确定的）时钟中断间隔来计算 wall time 和 jiffies（系统启动以来的节拍总数）。那么，在时钟中断发生时究竟会做哪些工作呢？以下给出一些会周期执行的工作：</p>
<ol>
<li>更新系统运行时间和实际时间</li>
<li>对于 SMP 系统，需要均衡各处理器上的任务队列，如果运行队列负载不均衡，需要尽量让它们均衡</li>
<li>检查当前进程是否用尽了自己的时间片，如果时，则重新进行调度</li>
<li>运行超时的动态定时器</li>
<li>更新资源消耗和处理器时间统计值</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>内核是把物理内存分页管理的，也就是说页（page）是最基本的管理单元。MMU 也是以页大小为单位转换虚拟地址到硬件地址的。不同的体系结构，页大小不同，一般 32 位系统是 4KB，64 位系统是 8KB。</p>
<h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>因为硬件存在限制，内核无法对所有的页一视同仁。因此需要把页划分成不同的区（zone），内核需要处理如下因为硬件缺陷而引起的内存寻址问题：</p>
<ol>
<li>一些硬件只能用特定的内存地址执行 DMA 操作</li>
<li>一些体系结构的内存物理寻址范围比虚拟地址范围大</li>
</ol>
<p>内核的分区有四种：</p>
<ol>
<li><strong>ZONE_DMA</strong>：可执行 DMA 操作的页集合</li>
<li>ZONE_DMA32：同上，但仅限于 32 位设备</li>
<li><strong>ZONE_NORMAL</strong>：能够正常映射的页</li>
<li>ZONE_HIGHMEM：高端内存区域，其中的页不能永久映射到内核地址空间（这里限于 32 位地址空间，64 位就不会有问题了）</li>
</ol>
<h2 id="页申请和释放"><a href="#页申请和释放" class="headerlink" title="页申请和释放"></a>页申请和释放</h2><ol>
<li><code>alloc_page(gfp_mask)</code>：只分配一页，返回指向页结构的指针</li>
<li><code>alloc_pages(gfp_mask, order)</code>：分配 2^order 个连续页</li>
<li><code>__get_free_page(gfp_mask)</code>：只分配一页，返回指向其逻辑地址的指针</li>
<li><code>__get_free_pages(gfp_mask, order)</code>：分配 2^order 个连续物理页，返回逻辑地址指针</li>
<li><code>get_zeroed_page(gfp_mask)</code>：只分配一页，且填充 0 ，返回逻辑地址指针</li>
<li><code>__free_pages(struct page *page, unsinged int order)</code></li>
<li><code>free_pages(unsigned long addr, unsinged int order)</code></li>
<li><code>free_page(unsigned long addr)</code></li>
</ol>
<h2 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h2><p><code>void *kmalloc(size_t size, gfp_t flags)</code>，<code>kmalloc()</code> 类似于 <code>malloc()</code>，可以获得指定字节大小的内核内存，它分配得到的页的物理地址是连续的，所以虚拟地址也是连续的。<br><code>void kfree(const void *ptr)</code> 释放分配的内存空间</p>
<p>关于标记位，常用的是 GFP_KERNEL，允许睡眠，用于进程上下文空间；另外的 GFP_ATOMIC，则不可以睡眠，可用于进程上下文、中断处理程序、软中断、tasklet。</p>
<h2 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h2><p><code>vmalloc()</code> 类似 <code>kmalloc()</code>，不同的是，它分配的内存虚拟地址虽然是连续的，但是实际的物理地址无需连续。它通过分配非连续的物理内存，再「修正」页表，从而把内存映射到逻辑地址空间连续的区域。它需要专门的页表来完成连续虚拟地址到实际非连续物理地址的映射，开销较大，且容易引起 TLB 抖动，通常在内核中更倾向于使用 <code>kmalloc()</code>。</p>
<h2 id="slab-层"><a href="#slab-层" class="headerlink" title="slab 层"></a>slab 层</h2><p>slab 层充当通用数据结构的缓存层的角色，它会为不同的对象划分成不同的高速缓存组，每组存放不同类型的对象。比如，存放 task_struct 和 inode 就分属于不同的组。kmalloc() 也是基于 slab 层之上，使用了一组通用高速缓存。</p>
<p>slab 分配器引入的目的：</p>
<ol>
<li>避免频繁使用的对象需要频繁分配和释放，降低开销</li>
<li>频繁分配回收容易导致内存碎片，减少碎片问题</li>
<li>提高性能</li>
<li>部分缓存专属于某个处理器时，可以实现无锁分配和释放（tcmalloc）</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-1540217805cb1d2ee083d293209bbbaf_r.png" alt=""></p>
<h1 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h1><p>VFS 是 Linux 提供的一个文件系统抽象层，涵盖了任何文件系统的常用功能集和行为，从而支持各种实际的文件系统（如 NTFS, FAT, EXT4）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户空间 write() -&gt; VFS sys_write() -&gt; 文件系统的写方法 -&gt; 存储设备</span><br></pre></td></tr></table></figure></p>
<p>Unix 文件系统传统抽象概念：File, DirectoryEntry, Index Node 和 Mount Point。Unix 文件的特点是面向字节流抽象设计的，具有简单、灵活的特性。在 Unix 中，目录也是普通文件，其列出了包含在目录中所有文件。</p>
<p>VFS 中的主要对象：</p>
<ol>
<li>超级块对象，代表具体已安装的文件系统</li>
<li>索引节点对象，代表一个具体的文件</li>
<li>目录项对象，代表一个目录项，是路径的组成部分</li>
<li>文件对象，代表由进程打开的文件（其实它会指向目录项对象，而目录项对象才是真正表示已打开的实际文件，因为其中包含了指向 inode 的指针）</li>
</ol>
<h1 id="块-I-O"><a href="#块-I-O" class="headerlink" title="块 I/O"></a>块 I/O</h1><p>Linux 中，设备分为三类：</p>
<ol>
<li><strong>块设备</strong>：支持随机访问固定大小的数据块，如硬盘、闪存</li>
<li><strong>字符设备</strong>：以字符流的形式被访问，如键盘</li>
<li><strong>网络设备</strong></li>
</ol>
<p>需要注意的是，针对块设备的请求会被操作系统挂起在 I/O 请求队列上，并且由 I/O 调度程序来管理请求队列。它会决定请求队列中的请求<strong>如何排序</strong>，以及<strong>何时</strong>发送到具体的块设备。之所以这么做，就是期望借助 I/O 调度程序，对请求进行<strong>合并</strong>和<strong>排序</strong>，从而有效提高系统的整体性能（也可能造成某些请求得不到公平对待，甚至出现饥饿的情况）。以下记录的是 Linux 中已经实现的几种 I/O 调度算法：</p>
<ol>
<li><p><strong>Linus 电梯</strong></p>
<ol>
<li>支持向前和向后合并（通常都是这种居多）</li>
<li>有较好的全局吞吐量</li>
<li>会发生请求饥饿问题</li>
</ol>
</li>
<li><p><strong>最终期限（deadline） I/O 调度</strong></p>
<ol>
<li>降低了系统的全局吞吐量</li>
<li>读请求超时 500ms，写请求超时 5s，超时必然得到服务，避免长时间饥饿的问题</li>
</ol>
</li>
<li><p><strong>预测（anticipatory） I/O 调度</strong></p>
<ol>
<li>目标是保持较好的读响应同时，提供良好的全局吞吐量。视图减少在进行 I/O 操作期间，处理新到的读请求带来的寻址数量</li>
<li>请求提交后不会直接返回处理其它请求，而会空闲片刻（几毫秒），等待应用提交其它读请求</li>
</ol>
</li>
<li><p><strong>完全公平排队 I/O 调度（CFQ）</strong></p>
<ol>
<li>为特殊工作负载的场景设计，每个进程都有自己的请求队列</li>
<li>以时间片轮转调度队列，处理队列中的请求</li>
</ol>
</li>
</ol>
<h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>现代操作系统通过采用虚拟内存技术，为每个进程提供了独立的地址空间，从而给每个进程营造了独享内存的假象，这是内存虚拟化的重要机制。需要注意的是，现代采用虚拟内存的系统通常都使用平坦地址空间，而非分段式的内存模式。</p>
<p>值得注意的是，内存地址空间会根据需要划分成不同的区域。内核可以给进程地址空间动态添加或减少内存区域。每个进程只能访问有效内存区域内的内存地址，每个内存区域会包含权限等属性。<strong>进程中任意有效地址只能位于唯一的区域，且这些区域不能相互覆盖</strong>。</p>
<p>内存区域可以包含各种内存对象：</p>
<ol>
<li>可执行文件代码的内存映射，text section</li>
<li>可执行文件已初始化全局变量的内存映射，data section</li>
<li>包含未初始化的全局变量，BSS 段的零页的内存映射</li>
<li>进程用户空间栈的零页内存映射</li>
<li>每个一个诸如 C 库或动态连接程序等共享的  text section, data section 和 bss 也被载入到进程地址空间</li>
<li>内存映射文件</li>
<li>共享内存段</li>
<li>匿名映射，如 malloc() 分配的内存</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mm_struct -&gt; vm_area_struct</span><br></pre></td></tr></table></figure>
<h2 id="64-位系统进程地址空间布局"><a href="#64-位系统进程地址空间布局" class="headerlink" title="64 位系统进程地址空间布局"></a>64 位系统进程地址空间布局</h2><p><img src="https://pic4.zhimg.com/80/v2-5f2b9c321b7100a11e2dae9e48bce81f_r.png" alt=""><br>每一个进程都有 64bit 的地址空间，其中用户空间可以使用一半的地址空间（128 TiB），而另一半则是内核空间使用。内核通常驻留在内存中，并且会被映射到每个进程的虚拟内存当中。而在内核中，所有的内核线程都共享一个地址空间。详细的内存布局可以参考后面的学习资料~</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>Linux 中使用三级页表完成地址转换，使用多级页表可以节约地址转换需要占用的空间。但由于完成虚拟页地址到物理页地址转换都需要在三级页表中查找到映射，开销比较高。所以很多体系结构提供了 TLB 作为地址映射的硬件缓存。<br><img src="https://pic4.zhimg.com/80/v2-e7ae1f0fcc4b3a1d0af4e65a1ca04101_r.png" alt=""><br><img src="https://pic4.zhimg.com/80/v2-ff24fef84f1c136922f8bf1f5679ea99_hd.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体上来说，这本书还是比较适合对操作系统基本概念有一定了解，且对于 Linux 内核也有一点了解的前提下阅读，否则在看到一些概念的时候会比较吃力。比如对于进程、线程的抽象定义，虚拟内存中讲到的分页、分段概念以及多级页表的概念。另外，对于常用数据结构需要有清晰的认识；并发相关的同步问题也有了解。<br>虽然整本书是基于 Linux 2.6.3x 内核为基础的，如今的 Linux 内核已经发展到 5.x 时代了，这期间变化肯定有很多。但这本书的价值还是存在的，其中讲得很多思想、方法依然实用，可以变通地去看待和理解。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol>
<li>POSIX: Portable Operating System Interface</li>
<li>TLB: Translation Lookup Buffer</li>
<li>CFS: Complete Fair Scheduler</li>
<li>CFQ: Complete Fair Queueing，这个是 IO 调度器之一</li>
<li>VFS: Virtual File System</li>
<li>VMA: Virtual Memory Area</li>
<li>MMU: Memory Map Unit</li>
<li>jiffies: Linux 中用来记录系统启动以来的节拍数的全局变量，还有一个 jiffies_64</li>
<li>ISR: Interrupt Service Routine</li>
</ol>
<h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><ul>
<li>《Linux 内核设计与实现 Linux Kernel Development，第 3 版》</li>
<li><a href="https://unix.stackexchange.com/questions/364660/are-threads-implemented-as-processes-on-linux" target="_blank" rel="noopener">Are Threads Implemented As Processes on Linux</a></li>
<li><a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">POSIX 线程</a></li>
<li><a href="https://juejin.im/post/5d23326d6fb9a07efe2de11e" target="_blank" rel="noopener">Linux 线程实现</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">Linux Sched Doc CFS</a></li>
<li><a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a></li>
<li><a href="https://www.win.tue.nl/~aeb/linux/lk/lk-9.html" target="_blank" rel="noopener">Linux Memory</a></li>
<li><a href="https://www.it.iitb.ac.in/frg/wiki/images/f/fc/113050076_Rajesh_Prodduturi_week5_presentation_3_2012-08-04.pdf" target="_blank" rel="noopener">Linux memory management</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="noopener">x86_64 内存映射</a></li>
<li><a href="https://simonis.github.io/Memory/" target="_blank" rel="noopener">The Memory Layout of a 64-bit Linux Process</a></li>
<li><a href="https://stackoverflow.com/questions/55443733/linux-kernel-memory-layout" target="_blank" rel="noopener">Linux kernel memory layout</a></li>
<li><a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html" target="_blank" rel="noopener">Chapter 3 Page Table Management</a></li>
<li><a href="https://ifaceless.space/2019/11/18/linux-kernel-scheduler-papers/">Linux 调度器资料整理</a></li>
<li><a href="https://makelinux.github.io/kernel_map/" target="_blank" rel="noopener">Linux Kernel Map</a></li>
<li><a href="https://hackernoon.com/entering-god-mode-the-kernel-space-mirroring-attack-8a86b749545f" target="_blank" rel="noopener">Entering God Mode — The Kernel Space Mirroring Attack</a></li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    iFaceless
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://ifaceless.space/2019/10/31/linux-kernel-dev-notes/" title="Linux Kernel Development 学习与总结">http://ifaceless.space/2019/10/31/linux-kernel-dev-notes/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          
            <a href="/tags/操作系统/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          
            <a href="/tags/调度器/" rel="tag"><i class="fa fa-tag"></i> 调度器</a>
          
            <a href="/tags/内存管理/" rel="tag"><i class="fa fa-tag"></i> 内存管理</a>
          
            <a href="/tags/文件系统/" rel="tag"><i class="fa fa-tag"></i> 文件系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/29/golang-traps/" rel="next" title="Go 编写姿势">
                <i class="fa fa-chevron-left"></i> Go 编写姿势
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/15/implement-lru-cache-in-go/" rel="prev" title="使用 Go 语言实现一个简单的 LRU Cache">
                使用 Go 语言实现一个简单的 LRU Cache <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="iFaceless">
            
              <p class="site-author-name" itemprop="name">iFaceless</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ifaceless" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:me@ifaceless.me" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                常用链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xieyuanpeng.com" title="Lingering Fragments" target="_blank">Lingering Fragments</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.acolyer.org/" title="The Morning Paper" target="_blank">The Morning Paper</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.freecodecamp.org" title="freeCodeCamp" target="_blank">freeCodeCamp</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-内核简介"><span class="nav-number">2.</span> <span class="nav-text">Linux 内核简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#微内核和宏内核"><span class="nav-number">2.1.</span> <span class="nav-text">微内核和宏内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与传统-Unix-区别"><span class="nav-number">2.2.</span> <span class="nav-text">与传统 Unix 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核版本"><span class="nav-number">2.3.</span> <span class="nav-text">内核版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核编译"><span class="nav-number">2.4.</span> <span class="nav-text">内核编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">2.4.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译"><span class="nav-number">2.4.2.</span> <span class="nav-text">编译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核开发特点"><span class="nav-number">2.5.</span> <span class="nav-text">内核开发特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">3.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管理进程"><span class="nav-number">3.1.</span> <span class="nav-text">管理进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度进程"><span class="nav-number">3.2.</span> <span class="nav-text">调度进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFS-调度器"><span class="nav-number">3.2.1.</span> <span class="nav-text">CFS 调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占"><span class="nav-number">3.2.2.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时调度器"><span class="nav-number">3.2.3.</span> <span class="nav-text">实时调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器类"><span class="nav-number">3.2.4.</span> <span class="nav-text">调度器类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度相关的-syscall"><span class="nav-number">3.2.5.</span> <span class="nav-text">调度相关的 syscall</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#系统调用"><span class="nav-number">4.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内核数据结构"><span class="nav-number">5.</span> <span class="nav-text">内核数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#中断和中断处理"><span class="nav-number">6.</span> <span class="nav-text">中断和中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#无须重入"><span class="nav-number">6.1.</span> <span class="nav-text">无须重入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断上下文"><span class="nav-number">6.2.</span> <span class="nav-text">中断上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下半部及推后执行的工作"><span class="nav-number">6.3.</span> <span class="nav-text">下半部及推后执行的工作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内核同步"><span class="nav-number">7.</span> <span class="nav-text">内核同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定时器和时间管理"><span class="nav-number">8.</span> <span class="nav-text">定时器和时间管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">9.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#页"><span class="nav-number">9.1.</span> <span class="nav-text">页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区"><span class="nav-number">9.2.</span> <span class="nav-text">区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页申请和释放"><span class="nav-number">9.3.</span> <span class="nav-text">页申请和释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kmalloc"><span class="nav-number">9.4.</span> <span class="nav-text">kmalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vmalloc"><span class="nav-number">9.5.</span> <span class="nav-text">vmalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slab-层"><span class="nav-number">9.6.</span> <span class="nav-text">slab 层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟文件系统（VFS）"><span class="nav-number">10.</span> <span class="nav-text">虚拟文件系统（VFS）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#块-I-O"><span class="nav-number">11.</span> <span class="nav-text">块 I/O</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程地址空间"><span class="nav-number">12.</span> <span class="nav-text">进程地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#64-位系统进程地址空间布局"><span class="nav-number">12.1.</span> <span class="nav-text">64 位系统进程地址空间布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页表"><span class="nav-number">12.2.</span> <span class="nav-text">页表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">13.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#名词解释"><span class="nav-number">14.</span> <span class="nav-text">名词解释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入学习"><span class="nav-number">15.</span> <span class="nav-text">深入学习</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黑白之院（iFaceless）</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
