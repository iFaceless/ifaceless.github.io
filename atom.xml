<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑白之院</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ifaceless.space/"/>
  <updated>2020-04-15T08:31:35.091Z</updated>
  <id>http://ifaceless.space/</id>
  
  <author>
    <name>iFaceless</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Talent Plan 之 Rust 网络编程实践入门</title>
    <link href="http://ifaceless.space/2020/04/15/talent-plan-rust-network-programming-intro/"/>
    <id>http://ifaceless.space/2020/04/15/talent-plan-rust-network-programming-intro/</id>
    <published>2020-04-15T03:35:00.000Z</published>
    <updated>2020-04-15T08:31:35.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本节将开始「Talent Plan 之 Rust 网络编程实践」系列课程学习啦，该系列课程的最终目标是使用 Rust 语言编写一个高性能的单机日志类型（log-structured） key/value 存储服务，分为客户端和服务端两个部分，并使用自定义的协议进行通信，能够使用命令行进行操作。</p><p><em>需要注意的是，该系列课程并非面向初级编程爱好者。参与该系列课程学习和实践前，最好已经有过其它语言编程经验，并且对 Rust 语言有基本了解，写过一些 Rust 代码。笔者强烈建议阅读 The Rust Book 或者《Rust 编程之道》这样的书籍来打好基础。Rust 中引入的<strong>所有权、生命周期</strong>等概念需要转变思维来理解它，这样才能更好地领悟到这门语言的精髓。</em></p><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p>以下是 Rust 网络编程实践课程大纲，总共分为六个部分（最后一个部分还没完成），循序渐进地引导我们阅读一些博客，掌握最佳编程实践，通过不断实践来加深对这门语言的理解。</p><p><img src="https://pic2.zhimg.com/v2-5aba4ddbef921406caef406e0a03ca04.jpg" alt="课程大纲"></p><h1 id="学习姿势"><a href="#学习姿势" class="headerlink" title="学习姿势"></a>学习姿势</h1><p>GitHub <a href="https://github.com/pingcap/talent-plan/" target="_blank" rel="noopener">talent-plan</a> 仓库中存放了课程中安排的编程项目，位于 <code>/rust/projects</code> 目录下。这里的每一个项目都是基于前一个项目进行改造的，在每个项目中都会增量应用一些新的 Rust 知识，比如学习引入第三方 crates，使用标准网络库，使用多线程编程改进服务性能等。</p><p>在进行每个项目实践之前，会有一个针对性的 Building Block，可以看成是一些预备知识。在预备知识中，会针对和接下来要实践的项目有关的话题，提供一些阅读材料和练习题，在阅读完成后可以通过练习题巩固下学习到的知识，这样在进行项目实践时会更加得心应手，提升效率。</p><h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><p>我们可以通过 <code>rustup</code> 管理 Rust 版本及相关的工具链。如果还没有安装 Rust 编译器，可以通过下面的命令行完成（Linux 或者 macOS 环境）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><p><code>rustup</code> 工具会为我们安装最新稳定版本的 Rust 编译器。之后也可以通过 <code>rustup update</code> 进行版本更新，或者使用 <code>rustup self uninstall</code> 完成 Rust 编译器和 <code>rustup</code> 卸载。详细操作不再赘述，可参见 <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html" target="_blank" rel="noopener">Rust Getting Started</a>。</p><p>下面笔者将要安利两款神器级插件，便于提升 Rust 编程体验。早期的 Rust IDE 支持比较差，明显没有其它语言在 IDE 中体验舒服（笔者曾经在 Clion 中尝试 Rust 插件，但是效果欠佳）。不过社区一直都在努力改进这一点，下面介绍下笔者的开发环境，仅供参考。</p><ol><li>Rust 版本：1.42</li><li>代码编辑器：Visual Studio Code</li><li>插件：<ol><li><a href="https://github.com/rust-analyzer/rust-analyzer" target="_blank" rel="noopener">rust-analyzer</a>：这个是用来替代 RLS（Rust Language Server）的实验产品，目标是提供更加优秀的 IDE 功能支持。目前虽然处于 alpha 阶段，不过相对已有的其它插件，已经非常实用了。支持代码自动补齐、文档提示、函数实现跳转、<code>main</code> 函数识别、单元测试识别等。推荐使用~</li><li><a href="https://www.tabnine.com/" target="_blank" rel="noopener">TabNine</a>：这是一款智能代码自动补全工具，采用深度学习技术加速代码编写，支持主流编程语言。值得一提的是，TabNine 服务本身是使用 Rust 编写，所以它的很多付费功能都是对 Rust 语言开放的，所以尽管使用吧。</li></ol></li></ol><p><img src="https://pic4.zhimg.com/v2-70d3d483b71301424965477e588c2f9b.jpg" alt="开发环境"></p><h1 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h1><p>掌握调试技能，对于排查程序问题非常有帮助。那么如何在 Visual Studio Code 中调试我们的 Rust 项目呢？下面将以一个简单的例子来演示下如何进行调试。</p><p>首先，在工程目录下新建一个示例项目 <code>cargo new miao</code>，然后输入如下代码，并执行 <code>cargo build</code>，生成的可执行文件位于 <code>target/debug</code> 目录下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(binary_search(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>], <span class="number">10</span>), -<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(binary_search(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>], <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">binary_search</span></span>(nums: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, target: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> nums.len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> right = nums.len() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，点击 vscode 左侧工具栏中的「调试」按钮，并且点击「create a launch.json file」按钮，创建启动配置文件。在弹出的候选框中选择「C++ (GDB/LLDB)」。<br><img src="https://pic4.zhimg.com/v2-7301528605ef12c77b1de47aabcc273a.jpg" alt="create launch json"></p><p>紧接着，编辑生成的 <code>.vscode/launch.json</code> 文件，修改其中的程序启动配置，即 <code>configurations.program</code> 指向可执行文件 <code>${workspaceFolder}/target/debug/miao</code>。<br><img src="https://pic4.zhimg.com/v2-164ce2e487a7dc66404363f10f875fc0.jpg" alt="edit launch json"></p><p>接下来，在代码中添加断点，然后执行 <code>cargo build</code>（默认会以 debug 模式构建），最后启动调试即可。</p><p><img src="https://pic2.zhimg.com/v2-49c9a51d574b00d4f27ade589fd6ca4b.jpg" alt=""></p><p>当然，也可以使用命令行工具 <code>rust-lldb</code> 执行调试，感兴趣的话，可以前往 <a href="http://blog.dreamfever.me/2019/01/13/rust-lldb-debug-guide/" target="_blank" rel="noopener">Rust LLDB 调试入门指北</a> 了解更多细节。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节对「Talent Plan 之 Rust 网络编程实践」系列课程进行了简单介绍，了解课程的具体安排，并在最后给出了 Rust 开发环境搭建的一些参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;本节将开始「Talent Plan 之 Rust 网络编程实践」系列课程学习啦，该系列课程的最终目标是使用 Rust 语言编写一个高性能的单
      
    
    </summary>
    
      <category term="Rust" scheme="http://ifaceless.space/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://ifaceless.space/tags/Rust/"/>
    
      <category term="系统编" scheme="http://ifaceless.space/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>PingCAP Talent Plan 课程介绍</title>
    <link href="http://ifaceless.space/2020/04/13/talent-plan-summary/"/>
    <id>http://ifaceless.space/2020/04/13/talent-plan-summary/</id>
    <published>2020-04-13T06:24:31.000Z</published>
    <updated>2020-04-13T10:40:05.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>随着移动互联网、物联网、云计算以及未来 5G 技术场景的应用拓展，相关应用的数据规模也在不断增长，面临的存储压力越发明显。在此背景下，传统的单机 MySQL 数据库已经无法轻松应付，即便以分库分表的方式应对，也依然存在扩展性较差、可伸缩能力不足、自动化运维能力不足等问题。伴随着 Google 内部的分布式数据库 Spanner 和 F1 的设计思想开放，<a href="https://www.pingcap.com" target="_blank" rel="noopener">PingCAP</a> 公司在 2015 年受到相应的启发后开发了 <a href="https://book.tidb.io/" target="_blank" rel="noopener">TiDB</a> 数据库，历经将近五年的迭代，目前它已经成为开源社区非常知名的 NewSQL 数据库代表了，并且已经在<a href="https://pingcap.com/cases-cn/" target="_blank" rel="noopener">诸多知名企业中得到了部署和应用</a>。</p><p>在正式引入 PingCAP Talent Plan 系列课程介绍前，有必要对 TiDB 有所了解。以下将要介绍的内容包括：</p><ol><li>TiDB 是什么？</li><li>TiDB 的核心组件有哪些？</li><li>为什么会诞生 Talent Plan 课程？</li><li>Talent Plan 课程内容是什么？</li></ol><h1 id="初识-TiDB"><a href="#初识-TiDB" class="headerlink" title="初识 TiDB"></a>初识 TiDB</h1><p>从官网上得知，TiDB 是一款真正意义上的分布式关系型数据库，并且高度兼容 MySQL 协议，这也为我们迁移广泛基于 MySQL 的应用奠定了基础。下面来看看它主要有哪些特性呢？</p><ol><li>支持 OLTP + OLAP 的混合场景，是一款 HTAP（Hybrid Transactional/Analytical Processing） 融合型数据库产品；</li><li>支持分布式事务（乐观事务+悲观事务模型均支持）；</li><li>高可用，具备故障自动恢复能力；</li><li>易于伸缩，TiDB 和 TiKV 均可水平扩展，支持海量数据存储；</li><li>TiDB 4.0 全面拥抱云原生，提供了非常多的部署方式，同时为了方便本地部署测试，<a href="https://github.com/pingcap-incubator/tiup" target="_blank" rel="noopener">tiup</a> 工具的诞生，也为像笔者这样的小白用户铺平了道路。</li></ol><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><img src="https://pic4.zhimg.com/v2-c752ea0558eed832482ebfc32708aeb1.jpg" alt=""></p><p><a href="https://book.tidb.io/session1/chapter1/tidb-architecture.html" target="_blank" rel="noopener">TiDB in Action</a> 中对于 TiDB 的整体架构有详细的描述。概括来说，TiDB 的整体架构清晰易懂，包括三个核心组件：</p><ul><li><a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">TiDB</a>：此为 SQL 层，即无状态计算层。负责 SQL 解析、优化，并生成分布式执行计划。实际的数据请求会发送给底层的存储引擎 TiKV。具体可以阅读 <a href="https://book.tidb.io/session1/chapter3/tidb-computing.html" target="_blank" rel="noopener">谈计算</a> 了解更多细节。</li><li><a href="https://github.com/pingcap/tikv" target="_blank" rel="noopener">TiKV</a>：此为存储引擎层，本身是一个支持分布式事务的 KV 数据库。TiFlash 是列式存储引擎，主要是针对分析型场景查询而设计。 具体可以阅读 <a href="https://book.tidb.io/session1/chapter2/tidb-storage.html" target="_blank" rel="noopener">说存储</a> 和 <a href="https://book.tidb.io/session1/chapter9/tiflash-architecture.html" target="_blank" rel="noopener">TiFlash 架构原理</a> 了解更多细节。</li><li><a href="https://github.com/pingcap/pd" target="_blank" rel="noopener">PD</a>：全称为 Placement Driver，它负责整个 TiDB 集群的元信息管理、存储节点访问自动负载均衡调度、分布式事务 ID 分配等，可以看成整个集群的大脑。可以阅读 <a href="https://book.tidb.io/session1/chapter4/scheduling-overview.html" target="_blank" rel="noopener">讲调度</a> 了解更多细节。</li></ul><h2 id="更多学习资源"><a href="#更多学习资源" class="headerlink" title="更多学习资源"></a>更多学习资源</h2><p>TiDB 的社区资源相当丰富，在 PingCAP 官网中可以看到很多学习资源，笔者简单整理了下，传送门如下：</p><ol><li><a href="https://pingcap.com/docs-cn/stable/how-to/get-started/deploy-tidb-from-docker-compose/" target="_blank" rel="noopener">快速入门</a>；</li><li><a href="https://pingcap.com/blog-cn/tidb-best-practice/" target="_blank" rel="noopener">最佳实践</a>；</li><li><a href="https://pingcap.com/docs-cn/stable/reference/tools/user-guide/" target="_blank" rel="noopener">周边工具</a>；</li><li><a href="https://pingcap.com/blog-cn/#DM-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB" target="_blank" rel="noopener">DM 源码解读</a>；</li><li><a href="https://pingcap.com/blog-cn/#TiDB-Binlog-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB" target="_blank" rel="noopener">TiDB Binglog 源码解读</a>；</li><li><a href="https://pingcap.com/blog-cn/#TiDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB" target="_blank" rel="noopener">TiDB 源码解读</a>；</li><li><a href="https://pingcap.com/blog-cn/#TiKV-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">TiKV 源码解读</a>；</li><li><a href="https://university.pingcap.com/" target="_blank" rel="noopener">PingCAP University</a>；</li><li><a href="https://tikv.org/deep-dive/introduction/" target="_blank" rel="noopener">深入 TiKV</a>。</li></ol><h1 id="跃跃欲试"><a href="#跃跃欲试" class="headerlink" title="跃跃欲试"></a>跃跃欲试</h1><p>如果对于分布式系统，尤其是分布式存储系统感兴趣的话，那么跟着 PingCAP 推出的系列课程学习并参与到开源项目中，一定会有很多收获。不过面对如此庞大的系统，想要深入了解其原理并能够读懂源码还是有些门槛的。好在有很多官方的源码解读博客可以学习~</p><p>不过在实际学习中还是遇到一些困难，比如编程语言（Go 和 Rust）实践不足，分布式系统理论和实践结合存在鸿沟等。所以，PingCAP 官方推出了 Talent Plan 课程，分为 TiDB 方向和 TiKV 方向。由于笔者对于 Rust 语言的了解仅仅浮于表面，实践不多，刚好 Talent Plan 提供了这样的机会，可以从 0 到 1 设计并实现一个分布式存储系统。在完成这个系列课程学习后，也能让我们更好地理解 TiDB 和 TiKV，并且在尝试阅读它们的源码时，也不至于一头雾水啦~</p><p>在 GitHub <a href="https://github.com/pingcap/talent-plan" target="_blank" rel="noopener">talent-plan</a> 仓库中可以看到关于这个系列课程的介绍。为了便于快速了解课程大纲，画了一个思维导图如下（笔者主要关注的是 Rust 部分）：</p><p><img src="https://pic4.zhimg.com/v2-2ae2e76368fd0f0cdf08042f7d195029.jpg" alt=""></p><h1 id="上车，走吧"><a href="#上车，走吧" class="headerlink" title="上车，走吧"></a>上车，走吧</h1><p>接下来，笔者将按照 Talent Plan 安排的课程循序渐进地学习，并在学习中做一些笔记，以便随时复习，欢迎围观交流~</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.pingcap.com" target="_blank" rel="noopener">PingCAP 官网</a></li><li><a href="https://book.tidb.io/" target="_blank" rel="noopener">TiDB in Action</a></li><li><a href="https://studygolang.com/articles/21947" target="_blank" rel="noopener">我们是如何设计 Rust &amp; 分布式存储教程的？ | Talent Plan 背后的故事</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;随着移动互联网、物联网、云计算以及未来 5G 技术场景的应用拓展，相关应用的数据规模也在不断增长，面临的存储压力越发明显。在此背景下，传统的
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://ifaceless.space/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="Rust" scheme="http://ifaceless.space/tags/Rust/"/>
    
      <category term="PingCAP" scheme="http://ifaceless.space/tags/PingCAP/"/>
    
      <category term="分布式系统" scheme="http://ifaceless.space/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="存储系统" scheme="http://ifaceless.space/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go RESTful API 项目模板介绍</title>
    <link href="http://ifaceless.space/2020/04/02/go-rest-api-for-beginners/"/>
    <id>http://ifaceless.space/2020/04/02/go-rest-api-for-beginners/</id>
    <published>2020-04-02T15:03:15.000Z</published>
    <updated>2020-04-13T10:50:03.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p>疫情期间学的东西比较杂（比如学习了如何在市场行情不好的时候还盲目加仓 🙂），没什么干货值得分享。不过考虑到很久都没有更新了，还是要强迫自己写一点东西，不然容易变懒。总之，多思考，多实践还是很重要。</p><p>今天主要是想把三个月前就放到 GitHub 上的 <a href="https://github.com/iFaceless/go-rest-api-starter" target="_blank" rel="noopener">go-rest-api-starter</a> 项目介绍下，目的有两个：</p><ol><li>分享下我们目前的工程实践；</li><li>给 <a href="https://github.com/ifaceless/portal" target="_blank" rel="noopener">portal</a> 增加点曝光度 😊。虽然笔者在 <a href="https://zhuanlan.zhihu.com/p/85404746" target="_blank" rel="noopener">Go 语言中如何以优雅的姿势实现对象序列化</a> 做过介绍，不过一直没有给过我们在真实环境中的具体用法，今天提供的示例也刚好可以帮助感兴趣的同学了解下它的用法。</li></ol><h1 id="0x01-为什么？"><a href="#0x01-为什么？" class="headerlink" title="0x01 为什么？"></a>0x01 为什么？</h1><p>好的工程规范是在项目实践中不断踩坑总结出来的，期间我们也遇到各种写起来不够优雅的地方，自然就需要想办法解决这些问题。经过若干项目的实践，结合遇到的问题，也造了些轮子便于提升<strong>开发幸福度</strong>。沉淀和提炼的结果，便是一套可以沿袭的项目脚手架，集成了一些我们认为的「最佳实践」。</p><p>笔者相信不同的团队有不同的想法，但本质上都是更好的服务于业务。我们希望能够以<strong>一致</strong>、<strong>清晰</strong>的方式来编写代码，并且保证项目结构不被随意破坏，项目的可维护性大于一切。另外，对于业务框架，也不应该一味地排斥。合理地使用业务框架，既有利于简化业务代码编写，又有利于理解和维护。</p><h1 id="0x02-是什么？"><a href="#0x02-是什么？" class="headerlink" title="0x02 是什么？"></a>0x02 是什么？</h1><p><a href="https://github.com/iFaceless/go-rest-api-starter" target="_blank" rel="noopener">go-rest-api-starter</a> 是一个完整的 RESTful API 项目（商品管理后台+前台接口，源自 <a href="https://dev.aizoo.com" target="_blank" rel="noopener">aizoo</a> 管理后台），演示了我们目前的工程实践是什么样的。当然，团队内部版本使用了一些非开源框架，不过同样的理念换成别的框架依然可行。所以，在该项目中，笔者将一些内部框架换成了开源框架，方便大家参考。</p><p>从这个项目中可以了解到什么？</p><ol><li>整体的项目结构，分层情况；</li><li>Model 层怎么编写，关联资源如何以属性方式暴露；</li><li>Schema 层怎么编写，表单校验逻辑放在什么位置；</li><li>复杂业务逻辑如何在 Controller 层实现；</li><li>如何保证 Handler 层整洁清晰；</li><li><a href="https://github.com/ifaceless/portal" target="_blank" rel="noopener">portal</a> 所扮演的角色，如何简化字段格式化逻辑。</li></ol><p>首先来看下项目结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">├── .env（环境变量配置，资源连接串等）</span><br><span class="line">├── .env_unittest（跑单元测试使用的测试资源配置）</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── bin</span><br><span class="line">│   ├── starter-admin（面向管理后台的 RESTful API 服务器）</span><br><span class="line">│   └── starter-web（面向客户端、PC 等前台的 RESTful API 服务器）</span><br><span class="line">├── cmd（各个服务启动的入口）</span><br><span class="line">│   ├── admin（管理后台）</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── bee（离线异步任务）</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── service（RPC 服务）</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   └── web（客户端、PC、小程序等前台）</span><br><span class="line">│       └── main.go</span><br><span class="line">├── go.mod（依赖包 go modules）</span><br><span class="line">├── pkg</span><br><span class="line">│   ├── admin（管理后台服务）</span><br><span class="line">│   │   ├── handler</span><br><span class="line">│   │   ├── router.go</span><br><span class="line">│   │   ├── schema（和返回的 JSON 数据关联的资源结构体定义）</span><br><span class="line">│   │   └── validator（通用的校验代码）</span><br><span class="line">│   ├── config（资源配置）</span><br><span class="line">│   │   ├── fixture.go</span><br><span class="line">│   │   ├── init.go</span><br><span class="line">│   │   └── mysql.go</span><br><span class="line">│   ├── constant（常量、枚举定义）</span><br><span class="line">│   │   ├── enum.go</span><br><span class="line">│   │   ├── gen_enum.go</span><br><span class="line">│   │   └── macro.go</span><br><span class="line">│   ├── controller（复杂业务逻辑）</span><br><span class="line">│   │   ├── company.go</span><br><span class="line">│   │   ├── company_test.go</span><br><span class="line">│   │   └── product.go</span><br><span class="line">│   ├── job（异步离线任务业务逻辑）</span><br><span class="line">│   │   └── after_product_created.go</span><br><span class="line">│   ├── middleware（可复用的中间件）</span><br><span class="line">│   │   └── cors.go</span><br><span class="line">│   ├── model（Models，可能还会聚合来自 RPC 等数据源，数据模型抽象）</span><br><span class="line">│   │   ├── company.go</span><br><span class="line">│   │   ├── doc.go</span><br><span class="line">│   │   ├── init.go</span><br><span class="line">│   │   └── product.go</span><br><span class="line">│   ├── util（工具集）</span><br><span class="line">│   │   ├── orderby.go</span><br><span class="line">│   │   ├── pic</span><br><span class="line">│   │   ├── rest</span><br><span class="line">│   │   ├── seqgen</span><br><span class="line">│   │   └── toolkit</span><br><span class="line">│   └── web（前台服务）</span><br><span class="line">│       ├── handler</span><br><span class="line">│       ├── router.go</span><br><span class="line">│       └── schema</span><br><span class="line">├── script（一些脚本文件）</span><br><span class="line">│   └── 20200101</span><br><span class="line">└── testdata（单元测试有关测试数据、表结构定义）</span><br><span class="line">    ├── fixtures</span><br><span class="line">    │   ├── company.yml</span><br><span class="line">    │   ├── doc.yml</span><br><span class="line">    │   └── product.yml</span><br><span class="line">    └── schema.sql</span><br></pre></td></tr></table></figure><h1 id="0x03-说-Handler"><a href="#0x03-说-Handler" class="headerlink" title="0x03 说 Handler"></a>0x03 说 Handler</h1><p>我们希望 Handler 层的逻辑不要太过复杂，曾经在看某后台项目时，某 Handler 足足近百行代码，糅杂了大量的字段校验逻辑、业务逻辑、数据格式化逻辑等，极度啰嗦，难以修改和维护，这个是我们不太想要的。</p><p>理想情况下，Handler 层应该保证足够轻量，它就应该像是胶水，负责将 Model 层、Controller 层以及 Schema 层粘在一起。我们来看看下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProducts</span><span class="params">(c *rest.Context)</span> <span class="params">(rest.Response, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 复杂逻辑下沉到 Controller 层实现</span></span><br><span class="line">    products, total, err := controller.GetProducts(</span><br><span class="line">        c.Query(<span class="string">"title"</span>),</span><br><span class="line">        c.QueryWithFallback(<span class="string">"order_by"</span>, <span class="string">"-created_at"</span>),</span><br><span class="line">        c.Offset(),</span><br><span class="line">        c.Limit(),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Model -&gt; Schema 渲染</span></span><br><span class="line">    <span class="keyword">var</span> schemas []schema.OutputProductSchema</span><br><span class="line">    <span class="comment">// 借助 portal.Only，可以在请求的时候指定只吐出需要的字段值</span></span><br><span class="line">     err = portal.Dump(&amp;schemas, products, portal.Only(strings.Split(c.QueryWithFallback(<span class="string">"only"</span>, <span class="string">""</span>), <span class="string">","</span>)...))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> rest.NewPage(c, schemas, total), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateProduct</span><span class="params">(c *rest.Context)</span> <span class="params">(rest.Response, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 表单校验和处理</span></span><br><span class="line">    <span class="keyword">var</span> input schema.InputProductSchema</span><br><span class="line">    err := c.BindJSON(&amp;input)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> product model.ProductModel</span><br><span class="line">    err = portal.Dump(&amp;product, input)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 业务逻辑处理</span></span><br><span class="line">    prodID, err := controller.CreateProduct(&amp;product, &amp;input)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 返回处理结果</span></span><br><span class="line">    <span class="keyword">return</span> gin.H&#123;<span class="string">"success"</span>: <span class="literal">true</span>, <span class="string">"product_id"</span>: cast.ToString(prodID)&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来看，Handler 层无非执行如下几个步骤（Keep It Simple, Stupid）：</p><ol><li>输入参数校验和处理（实际逻辑要么封装在 Schema 层，要么在框架层解决）；</li><li>业务逻辑处理（Controller 层负责）；</li><li>结果返回。</li></ol><h1 id="0x04-讲-Schema-与-Model"><a href="#0x04-讲-Schema-与-Model" class="headerlink" title="0x04 讲 Schema 与 Model"></a>0x04 讲 Schema 与 Model</h1><p>这两个适合放在一起讲，因为 Schema 的字段映射的正是对应的 Model 中相关字段。也许这里会有疑惑，为什么我们不直接在 Model 层，给某个 Field 加个 Tag <code>json: field_name</code>，直接序列化返回出去呢？为何非要生硬地写一个 Schema 结构体再做映射呢？</p><p>接下来将结合具体的场景来回答这个问题：</p><ol><li>API 要求返回的字段类型和 Model 中实际类型不一致（如 model.ID 为 int 类型，但 API 要求返回 string 类型）；</li><li>某些字段要求是可选返回字段（这时可以轻松地修改 Schema 中的字段为 <code>*type</code> 即可）。</li></ol><p>总之，Model 层作为 Source of Truth，保持最原始的格式最好。Schema 层则根据具体的业务场景进行变动，对于不适配的场景，自定义 format 方法完成转换即可。这样可以将改动只聚焦在较小的范围，避免到处修改类型，想想也心累。</p><p>最后要提的一点是 Model 的关联资源，我们推荐的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProductModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">int64</span></span><br><span class="line">    CompanyID <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// ... other fields ignored</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Company 返回商品关联的公司（来源于别的表）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *ProductModel)</span> <span class="title">Company</span><span class="params">()</span> <span class="params">(*CompanyModel, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> company CompanyModel</span><br><span class="line">    err := DB.Where(<span class="string">"id = ?"</span>, pd.CompanyID).Find(&amp;company).Error</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> gorm.IsRecordNotFoundError(err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.WithStack(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;company, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rate 返回商品关联的评分（来源于 RPC 调用）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *ProductModel)</span> <span class="title">Rate</span><span class="params">()</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rpc.GetProductRate(pd.ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 Schema 层，我们只需要声明需要映射的字段，在经过 <code>portal.Dump</code> 时，框架会自动完成相关字段映射，并将返回的值填充到对应的 Schema 字段中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OutputCompanySchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">string</span>           <span class="string">`json:"id"`</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OutputProductSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            *<span class="keyword">string</span>               <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Company       *OutputCompanySchema  <span class="string">`json:"company,omitempty" portal:"nested;async"`</span></span><br><span class="line">    CreatedAt     *field.Timestamp      <span class="string">`json:"created_at,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output OutputProductSchema</span><br><span class="line">portal.Dump(&amp;output, product)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时将 output json 序列化，就是想要得到的结果</span></span><br></pre></td></tr></table></figure><h1 id="0x05-碎碎念"><a href="#0x05-碎碎念" class="headerlink" title="0x05 碎碎念"></a>0x05 碎碎念</h1><p>最近几天在尝试重构某个项目的某个巨长的函数（接近 250 行，代码就不贴了，怕被打 😝），每次修改它的时候心态都要崩。但说起来，它也没有多么复杂的业务逻辑，只是产品线类型较多，糅杂了资源获取逻辑、字段格式化逻辑等等。严格来说，完全可以使用上述的 Model &amp; Schema 分层思路进行重构，但是该函数做了些优化：</p><ol><li>使用 <code>batch_get_resource</code> 接口替代 <code>get_resource</code> 接口；</li><li>并发获取多个产品线的章节信息等。</li></ol><p>因为这种优化的引入，会导致上述写法上存在一些不太优雅的地方。接下来举个栗子🌰能够更好地说明现在遇到的问题：</p><p>先看看常规的 StudentModel &amp; StudentSchema 定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StudentModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    MemberID <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Member 返回关联的账号详情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StudentModel)</span> <span class="title">Member</span><span class="params">(ctx context.Member)</span> *<span class="title">rpc</span>.<span class="title">Member</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注意，这里使用的是单次调用，而非批量调用</span></span><br><span class="line">    <span class="keyword">return</span> rpc.GetMemberByID(s.MemberID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemberSchema <span class="keyword">struct</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StudentSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    Member *MemberSchema <span class="string">`portal: nested`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一页需要获取 20 个学生信息，portal 序列化时，会默认启动 20 个 goroutine 分别处理 20 个 StudentSchema 的渲染。这样的话，具体到 StudentModel.Member 获取时，就会产生 20 个并发的 <code>GetMemberByID</code> 请求，相对串行执行，这种方式自然可以提高速度。但是代价也很明显，产生的请求较多。对于一些后台项目这样做还好，但是对于 C 端接口，如果请求量较高，那请求放大会比较严重。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students := DBGetStudents(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output []StudentSchema</span><br><span class="line">portal.Dump(&amp;output, students)</span><br></pre></td></tr></table></figure><p>假设上游为我们提供了类似 <code>func BatchGetMemberByID(memberIDs []int64) map[int64]*Member</code> 方法，那么们可以通过批量调用的方式解决上面提到的问题。不过，此时我们需要同时修改原有的 Model 层和 Schema 层如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StudentModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    MemberID <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StudentSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    Member *MemberSchema <span class="string">`portal: nested`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StudentSchema)</span> <span class="title">GetMember</span><span class="params">(ctx context.Context, student *StudentModel)</span> *<span class="title">rpc</span>.<span class="title">Member</span></span> &#123;</span><br><span class="line">    <span class="comment">// 假设外层批量调用结果放在 ctx 中传入</span></span><br><span class="line">    v := ctx.Value(<span class="string">"members"</span>).(<span class="keyword">map</span>[<span class="keyword">int64</span>]*rpc.Member)</span><br><span class="line">    <span class="keyword">return</span> v[student.MemberID]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Handler 层，我们需要手动调用 <code>BatchGetMemberByID</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">students := DBGetStudents(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集 member_ids</span></span><br><span class="line">memberIDs := <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="built_in">len</span>(students))</span><br><span class="line"><span class="keyword">for</span> i, s := <span class="keyword">range</span> students &#123;</span><br><span class="line">    memberIDs[i] = s.MemberID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量调用一次</span></span><br><span class="line">members := rpc.BatchGetMemberByID(memberIDs)</span><br><span class="line">ctx = context.WithValue(<span class="string">"members"</span>, members)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output []StudentSchema</span><br><span class="line">portal.DumpWithContext(ctx, &amp;output, students)</span><br></pre></td></tr></table></figure><p>嗯，似乎看起来并没有多么繁琐嘛。不过这样的写法很容易导致 Handler 层膨胀，试想再加点别的关联资源获取呢？那各种 <code>BatchGetShit</code> 就怼进去了。</p><p>所以，我们究竟怎么才能做到原有的 Model 层依然保持简单的 <code>rpc.GetResourceByID</code> 这种简单的调用方式；Schema 层也不用做侵入式修改；Handler 层更不用忍受可能导致的代码膨胀问题呢？也许我们可以对 <code>rpc.GetResourceByID</code> 做点包装，在底层框架上，自动支持请求合并；而对于上层调用方无感知。</p><p>熟悉 HTTP/2 的同学应该了解到其中一个特色是多路复用，避免每次新的请求都要进行 TCP+TLS 握手。那么如果我们能够做到在底层将上层的 <code>rpc.GetResourceByID</code> 自动合并为 <code>rpc.BatchGetResourceByID</code>，也能很大程度上提高请求效率，减少上游服务的请求压力。虽然相对于并发 20 个 <code>rpc.GetResourceByID</code> 请求，自动合并技术可能因为优化不到位或者策略上的问题，响应时间可能稍长，但是相对于串行调用，速度理论上会有很大提升。</p><p><img src="https://camo.githubusercontent.com/878e48b845b8e24e870c9ecd4642b0ae2ddd5dd0/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d37303061333265333865316465303361633639393732343138303462356136622e706e67" alt=""></p><p>关于这个请求合并的策略如何实现呢？可以想象下 <code>rpc.BatchGetResourceByID</code> 就像一辆往返于两地的公共汽车，假设它有两个关键属性：</p><ol><li>车上乘客一旦坐满立刻出发（不许加塞，咱们要合法经营）；</li><li>到达一定超时时间立刻出发（守时很重要，保证服务质量）；</li><li>到达目的地后，还要在返程时将同一批乘客尽可能全部带回来（假设乘客们要么买到了想要的礼物 <code>result</code> 或者像笔者一样比较穷就什么也没买 <code>error</code>）。</li></ol><p>基于这样的假设，尝试使用 Go 语言实现了一个简单的 Demo，感兴趣的同学可以前往仓库 <a href="https://github.com/iFaceless/rpcx" target="_blank" rel="noopener">rpcx</a> 查看。尝试引入了一个 Proxy 层，由 Proxy 层收集业务方的调用参数，并批量发起调用，最后将结果分派给业务方。当然，目前 Proxy 是以一个单独的 goroutine 部署；理想情况下，如果能用 sidecar 方式部署，甚至可以做到语言无关，独立升级，其它语言实现的服务也可以享受到同样的优化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    rsdk.Init(<span class="number">10</span>, <span class="number">1</span>*time.Millisecond)</span><br><span class="line">    getMembersAutoAgg(ctx, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMembersAutoAgg</span><span class="params">(ctx context.Context, max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= max; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 底层自动将并发单次调用转换成批量调用</span></span><br><span class="line">         <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            r, err := rsdk.GetMember(ctx, <span class="keyword">int64</span>(n)+<span class="number">1</span>)</span><br><span class="line">            _, _ = r, err</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，想要在生产环境搞事情，还有很长的路要走。比如 Proxy 监控怎么做？单点问题怎么解解决？是否会成为接口调用瓶颈？如何与公司现有的 RPC 框架结合？收益是否真的达到预期（分析具体场景）？</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>以上分享了一些关于工程实践方面的思考，欢迎指正，有什么好的想法也欢迎留言交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-引言&quot;&gt;&lt;a href=&quot;#0x00-引言&quot; class=&quot;headerlink&quot; title=&quot;0x00 引言&quot;&gt;&lt;/a&gt;0x00 引言&lt;/h1&gt;&lt;p&gt;疫情期间学的东西比较杂（比如学习了如何在市场行情不好的时候还盲目加仓 🙂），没什么干货值得分享。不
      
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="RESTful" scheme="http://ifaceless.space/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>Rust async-std 入门</title>
    <link href="http://ifaceless.space/2020/01/20/rust-async-std-intro/"/>
    <id>http://ifaceless.space/2020/01/20/rust-async-std-intro/</id>
    <published>2020-01-20T10:00:40.000Z</published>
    <updated>2020-01-21T03:45:37.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近打算基于 Rust <a href="https://github.com/async-rs/async-std" target="_blank" rel="noopener">async-std</a> 造轮子，自然是要熟悉下这个库。以下内容是根据 Rust <a href="https://github.com/async-rs/async-std" target="_blank" rel="noopener">async-std</a> 官方文档翻译整理，当然也加入了部分自己的理解，有不到位的地方还请指点。</p><p><a href="https://github.com/async-rs/async-std" target="_blank" rel="noopener">async-std</a> 旨在简化异步编程，由于是模拟 Rust 标准库接口，所以熟悉标准库的话，使用起来也会非常舒服。目前 <code>async-std</code> 给我们提供了很多接口：文件系统、网络、计时器等等；它还提供了一个 <code>task</code> 模型，有点类似 Rust 标准库中的 <code>thread</code> 模块。此外，还有 <code>async/await</code> 风格的 <code>Mutex</code> 原语。</p><a id="more"></a><p>Rust 中有两种类型的 <code>Future</code>：</p><ol><li>源自<a href="https://doc.rust-lang.org/std/future/trait.Future.html" target="_blank" rel="noopener">标准库</a>的 <code>std::future::Future</code></li><li>源自 <a href="https://docs.rs/futures/0.3/futures/prelude/trait.Future.html" target="_blank" rel="noopener">futures-rs crate</a>  的 <code>futures::future::Future</code></li></ol><p>背景是这样的，<a href="https://docs.rs/futures/0.3/futures/prelude/trait.Future.html" target="_blank" rel="noopener">futures-rs crate</a>  中定义的 future 是 Future 类型最初的实现。Rust 为了支持 <code>async/await</code> 语法，就把核心的 <code>trait Future</code> 转移到了标准库中，也就是现在的 <code>std::future::Future</code>。所以，我们可以把 <code>std::future::Future</code> 看作是 <code>futures::future::Future</code> 的最小子集。</p><p>我们需要严格区分 <code>std::future::Future</code> 和 <code>futures::future::Future</code>，以及 <code>async-std</code> 是如何使用它们的。总的来说，普通的用户一般是不会和 <code>std::future::Future</code> 打交道的（除了使用 <code>.await</code> 调用）。通常只有实现 <code>Future</code> 的开发者才会关注 <code>std::future::Future</code> 的内部工作机制。过去很多在 <code>Future</code> 中定义的功能都被移动到了 <code>FuturesExt</code> 扩展 trait 中。所以，可以将 <code>futures</code> 库当作是核心 Rust 异步功能的扩展。</p><p>那么，上面一直提到的 Futures 究竟是何方神圣？又是怎么被执行的呢？简单来说，<strong>Futures 就是对于代码是如何运行的一种抽象</strong>，它们其实什么也不做。那么怎么推进执行并获得结果呢？答案是依靠执行器 <code>executor</code>，它会决定<strong>何时</strong>及<strong>如何</strong>执行你的 Futures。<code>async-std::task</code> 模块就为我们提供了这样的执行器接口。</p><h1 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h1><p>Rust 有个非常亮眼的特性叫<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">「无谓并发」</a>，也就是说我们在编写多线程应用时，可以在获得并发特性的同时，不用担心数据竞争的问题（编译器会在编译时就能检查到数据竞争的问题）。</p><p>Futures 是对<strong>计算</strong>的抽象，它们描述了「做什么（what）」，但是与「在哪儿（where）」、「什么时候（when）」执行是分开的。因此，我们的目标是将代码打散成小段的、可组合的行为，这样可以作为系统的一部分执行。接下来我们来看看什么是<strong>计算</strong>（compute things），并找到可以抽象的地方。</p><h2 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a>Send 和 Sync</h2><p>Rust 安全并发中有两个重要的抽象（Markers）：<code>Send</code> 和 <code>Sync</code>。下面来看看简单的介绍：</p><ul><li><code>Send</code> 标记的数据类型是可以安全地从一个计算（computation）<strong>转移到（moved）</strong>另外一个并发计算（所有权也同样被转移了，发送方将不能再访问它）。</li><li><code>Sync</code> 是指我们可以在并发环境中<strong>共享（sharing）</strong>数据。</li></ul><p>以上没有使用 <code>thread</code> 即线程这样的字眼，而是使用了抽象的 <code>computation</code>。<code>Send</code> 和 <code>Sync</code> 最强大的特点在于它为我们减轻了知道共享什么的负担。在实现时，我们只需要知道对于相应的数据类型采用什么分享方式即可。</p><p>关于 <code>Send</code> 和 <code>Sync</code> 的组合还有更多有趣的特性，可以参考 <a href="https://doc.rust-lang.org/stable/book/ch16-04-extensible-concurrency-sync-and-send.html" target="_blank" rel="noopener">Rust Book</a> 了解更多。</p><h2 id="什么是计算（computation）"><a href="#什么是计算（computation）" class="headerlink" title="什么是计算（computation）"></a>什么是计算（computation）</h2><p>所谓的计算（computation）是指一个可组合的操作序列，可以基于决策分支，可以一直推进运行到结束，最终返回结果或者错误。</p><h2 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h2><p>如上所述，<code>Send</code> 和 <code>Sync</code> 都是描述数据的；但应用程序可不止数据，我们还要知道如何计算出数据，由此引入了 <code>Futures</code>。我们可以看看 <code>Futures</code> 是怎么允许我们用自然语言表达要做的事情的，<code>Futures</code> 从这样的计划：</p><ul><li>Do X</li><li>If X succeeded, do Y</li></ul><p>变成了：</p><ul><li>Start doing X</li><li>Once X succeeds, start doing Y</li></ul><p>相比于告诉计算机要做什么，并且根据当前结果决定下一步做什么；延迟计算就是让我们告诉计算机要开始做什么，并响应<strong>未来</strong>可能发生的事件。</p><h2 id="从简单的例子开始"><a href="#从简单的例子开始" class="headerlink" title="从简单的例子开始"></a>从简单的例子开始</h2><p>下面的例子是从指定的文件中读取内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在任意时刻调用上面的函数，也很直观。问题是，一旦调用上述函数，控制权就会转移至被调用的函数直到其返回。需要说明的是，上述返回值描述的是过去。而过去存在的问题是：所有的决策都已经确定了。但也不是没有优点：返回的结果很明显，我们可以直接将程序过去计算的结果解包（unwrap）出来，然后决定如何使用它。</p><p>但我们还是想要抽象计算，并让别人选择如何运行它。所以我们需要一种类型，可以描述计算过程，但是又不执行它。👆 上面的函数只能让我们在调用前或者调用后执行操作。这其实并非预期的，我们希望能够在在运行的时候做点别的事情（实际上就是能够打断执行流）。当在并行编程时，这也剥夺了我们在第一个任务运行时启动另外一个并行任务的能力（这时控制权已经转移给正在执行的函数了）。</p><p>此处虽然可以引入线程，但是线程本身是非常特定的并发原语，而我们需要寻找的是一种<strong>抽象</strong>。具体来说，这样的抽象就是用来表示一个进行中的工作，会在未来产生结果。下面看看非完整定义的 <code>Future</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="comment">// Ouput 是一个泛型，表示输出结果的泛型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="comment">// poll 方法会返回当前计算的状态，poll 方法会返回两种结果：</span></span><br><span class="line">    <span class="comment">// 1. `Poll::Ready`，表示计算结束</span></span><br><span class="line">    <span class="comment">// 2. `Poll::Pending`，表示计算尚未结束</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们可以通过 <code>poll()</code> 方法检查 <code>Future</code> 是否完成，如果已经完成，则返回对应的结果。显然，最简单的机制就是在循环中不断轮询；不过我们通常使用成熟的 runtime 来执行。<em>需要注意的是，在 <code>poll()</code> 返回 <code>Poll::Ready</code> 后，继续调用可能会有令人困惑的行为产生，具体可以参见 <a href="https://doc.rust-lang.org/std/future/trait.Future.html" target="_blank" rel="noopener">futures-docs</a></em>。</p><h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p>实际上 <code>Future</code> 在 Rust 中已经存在一段时间了，只是直接构建和描述它们比较麻烦。因此，<code>async</code> 关键词就是我们的救星，下面的例子中演示了 <code>async-std</code> 搭配 <code>async/await</code> 重构上面的函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 标记函数体是一个延迟计算对象，当函数调用时，会产生一个 `Future&lt;Output = io::Result&lt;string&gt;&gt;`，</span></span><br><span class="line"><span class="comment">// 该值并非立即返回的结果 `io::Result&lt;String&gt;`，</span></span><br><span class="line"><span class="comment">//（准确地说，是产生了实现了 `Future&lt;Output = io::Result&lt;String&gt;&gt;` 的类型）。</span></span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(path).await?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents).await?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="await-干了什么"><a href="#await-干了什么" class="headerlink" title=".await 干了什么"></a><code>.await</code> 干了什么</h2><p>顾名思义，<code>.await</code> 表示等待请求行为（requested action）直到完成，然后才会继续后续的执行。准确的来说，<code>.await</code> 是一个标记，表示此处的代码将会等待直到 <code>Future</code> 产生结果。至于 Future 是怎么结束的，我们不用关心。<code>.await</code> 会让运行时掌控这段代码的执行，至于在计算结束时要执行哪些操作都由运行时来操心。当你编写的操作在后台完成时，它会回到标记点，继续后续的操作。所以这种模式也称为 <strong>事件驱动编程（evented programming）</strong>，因为我们在等待某些事件发生（如打开文件），并据此作出响应（比如开始读取内容）。</p><p>当有 2 个及以上这样的函数在同时运行时，我们的运行时系统就能够处理当前所有进行的事件了，避免了傻傻地等待。</p><h1 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h1><p>我们已经知道什么是 Futures 了，那具体怎么运行它们呢？这就是接下来要介绍的 <code>tasks</code> 模块要做的事情。下面看个简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::&#123;fs::File, io, prelude::*, task&#125;;</span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file: File = File::open(path).await?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents).await?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// `spawn` 方法接收一个 `Future`，并且在一个任务中执行它。</span></span><br><span class="line">    <span class="comment">// 该函数会返回 `JoinHanle`。</span></span><br><span class="line">    <span class="keyword">let</span> reader_task = task::spawn(async &#123;</span><br><span class="line">        <span class="comment">// 这里是一个异步块，必须要使用异步块才能调用异步函数，同时</span></span><br><span class="line">        <span class="comment">// 也会引导编译器将所有相关的指令包含进来。Rust 中所有的块</span></span><br><span class="line">        <span class="comment">// 都会返回一个值，而 `async` 块则返回的是类型为 </span></span><br><span class="line">        <span class="comment">// `Future` 的值</span></span><br><span class="line">        <span class="keyword">let</span> result = read_file(<span class="string">"data.csv"</span>).await;</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="literal">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s),</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">"Error reading &#123;:?&#125;"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Started task!"</span>);</span><br><span class="line">    task::block_on(reader_task);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Stopped task!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 的 Futures 有时也叫「冷（cold）」Futures，你需要运行它们的东西。为了运行一个 Future，可能还需要一些额外的记账工具：比如当前 Future 是否在运行中还是已经结束，在内存中的位置和当前的状态。这种记账逻辑就被抽象到了 <code>Task</code> 中。</p><p><code>Task</code> 类似于 <code>Thread</code>，但也有些许不同：它是由应用程序（用户空间）被调度，操作系统内核不会感知；一旦到了某个点需要等待，应用程序自己需要负责唤醒任务。<code>async_std</code> 的任务可以拥有名称和 ID。</p><p>当通过 <code>spawn</code> 生成任务后，会一直在后台运行。返回的 <code>JoinHandle</code> 本身是一个 Future，它会在 <code>Task</code> 运行结束后（run to conclusion）也会结束。类似 <code>threads</code> 和 <code>join</code> 函数，我们可以调用对 <code>JoinHandle</code> 调用 <code>block_on</code> 函数，从而阻塞程序（准确来说是调用线程被阻塞）直到其运行结束。</p><h2 id="Task-中是如何推进-Future-完成计算的呢？"><a href="#Task-中是如何推进-Future-完成计算的呢？" class="headerlink" title="Task 中是如何推进 Future 完成计算的呢？"></a>Task 中是如何推进 Future 完成计算的呢？</h2><p>通过简单阅读源码，可以在 <a href="https://github.com/async-rs/async-std/blob/d283352a9add80f722c272238c6f9e122976aedb/src/task/block_on.rs#L129" target="_blank" rel="noopener">src/task/block_on.rs</a> 看到执行的逻辑，当 Task 被调度执行时，对应的  <code>run</code> 函数也会被执行，进而推进 Future 中的计算逻辑直到完成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Blocks the current thread on a future's result.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;F, T&gt;(future: F) -&gt; T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: Future&lt;Output = T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    CACHE.with(|cache| &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> Poll::Ready(t) = future.as_mut().poll(cx) &#123;</span><br><span class="line">                <span class="comment">// Save the parker for the next invocation of `block`.</span></span><br><span class="line">                cache.set(<span class="literal">Some</span>(arc_parker));</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Yield a few times or park the current thread.</span></span><br><span class="line">            <span class="keyword">if</span> step &lt; <span class="number">3</span> &#123;</span><br><span class="line">                thread::yield_now();</span><br><span class="line">                step += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arc_parker.park();</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JoinHandle-是如何将任务结果返回的呢？"><a href="#JoinHandle-是如何将任务结果返回的呢？" class="headerlink" title="JoinHandle 是如何将任务结果返回的呢？"></a>JoinHandle 是如何将任务结果返回的呢？</h2><p>翻阅 <a href="https://github.com/async-rs/async-std/blob/d283352a9add80f722c272238c6f9e122976aedb/src/task/join_handle.rs#L15" target="_blank" rel="noopener">src/task/join_handle.rs</a> 源码得知，它其实也是一个实现了 <code>Future trait</code> 的对象，具体逻辑如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">JoinHandle</span></span>&lt;T&gt;(async_task::JoinHandle&lt;T, Task&gt;);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Future <span class="keyword">for</span> JoinHandle&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> Pin::new(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span>).poll(cx) &#123;</span><br><span class="line">            Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">            <span class="comment">// 如果是 None，表示任务 panic 或者被取消了</span></span><br><span class="line">            Poll::Ready(<span class="literal">None</span>) =&gt; <span class="built_in">panic!</span>(<span class="string">"cannot await the result of a panicked task"</span>),</span><br><span class="line">            <span class="comment">// 当任务结束，自然会拿到具体结果</span></span><br><span class="line">            Poll::Ready(<span class="literal">Some</span>(val)) =&gt; Poll::Ready(val),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>async_std</code> 中的 <code>JoinHandle</code> 实际是对 <code>async_task::JoinHandle</code> 的包装，我们可以深入看下具体是怎么从 Task 中取到结果的：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-task-1.1.0/src/join_handle.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A handle that awaits the result of a task.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// * `None` 表示任务被取消或者 panic 了</span></span><br><span class="line"><span class="comment">/// * `Some(result)` 表示任务结束，返回的结果 `result` 类型为 `R`</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">JoinHandle</span></span>&lt;R, T&gt; &#123;</span><br><span class="line">    <span class="comment">/// A raw task pointer.</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) raw_task: NonNull&lt;()&gt;,</span><br><span class="line">    <span class="comment">/// A marker capturing generic types `R` and `T`.</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) _marker: PhantomData&lt;(R, T)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Future <span class="keyword">for</span> JoinHandle&lt;R, T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">Option</span>&lt;R&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> ptr = <span class="keyword">self</span>.raw_task.as_ptr();</span><br><span class="line">        <span class="keyword">let</span> header = ptr <span class="keyword">as</span> *<span class="keyword">const</span> Header;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> state = (*header).state.load(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// If the task has been closed, notify the awaiter and return `None`.</span></span><br><span class="line">                <span class="keyword">if</span> state &amp; CLOSED != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">return</span> Poll::Ready(<span class="literal">None</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If the task is not completed, register the current task.</span></span><br><span class="line">                <span class="keyword">if</span> state &amp; COMPLETED == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务完成，提取结果</span></span><br><span class="line">                <span class="keyword">match</span> (*header).state.compare_exchange(</span><br><span class="line">                    state,</span><br><span class="line">                    state | CLOSED,</span><br><span class="line">                    Ordering::AcqRel,</span><br><span class="line">                    Ordering::Acquire,</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="literal">Ok</span>(_) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 从这里把任务结果获取出来（挺 Hack 的），就是下面的 output.read()</span></span><br><span class="line">                        <span class="keyword">let</span> output = ((*header).vtable.get_output)(ptr) <span class="keyword">as</span> *<span class="keyword">mut</span> R;</span><br><span class="line">                        <span class="keyword">return</span> Poll::Ready(<span class="literal">Some</span>(output.read()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">Err</span>(s) =&gt; state = s,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="async-std-中的-Task"><a href="#async-std-中的-Task" class="headerlink" title="async_std 中的 Task"></a>async_std 中的 Task</h2><p>Task 是 <code>async_std</code> 中最核心的抽象之一，和 Rust 中的 <code>thread</code> 类似。<code>Tasks</code> 和运行时虽然也有关联，但它们是分开的。<code>async_std</code> Task 有如下几个特性：</p><ul><li>所有任务是单次分配的（in one single allocation）；</li><li>所有任务都有一个 <code>backchannel</code>，这样可以通过 <code>JoinHandle</code> 将结果和错误传递到对应的任务（spawning task）；</li><li>它们携带用于调试的元信息；</li><li>它们支持 任务级别的 local storage。</li></ul><p><code>async_std</code> 任务 API 会处理背后的 runtime 初始化（setup）和清理（teardown）工作，作为用户，我们不需要显式地启动运行时（这个和 Python 3 有丢丢区别）。</p><h2 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h2><p>一般我们认为 Tasks 都是并发执行的，可能它们会共享同一个执行线程（在该线程上切换任务执行）。这同时也意味着如果在某个执行线程上调用了阻塞 API（比如 <code>std::thread::sleep</code> 或者标准库的 IO 函数），会导致对应执行线程阻塞，从而导致<strong>该执行线程上的所有任务都停止运行了</strong>。其它的一些库（如 db drivers）也会有类似的行为。</p><p>需要注意的是，阻塞当前线程本身并非坏事情，只是不要和 <code>async_std</code> 并发执行的模型搞混淆即可。总之，不要这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    task::block_on(async &#123;</span><br><span class="line">        <span class="comment">//  标准库 std::fs，会导致阻塞</span></span><br><span class="line">        std::fs::read_to_string(<span class="string">"test_file"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要混合阻塞 API 调用，建议另起一个线程执行这样的阻塞操作。</p><h2 id="关于错误和-Panic"><a href="#关于错误和-Panic" class="headerlink" title="关于错误和 Panic"></a>关于错误和 Panic</h2><p>常规模式下，如果任务可能出错，那么任务的输出 <code>Output</code> 应该是  <code>Result&lt;T, E&gt;</code> 类型。但是在 <code>panic</code> 的时候，具体的表现则取决于有没有合理处理 panic 的地方，如果没有的话，则会退出。</p><p>实践中，意味着 <code>block_on</code> 会传递 panic 到阻塞调用的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    task::block_on(async &#123;</span><br><span class="line">        panic!(&quot;test&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread &apos;async-task-driver&apos; panicked at &apos;test&apos;, examples/panic.rs:8:9</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.</span><br></pre></td></tr></table></figure></p><p>而对于 spwan 出去的任务如果 panic，则会导致退出（abort）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task::spawn(async &#123;</span><br><span class="line">    panic!(&quot;test&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">task::block_on(async &#123;</span><br><span class="line">    task::sleep(Duration::from_millis(10000)).await;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">thread &apos;async-task-driver&apos; panicked at &apos;test&apos;, examples/panic.rs:8:9</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure></p><p>上面的行为最初看上去有点奇怪，但另外一种选项是对于 spawn 出去的任务如果发生 panic，则简单忽略掉。当前的行为可以被修改为捕获 spawn 出去的任务中发生的 panic，并且根据不同的情况做出不同的响应，这样我们就可以根据需要采取不同的 panic 处理策略。</p><h1 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h1><p>在 <a href="https://github.com/async-rs/async-std/tree/master/examples" target="_blank" rel="noopener">这里</a> 有不少示例代码可以参考，下面是一个简单的 UDP 客户端例子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::io;</span><br><span class="line"><span class="keyword">use</span> async_std::net::UdpSocket;</span><br><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    task::block_on(async &#123;</span><br><span class="line">        <span class="keyword">let</span> socket = UdpSocket::bind(<span class="string">"127.0.0.1:8081"</span>).await?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Listening on &#123;&#125;"</span>, socket.local_addr()?);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> msg = <span class="string">"hello world"</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&lt;- &#123;&#125;"</span>, msg);</span><br><span class="line">        socket.send_to(msg.as_bytes(), <span class="string">"127.0.0.1:8080"</span>).await?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buf = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">let</span> (n, _) = socket.recv_from(&amp;<span class="keyword">mut</span> buf).await?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"-&gt; &#123;&#125;\n"</span>, <span class="built_in">String</span>::from_utf8_lossy(&amp;buf[..n]));</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.async.rs/introduction.html" target="_blank" rel="noopener">Async programming in Rust with async-std</a></li><li><a href="https://rust-lang.github.io/async-book/" target="_blank" rel="noopener">Asynchronous Programming in Rust</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近打算基于 Rust &lt;a href=&quot;https://github.com/async-rs/async-std&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;async-std&lt;/a&gt; 造轮子，自然是要熟悉下这个库。以下内容是根据 Rust &lt;a href=&quot;https://github.com/async-rs/async-std&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;async-std&lt;/a&gt; 官方文档翻译整理，当然也加入了部分自己的理解，有不到位的地方还请指点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/async-rs/async-std&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;async-std&lt;/a&gt; 旨在简化异步编程，由于是模拟 Rust 标准库接口，所以熟悉标准库的话，使用起来也会非常舒服。目前 &lt;code&gt;async-std&lt;/code&gt; 给我们提供了很多接口：文件系统、网络、计时器等等；它还提供了一个 &lt;code&gt;task&lt;/code&gt; 模型，有点类似 Rust 标准库中的 &lt;code&gt;thread&lt;/code&gt; 模块。此外，还有 &lt;code&gt;async/await&lt;/code&gt; 风格的 &lt;code&gt;Mutex&lt;/code&gt; 原语。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://ifaceless.space/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://ifaceless.space/tags/Rust/"/>
    
      <category term="Async" scheme="http://ifaceless.space/tags/Async/"/>
    
  </entry>
  
  <entry>
    <title>初识 Elasticsearch</title>
    <link href="http://ifaceless.space/2020/01/15/elasticsearch-intro/"/>
    <id>http://ifaceless.space/2020/01/15/elasticsearch-intro/</id>
    <published>2020-01-15T06:06:48.000Z</published>
    <updated>2020-01-15T06:44:16.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在很多应用场景下，我们都需要搜索功能，不管是在 App 中还是网站中。搜索每时每刻都在发生，比如搜索喜欢的零食、好看的衣服、喜欢的文章、想要学习的课程等等。如今要为我们的应用添加搜索已经非常容易了，早期我们可以使用 MySQL 的 MyISAM 存储引擎来做全文本搜索支持，不过今天要说的 Elasticsearch 同样可以做到，而且更强大。简单来说，Elasticsearch 是一个分布式搜索和分析引擎，也是众所周知的 ELK Stack 核心成员。它以 JSON 的格式存储文档到索引当中，能够高效地存储多种类型，并提供快速搜索的能力。此外，整个 ELK Stack 生态非常完善。</p><a id="more"></a><p>那么接下来，我们将跟着官方文档学习下 Elasticsearch 具体是什么？适用的场景有哪些？支持什么数据类型存储和检索？</p><p><em>PS: 我们在生产环境中，使用 ES 构建了课程商品（SKU）索引，方便对用户、管理后台提供课程搜索能力。</em></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://github.com/deviantony/docker-elk" target="_blank" rel="noopener">docker-elk</a> 仓库提供了在 Docker 环境下搭建 ELK Stack 服务的配置，我们可以参考其说明文档进行安装（在 macOS Catalina 环境下操作）。</p><ol><li>克隆仓库：<code>git clone git@github.com:deviantony/docker-elk.git</code></li><li>第一次需要运行 <code>docker-compose build</code>，等待构建完成</li><li>需要在 <code>docker-compose.yml</code> 中修改下 ES 的密码，当然还有 <code>elasticsearch/config</code>，<code>kibana/config</code>, <code>logstash/config</code> 中都有密码需要修改。由于是在本地学习，所以只是简单设置了下密码。生产环境建议参考文档，生成复杂的密码</li><li>运行 <code>docker-compose up [-d]</code> 即可启动</li><li>关闭 <code>docker-compose down -v</code></li></ol><p>注意事项：</p><ol><li>配置文件并非动态加载，每次变更后需要重启对应的组件</li><li>端口映射说明：<ol><li>9200: ES HTTP</li><li>9300: ES TCP</li><li>5000: Logstash TCP input</li><li>5601: Kibana</li></ol></li></ol><p>启动成功后，可以打开 Kibana 开始探索啦~<br><img src="https://pic3.zhimg.com/v2-8ea49800d9c7e5e4f147349ca3237593.png" alt=""></p><h1 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h1><p>Elasticsearch 是一个<strong>分布式搜索和分析引擎</strong>，ELK 栈的核心组成部分。而 Logstash 和 Beats 用于<strong>收集</strong>、<strong>聚合</strong>、<strong>转换</strong>数据，并将其存储在 Elasticsearch 当中。而 Kibana 则让我们能够便捷探索、查看并分享数据，同时也用来管理 ELK 栈。</p><p>ES 提供了实时的搜索和分析能力，支持多种数据类型（结构化、非结构化、数字、地理位置等），ES 会高效地存储并索引这些数据，从而支持快速搜索。由于分布式的特点，随着数据集的增加，可以轻松地进行水平扩展来提高服务可靠性和性能。</p><p>ES 支持的使用场景包括：</p><ol><li><strong>为我们的 App 或网站提供搜索支持</strong></li><li><strong>可以存储分析日志（analyze logs）、指标数据（metrics）、安全事件数据（security event data）</strong></li><li>基于机器学习根据数据实时建模</li><li>可以用作 GIS 系统（地理信息系统），用于管理、集成并分析空间信息</li><li>可以用于生物学研究工具，存储并处理基因数据</li></ol><h1 id="文档和索引"><a href="#文档和索引" class="headerlink" title="文档和索引"></a>文档和索引</h1><p>ES 本质上还是一个分布式文档存储服务（类比 Mongo？），实际在索引中存储的是 JSON 格式的文档。在 ES 集群中，文档会被分布到整个集群存储的，并且能够从任意一个节点立刻访问到。</p><p>一旦新的文档存储到索引后，几乎可以立刻被搜索到（1s 以内），因此可以构建近乎实时的搜索引擎。那么 ES 究竟是如何做到的呢？简单来说，它使用了<strong>倒排索引（inverted index）</strong>这种数据结构来支持全文本搜索。所谓的<strong>倒排索引</strong>就是对文本进行分词，然后记录每个分词所在的文档 id（当然还有词频等信息），这样在查询时可以基于分词快速定位所在的文档。</p><p>在 ES 中，<strong>索引</strong>是一个很重要的概念（回顾下 MySQL InnoDB 的聚簇索引，表中的记录存储在 B-Tree Node 上，基于 B+ Tree 这种数据结构快速定位记录所在的页），但是这里的索引和在关系数据库中提到的索引有所差别。总结下特点：</p><ol><li>ES 的<strong>索引（index）</strong>可以看成<strong>文档（document）</strong>的集合；</li><li>每个<strong>文档（document）</strong>可以看成<strong>字段（field）</strong>（类比下字典中的 key-value）的集合；<br><img src="https://pic1.zhimg.com/v2-b165c6321a00d62c6c5ab2b2ac0994bb.png" alt=""></li></ol><p>默认设置下，ES 会为文档中的每个字段建立索引，并且每个字段都会匹配专门优化的数据结构以达到高效存储和快速搜索的目的。比如：文本使用<strong>倒排索引</strong>，数字和地理位置使用 <a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-bkd/" target="_blank" rel="noopener">BKD 树</a>。</p><p>ES 支持 schema-less，这样我们就不用为每个字段显式指定索引方式。当我们启用动态映射（dynamic mapping）时（这个是默认设置），ES 会自动检测到新增字段，自动将文档中的 bool 值、浮点数、整数、日期、字符串等映射成合适的 ES 数据类型。</p><p>当然，某些情况下，我们可能想要关闭动态映射的功能，这时可以自定义映射规则，从而控制每个字段存储和索引的方式。自定义映射带可以：</p><ol><li>区分全文本字符串字段和精确匹配的字符串字段；</li><li>执行特定语言的文本分析；</li><li>优化部分匹配；</li><li>使用自定义日期格式；</li><li>使用一些无法自动检测到的数据类型（如 <code>geo_point</code>, <code>geo_shape</code>）。</li></ol><p>此外，ES 可以为相同的字段建立不同的索引，以满足不同的需求场景。</p><h1 id="搜索与分析"><a href="#搜索与分析" class="headerlink" title="搜索与分析"></a>搜索与分析</h1><p>ES 提供了非常简单易于使用的 REST API，可以利用它们管理集群、索引和搜索数据。我们既可以在 Kibana 控制台中和 ES 交互，也可以使用各个语言（支持 Java, JavaScript, Go, .Net, PHP, Perl, Python, Ruby 等）的客户端进行交互。</p><h2 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h2><p><em>目前支持两种查询方式：JSON Query DSL 和 SQL。</em></p><p>ES API 允许我们使用结构化查询、全文本查询或者二者组合：</p><ol><li><strong>结构化查询</strong>：类似 SQL 那样，我们可以搜索某几个字段，基于某字段排序等；</li><li><strong>全文本查询</strong>：返回匹配关键词的文档，返回的结果基于相关性排序。</li></ol><p>此外，还支持单独分词（individual terms）查询，我们可以执行短语搜索（phrase searches）、相似度搜索（similarity searches）和前缀搜索（prefix searches），甚至可以得到自动补全的建议。当然，对于地理位置或者数字类型的数据，ES 也可以提供高效的查询功能。</p><h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>ES 允许我们执行<strong>聚合（aggregation）</strong>操作，从而对关键的指标、 增长趋势等有更为深刻的认识。ES 高效聚合的能力，可以让我们能够实时地分析和可视化数据。我们可以把搜索和聚合联合在一起使用，这样就可以在搜索、过滤文档的同时，对相同的结果进行分析。</p><p>此外，ES 还提供了自动分析时序数据的功能，也就是利用机器学习来发现数据中的异常，不过这块属于高级功能了，有兴趣的话可以自行研究下~</p><h1 id="高可用、可伸缩与可靠性"><a href="#高可用、可伸缩与可靠性" class="headerlink" title="高可用、可伸缩与可靠性"></a>高可用、可伸缩与可靠性</h1><p><img src="https://pic3.zhimg.com/v2-f8f2d20ee4cd5a1cc87c4ddba58f0078.jpg" alt=""></p><p>既然是分布式搜索引擎，高可用和可伸缩的能力自然是 ES 必备技能。我们可以按需给集群增加服务器（节点）实现扩容。ES 会自动将数据和查询负载均衡到<strong>可用节点</strong>上，以实现伸缩和高可用。</p><p>那么，ES 是如何存储和维护索引的呢？简单来说，每个 ES <strong>索引（index）</strong>其实是一个到多个<strong>物理分片（physical shards）</strong> 所组成的<strong>逻辑分组（logical group）</strong>；每个分片实际是<strong>自包含索引（self-contained index）</strong>。通过将索引放到多个分片存储，然后将分片分布到多个节点上，ES 可以为分片提供冗余备份，从而达到水平扩展和高可用的目的。随着集群的扩容（或缩容），ES 会自动再均衡，必要时也会合并分片。</p><h2 id="关于分片（shards）"><a href="#关于分片（shards）" class="headerlink" title="关于分片（shards）"></a>关于分片（shards）</h2><p>分片分为两种类型：</p><ol><li><strong>主分片（primary shard）</strong>：索引中的每个文档都属于某个主分片。</li><li><strong>副本分片（replicas）</strong>：副本分片其实就是主分片的拷贝，一方面实现数据冗余，另一方面也对外提供读服务（搜索、获取文档等）。</li></ol><p>需要注意的是，<strong>索引的主分片数在创建后就不能修改了，只能重建靠重建索引来扩展主分片数</strong>，但是副本分片数可以随时修改，不会打断索引和查询操作。</p><p>那么问题来了，索引的主分片数越多越好吗？显然不是这样的。我们需要考虑索引的数据量大小，尽可能保证每个分片不要太大，分片数量不要过多。</p><p>我们先来看看分片数过多会导致的问题吧：</p><ol><li>每个分片其实都是一个 Lucene 索引，会占用更多的文件描述符、内存和 CPU 资源；</li><li>搜索会被分配到各个分片上，如果分片都位于不同节点还好，要是集中在某个节点，则会出现热点问题，资源竞争激烈，性能也会下降；</li><li>过多的分片也会导致过多的分片请求，会产生一定的网络开销等；</li><li>ES 使用词频来统计匹配的相关性，统计会被分配到各个分片上，如果大量分片上只维护了很少的数据，则会导致最终的文档的相关性较差。</li></ol><p>如果每个分片过大，则会导致集群再均衡办时，搬迁数据更耗时。总而言之，我们需要通过测试来确定最佳的配置。起初可以这样：</p><ol><li>保证每个分片的大小在 GB 到几十 GB 范围。对于常见的时序数据，分片大小在 20GB ~ 40GB 也很常见。参考文献中给出的大小限制为 30GB。</li><li>避免过大的分片问题。每个节点可容纳的分片数量和可用的堆空间成正比，每 GB 堆空间分片数应该小于 20。</li></ol><h2 id="灾备"><a href="#灾备" class="headerlink" title="灾备"></a>灾备</h2><p>考虑性能的因素，通常集群中的节点应该位于相同的网络环境。跨数据中心均衡分片非常耗时，可靠性也会降低。但是高可用架构设计就是要保证我们不要把鸡蛋放在一个篮子里，这样一旦某处的服务器宕机，位于其它位置的服务器可以接替继续提供服务。</p><p>ES 为我们提供了 CCR 功能（跨集群复制，Cross-cluster replication），这样可以将主集群的索引同步到远程的集群作为热备，同时也可以基于地理位置使用其它集群提供读请求。所有的写入操作都在主集群完成，其它的副本集群都是只读的 Followers。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://pic2.zhimg.com/v2-f2d85b3f20fc985bf5b47c8927c2afcf.jpg" alt=""></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>生产环境创建索引模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">PUT /_template/km_server_warehouse_template</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"order"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"index_patterns"</span>: [</span><br><span class="line">    <span class="string">"km_server_warehouse*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: &#123;</span><br><span class="line">      <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">        <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">          <span class="attr">"znlp-coarse"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">            <span class="attr">"tokenizer"</span>: <span class="string">"znlp-fine"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"number_of_shards"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"translog"</span>: &#123;</span><br><span class="line">        <span class="attr">"sync_interval"</span>: <span class="string">"5s"</span>,</span><br><span class="line">        <span class="attr">"durability"</span>: <span class="string">"async"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"number_of_replicas"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"similarity"</span>: &#123;</span><br><span class="line">        <span class="attr">"scripted_bm25"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"scripted"</span>,</span><br><span class="line">          <span class="attr">"script"</span>: &#123;</span><br><span class="line">            <span class="attr">"source"</span>: <span class="string">"double k1 = 1.2; double b = 0.75; double tfNorm = doc.freq * (k1 + 1) / (doc.freq + k1 * (1 - b + b * doc.length / (1.0 * field.sumTotalTermFreq/field.docCount))); return query.boost * tfNorm;"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"contents"</span>: &#123;</span><br><span class="line">      <span class="attr">"dynamic"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"content_basic"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"sku_id"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"business_id"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"business_type"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"producer"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"svip_right"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"free"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"discount"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"short"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"instabook_right"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"free"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"discount"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"short"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"svip_privileges"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">              <span class="attr">"similarity"</span>: <span class="string">"scripted_bm25"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"znlp-fine"</span>,</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"authors"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"right_list"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"serial_status"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"short"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"public_status"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"short"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"online_time"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"categories"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"level"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"short"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"weight"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"short"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                  <span class="attr">"fields"</span>: &#123;</span><br><span class="line">                    <span class="attr">"keyword"</span>: &#123;</span><br><span class="line">                      <span class="attr">"ignore_above"</span>: <span class="number">256</span>,</span><br><span class="line">                      <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"name_en"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                  <span class="attr">"fields"</span>: &#123;</span><br><span class="line">                    <span class="attr">"keyword"</span>: &#123;</span><br><span class="line">                      <span class="attr">"ignore_above"</span>: <span class="number">256</span>,</span><br><span class="line">                      <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"is_test"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"content_aggregation"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"interest_count"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"created_at"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"updated_at"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aliases"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html" target="_blank" rel="noopener">ES 介绍</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="noopener">Query DSL</a></li><li><a href="https://www.cnblogs.com/ningskyer/articles/5789010.html" target="_blank" rel="noopener">Elasticsearch系统概念及架构图</a></li><li><a href="https://blog.csdn.net/zx711166/article/details/81517178" target="_blank" rel="noopener">倒排索引</a></li><li><a href="https://elasticsearch.cn/article/711" target="_blank" rel="noopener">聊聊 ELASTICSEARCH 的集群状态的管理和维护</a></li><li><a href="https://logz.io/learn/complete-guide-elk-stack/#intro" target="_blank" rel="noopener">THE COMPLETE GUIDE TO THE ELK STACK</a></li><li><a href="https://www.edureka.co/blog/elk-stack-tutorial/" target="_blank" rel="noopener">ELK Stack Tutorial – Discover, Analyze And Visualize Your Data Efficiently</a></li><li><a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-bkd/" target="_blank" rel="noopener">Lucene BKD树-动态磁盘优化BSP树</a></li><li><a href="https://www.cnblogs.com/bigben0123/p/11274296.html" target="_blank" rel="noopener">聊聊 ES 分片优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在很多应用场景下，我们都需要搜索功能，不管是在 App 中还是网站中。搜索每时每刻都在发生，比如搜索喜欢的零食、好看的衣服、喜欢的文章、想要学习的课程等等。如今要为我们的应用添加搜索已经非常容易了，早期我们可以使用 MySQL 的 MyISAM 存储引擎来做全文本搜索支持，不过今天要说的 Elasticsearch 同样可以做到，而且更强大。简单来说，Elasticsearch 是一个分布式搜索和分析引擎，也是众所周知的 ELK Stack 核心成员。它以 JSON 的格式存储文档到索引当中，能够高效地存储多种类型，并提供快速搜索的能力。此外，整个 ELK Stack 生态非常完善。&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://ifaceless.space/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://ifaceless.space/tags/Elasticsearch/"/>
    
      <category term="ELK" scheme="http://ifaceless.space/tags/ELK/"/>
    
      <category term="搜索引擎" scheme="http://ifaceless.space/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>快递网点抓取杂记</title>
    <link href="http://ifaceless.space/2019/12/29/craw-dilivery-network-distribution/"/>
    <id>http://ifaceless.space/2019/12/29/craw-dilivery-network-distribution/</id>
    <published>2019-12-29T05:02:30.000Z</published>
    <updated>2020-01-01T04:34:08.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>应求开发一个简单的爬虫，用于从<a href="https://www.kuaidi100.com/network/" target="_blank" rel="noopener">快递 100</a> 抓取快递网点的分布，输入省份+城市+区县，然后是快递公司名称，抓取其对应的快递网点的信息（包括名称、地址、电话、坐标等）。说起来，开发这样一个简单的爬虫其实没什么难度，也没什么技术含量（没有时间要求、不需要分布式抓取、没什么反反爬策略加持等），不过这期间也遇到一些比较有趣的问题，特此记录下。</p><p>另外就是第一次接触了 <a href="https://pyecharts.org/#/zh-cn/geography_charts" target="_blank" rel="noopener">pyecharts</a> 这个数据可视化工具，用起来还挺方便的。样式配置好，还是会带来很好的视觉冲击的！当然，关键是利用这种工具有助于增加对抓取数据的理解（看具体需要的分析维度了）。</p><a id="more"></a><p>整个过程还是挺有趣的，虽然定位某些元素的时候很麻烦，写 XPath 表达式也比较枯燥（不要指望浏览器自动生成的 XPath，通常都不够通用）。但是完成整个任务后，还是有些收获的。下面开始吧~</p><h1 id="确定方案"><a href="#确定方案" class="headerlink" title="确定方案"></a>确定方案</h1><h2 id="尝试-API-直接获取"><a href="#尝试-API-直接获取" class="headerlink" title="尝试 API 直接获取"></a>尝试 API 直接获取</h2><p>快递 100 对外公开的 API 文档<a href="https://www.kuaidi100.com/openapi/cloud_api.shtml" target="_blank" rel="noopener">在此</a>，但是并没有开放网点查询的接口，故无法使用。<em>直接通过 API 查询是最省心的方式，但是目前这条路行不通</em>。</p><h2 id="尝试分析网页请求，间接使用-API-请求"><a href="#尝试分析网页请求，间接使用-API-请求" class="headerlink" title="尝试分析网页请求，间接使用 API 请求"></a>尝试分析网页请求，间接使用 API 请求</h2><p>网点查询的<a href="https://www.kuaidi100.com/network/" target="_blank" rel="noopener">主页</a>，可以根据选择的城市和快递公司，页面内容自动切换。此时，还是尝试分析其 API 请求，因为这个通常是抓取网站最简单的方式。</p><p>打开 Chrome 浏览器的调试模式，通过点击页面上的筛选项，查看网络请求，确定请求了什么接口，传递的参数是什么，返回的参数是什么，从而能够模拟其请求方式来获取数据。接下来演示的是查询上海地区的某快递公司的网点。</p><p>截图 1：请求方式为 POST，URL 为 <code>www.kuaidi100.com/network/searchapi.do</code><br><img src="https://pic4.zhimg.com/80/v2-5e4a1966207a0722b6027de8c59575fa.png" alt=""></p><p>截图 2：以表单的形式，提交了请求的参数，也就是页面点击的筛选项。<br><img src="https://pic4.zhimg.com/80/v2-68027253f03f285b193cbede8deff551.png" alt=""></p><p>截图 3：当完成请求后，可以看到其返回结果为 JSON 结构，其中的 <code>netList</code> 正是想要找的网点数据。<br><img src="https://pic4.zhimg.com/80/v2-e0a0299c70020102ca4f261123572f1a.png" alt=""></p><h2 id="尝试分析网页结构，采用传统的方式抓取"><a href="#尝试分析网页结构，采用传统的方式抓取" class="headerlink" title="尝试分析网页结构，采用传统的方式抓取"></a>尝试分析网页结构，采用传统的方式抓取</h2><p>一般在进行网站数据抓取时，能通过其 API 获取，就尽可能去利用。使用 API 请求数据的好处有这么几点：</p><ol><li>省去了分析网页 HTML 结构的时间，可以直接解析接口返回的数据，提取想要的信息并存储即可；</li><li>API 请求方式最为简单可靠灵活，且能适应较高的抓取频率；</li><li>相对于分析网页 HTML 结构，提取信息的方式，API 抓取通常不用像担心前端页面频繁改版而导致爬虫程序也要即使更新的困境，方便维护。</li></ol><p>不过只是通过 API 来抓取，感觉不是很有趣，在 Selenium 的帮助下，以可视化的方式抓取页面貌似更有趣点。这里的思路如下：</p><ol><li>安装 Selenium + Chrome Web Driver，通过操纵浏览器模拟人类访问页面的方式来抓取数据；</li><li>编写爬虫程序，控制浏览器打开网点查询的首页：<a href="https://www.kuaidi100.com/network/" target="_blank" rel="noopener">https://www.kuaidi100.com/network/</a></li><li>接收输入的城市和快递公司名称作为参数，然后操纵浏览器点击下拉框，选择城市；然后操纵浏览器点击指定的快递公司；</li><li>接下来开始解析页面结构，提取快递网点数据转换为 JSON 格式（地理位置坐标通过百度地图 API 获得），存储在指定路径下；然后不断控制浏览器翻页，完成剩余页面解析，至此对应的网点信息抓取完成。</li></ol><h1 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h1><ol><li>Python 3.7 环境；</li><li><a href="https://pypi.org/project/selenium/" target="_blank" rel="noopener">selenium-python</a>，其使用文档参考<a href="https://selenium-python-zh.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="noopener">此处</a>；</li><li><a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">chromedriver</a> 下载，并解压得到可执行文件；</li><li>Anaconda 环境安装，并且需要保证 Jupter Notebook 能够正常工作；</li><li>依赖的重要 Python 包安装：<ul><li>pyecharts</li><li>echarts-countries-pypkg </li><li>echarts-china-provinces-pypkg </li><li>echarts-china-cities-pypkg </li><li>echarts-china-counties-pypkg </li><li>echarts-china-misc-pypkg</li><li>requests</li></ul></li><li>记得安装 Chrome 浏览器。</li></ol><h1 id="页面关键元素定位"><a href="#页面关键元素定位" class="headerlink" title="页面关键元素定位"></a>页面关键元素定位</h1><p>根据上述抓取思路，需要做的是定位一些关键元素，并且能够从 HTML 中抽取出需要的信息。页面元素定位，需要了解下 <a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">XPath</a> 语法，摘取想要的元素。</p><p><em>小技巧，可以在 Chrome 控制台通过 <code>$x(&#39;xpath-expression&#39;)</code> 验证选择器是否正常：</em><br><img src="https://pic4.zhimg.com/80/v2-7349b600693e94c344c2246ad63c1548.png" alt=""></p><ul><li><p>省份选择下拉框元素 id 为 <code>provinceSelect</code>：<br>  <img src="https://pic4.zhimg.com/80/v2-bac9ebd7eb25c1b40feaff8d07ef3396.png" alt=""></p></li><li><p>定位省份位置（拷贝其 XPATH）<br>  <img src="https://pic1.zhimg.com/80/v2-5273d05981d0d6e9b4d611ea5408f785.png" alt=""></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其它关键元素确定方式类似，主要以 XPath 的方式查找。得到最终需要的 XPath 表达式如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XPathExpression</span>:</span></span><br><span class="line">    <span class="comment"># 省份下拉框 Tab</span></span><br><span class="line">    PROVINCE_TAB = <span class="string">'//*[@id="provinces"]/div/ul/li[2]'</span></span><br><span class="line">    <span class="comment"># 具体某个省份</span></span><br><span class="line">    PROVINCE_ITEM = <span class="string">'//*[contains(@class, "place province") and contains(text(), "&#123;&#125;")]'</span></span><br><span class="line">    <span class="comment"># 具体某个城市</span></span><br><span class="line">    CITY_ITEM = <span class="string">'//*[contains(@class, "place city") and contains(text(), "&#123;&#125;")]'</span></span><br><span class="line">    <span class="comment"># 具体某个区县</span></span><br><span class="line">    COUNTY_ITEM = <span class="string">'//*[contains(@class, "place county") and contains(text(), "&#123;&#125;")]'</span></span><br><span class="line">    <span class="comment"># 右侧查询按钮</span></span><br><span class="line">    QUERY_BUTTON = <span class="string">'//*[contains(@class, "btn-query")]'</span></span><br><span class="line">    <span class="comment"># 快递公司选择</span></span><br><span class="line">    PROVIDER_ITEM = <span class="string">'//ul[@id="companyCount"]/li/*[contains(text(), "&#123;&#125;")]'</span></span><br><span class="line">    <span class="comment"># 下一页</span></span><br><span class="line">    NEXT_PAGE_BUTTON = <span class="string">'//*[contains(@class, "page-down-active")]'</span></span><br><span class="line">    <span class="comment"># 页面中的快递公司信息条目</span></span><br><span class="line">    QUERY_ITEMS = <span class="string">'//*[@id="queryResult"]/dl'</span></span><br></pre></td></tr></table></figure><h1 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h1><p><code>main</code> 函数是关键入口，它会调用爬虫类搜索指定位置指定公司的快递网点信息，并将返回的数据存储到指定的路径下，使用 <code>json line</code> 格式（即每一行都是 json 格式字符串）存储。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(province, city, provider=<span class="string">'全部'</span>)</span>:</span></span><br><span class="line">    spider = DeliveryNetworkSpider(</span><br><span class="line">        driver_path=os.path.join(PROJECT_DIR, <span class="string">'dep/mac/chromedriver'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        results = spider.search(province=province, city=city, provider=provider)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        print(err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            print(result)</span><br><span class="line">            store_result(os.path.join(PROJECT_DIR, <span class="string">'results'</span>, <span class="string">f'<span class="subst">&#123;province&#125;</span>-<span class="subst">&#123;city&#125;</span>-<span class="subst">&#123;provider&#125;</span>.jl'</span>), result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        spider.close()</span><br></pre></td></tr></table></figure><h2 id="核心爬虫类"><a href="#核心爬虫类" class="headerlink" title="核心爬虫类"></a>核心爬虫类</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryNetworkSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""基于快递 100 的快递网点查询爬虫</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, driver_path)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化快递网点爬虫，关键参数是要指定 webdriver 路径，否则</span></span><br><span class="line"><span class="string">        无法控制浏览器进行模拟查询。当前仅支持 Chrome 浏览器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param driver_path: 默认是 Mac 版本所在的路径，如果是 win</span></span><br><span class="line"><span class="string">                版本，需要自行修改路径。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Windows 下需要替换成对应的 chromedriver，可以在 dep 目录下新建 win</span></span><br><span class="line">        <span class="comment"># 目录，将 windows 版本的放到目录下，并修改 mac-&gt;win</span></span><br><span class="line">        self._driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line">        self._driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待元素出现</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._driver.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, province, city, county=<span class="string">'暂不选择'</span>, provider=<span class="string">'全部'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""执行网点查询的核心方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param province: 省份（一定要是快递 100 上有的名字）</span></span><br><span class="line"><span class="string">        :param city: 城市（一定要是快递 100 上有的名字）</span></span><br><span class="line"><span class="string">        :param county: 区县，默认为全部区县</span></span><br><span class="line"><span class="string">        :param provider: 快递服务商名字，不传则查询所有快递公司</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._open_home_page()</span><br><span class="line">        self._select_location(province, city, county)</span><br><span class="line">        self._select_provider(provider)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self._parse_page(province, city)</span><br><span class="line">            <span class="keyword">if</span> self._has_next_page():</span><br><span class="line">                time.sleep(<span class="number">.5</span>)  <span class="comment"># 防止翻页太快被抓到</span></span><br><span class="line">                self._visit_next_page()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open_home_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._driver.get(<span class="string">'https://www.kuaidi100.com/network/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_select_location</span><span class="params">(self, province, city, county)</span>:</span></span><br><span class="line">        <span class="comment"># 找到输入下拉框位置</span></span><br><span class="line">        elem = self._driver.find_element_by_id(<span class="string">'provinceSelect'</span>)</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定位选择省份 Tab</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(XPathExpression.PROVINCE_TAB)</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接下来选择省份</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(</span><br><span class="line">            XPathExpression.PROVINCE_ITEM.format(province))</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 紧接着选择城市</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(</span><br><span class="line">            XPathExpression.CITY_ITEM.format(city))</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择所有区域</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(</span><br><span class="line">            XPathExpression.COUNTY_ITEM.format(county))</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定位到查询按钮，并点击查询跳转页面</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(XPathExpression.QUERY_BUTTON)</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_select_provider</span><span class="params">(self, provider)</span>:</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(</span><br><span class="line">            XPathExpression.PROVIDER_ITEM.format(provider))</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_has_next_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._driver.find_element_by_xpath(XPathExpression.NEXT_PAGE_BUTTON)</span><br><span class="line">        <span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_visit_next_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        elem = self._driver.find_element_by_xpath(XPathExpression.NEXT_PAGE_BUTTON)</span><br><span class="line">        self.__highlight(elem)</span><br><span class="line">        elem.click()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__highlight</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="string">"""高亮操作的元素"""</span></span><br><span class="line">        self._driver.execute_script(</span><br><span class="line">            <span class="string">"arguments[0].setAttribute('style',arguments[1]);"</span>,</span><br><span class="line">            elem,</span><br><span class="line">            <span class="string">"outline:2px solid red;"</span>)</span><br><span class="line">        time.sleep(<span class="number">.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse_page</span><span class="params">(self, province, city)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            elements = self._driver.find_elements_by_xpath(XPathExpression.QUERY_ITEMS)</span><br><span class="line">        <span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> el <span class="keyword">in</span> elements:</span><br><span class="line">                <span class="keyword">yield</span> self._extract(el.text, province, city)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_extract</span><span class="params">(text, province, city)</span>:</span></span><br><span class="line">        item = dict(</span><br><span class="line">            province=province,</span><br><span class="line">            city=city,</span><br><span class="line">            name=<span class="string">''</span>,  <span class="comment"># 名称</span></span><br><span class="line">            address=<span class="string">''</span>,  <span class="comment"># 地址</span></span><br><span class="line">            contact_phone=<span class="string">''</span>,  <span class="comment"># 联系电话</span></span><br><span class="line">            pickup_phone=<span class="string">''</span>,  <span class="comment"># 取件电话</span></span><br><span class="line">            check_phone=<span class="string">''</span>,  <span class="comment"># 查件电话</span></span><br><span class="line">            complaint_phone=<span class="string">''</span>,  <span class="comment"># 投诉电话</span></span><br><span class="line">            location=dict(</span><br><span class="line">                lng=<span class="number">0.0</span>,  <span class="comment"># 经度</span></span><br><span class="line">                lat=<span class="number">0.0</span>,  <span class="comment"># 纬度</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取出纯文本后换行解析</span></span><br><span class="line">        lines = [l.strip() <span class="keyword">for</span> l <span class="keyword">in</span> text.splitlines() <span class="keyword">if</span> l.strip()]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__</span><span class="params">(k)</span>:</span></span><br><span class="line">            r = [l <span class="keyword">for</span> l <span class="keyword">in</span> lines <span class="keyword">if</span> l.startswith(k)]</span><br><span class="line">            <span class="keyword">return</span> r[<span class="number">0</span>].replace(k, <span class="string">''</span>) <span class="keyword">if</span> r <span class="keyword">else</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        item[<span class="string">'name'</span>] = lines[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'address'</span>] = __(<span class="string">'公司地址：'</span>)</span><br><span class="line">        item[<span class="string">'contact_phone'</span>] = __(<span class="string">'联系电话：'</span>)</span><br><span class="line">        item[<span class="string">'pickup_phone'</span>] = __(<span class="string">'取件电话：'</span>)</span><br><span class="line">        item[<span class="string">'check_phone'</span>] = __(<span class="string">'查件电话：'</span>)</span><br><span class="line">        item[<span class="string">'complaint_phone'</span>] = __(<span class="string">'投诉电话：'</span>)</span><br><span class="line">        item[<span class="string">'location'</span>] = get_location(</span><br><span class="line">            item[<span class="string">'address'</span>], city=<span class="string">u"&#123;&#125;&#123;&#125;"</span>.format(province, city))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h2 id="坐标查询"><a href="#坐标查询" class="headerlink" title="坐标查询"></a>坐标查询</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BASE_API = <span class="string">'http://api.map.baidu.com'</span></span><br><span class="line">LOCATION_API = <span class="string">'/geocoding/v3/?address=&#123;&#125;&amp;city=&#123;&#125;&amp;output=json&amp;ak=&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加缓存，避免重复查询</span></span><br><span class="line"><span class="meta">@filecache(YEAR)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_location</span><span class="params">(addr, city=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文档参考：http://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> addr:</span><br><span class="line">        <span class="keyword">return</span> dict(lng=<span class="number">0.0</span>, lat=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    url = _get_query_url(LOCATION_API.format(addr, city, AK))</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    result = r.json()</span><br><span class="line">    <span class="keyword">assert</span> result[<span class="string">'status'</span>] == <span class="number">0</span>, <span class="string">u"获取经纬度信息失败！请求：&#123;&#125;，返回结果：&#123;&#125;"</span>.format(url, result)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">'result'</span>][<span class="string">'location'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_query_url</span><span class="params">(query_str)</span>:</span></span><br><span class="line">    query_str = query_str.replace(<span class="string">'#'</span>, <span class="string">''</span>)  <span class="comment"># 去除特殊字符</span></span><br><span class="line">    <span class="comment"># 对 query_str 进行转码，safe 内的保留字符不转换</span></span><br><span class="line">    qs = quote(query_str, safe=<span class="string">"/:=&amp;?#+!$,;'@()*[]"</span>)</span><br><span class="line">    sn = hashlib.md5(quote_plus(qs + SK).encode(<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> BASE_API + query_str + <span class="string">f'&amp;sn=<span class="subst">&#123;sn&#125;</span>'</span></span><br></pre></td></tr></table></figure><h1 id="控制抓取数据"><a href="#控制抓取数据" class="headerlink" title="控制抓取数据"></a>控制抓取数据</h1><p>比如，下面就是抓取中通快递在北京各个地区的网点。启动后，会通过 Selenuium 控制 Chrome 浏览器访问查询网站，并点击对应的元素，完成数据的抓取。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(province=<span class="string">'北京'</span>, city=<span class="string">'北京'</span>, provider=<span class="string">'中通'</span>)</span><br></pre></td></tr></table></figure><p>整个工作过程演示参见 <a href="https://pan.baidu.com/s/1HD_fwdNHZqr1k1w3vzWyMQ" target="_blank" rel="noopener">百度网盘（提取码: kaun）</a>。抓取到的数据示例如下：</p><p><img src="https://pic3.zhimg.com/80/v2-16533f8a8c8f62a9433df19e188dd305.png" alt=""></p><h1 id="绘制简单的热点地图"><a href="#绘制简单的热点地图" class="headerlink" title="绘制简单的热点地图"></a>绘制简单的热点地图</h1><p>这里就需要使用关键的 <a href="https://pyecharts.org/" target="_blank" rel="noopener">pyecharts</a> 了，具体怎么安装和配置就不多说了，它有非常完善的中文文档，以及一些 Demo 可以学习。以下就是利用上述抓到的数据，做个简单的演示，看看这些快递网点的具体分布热点是怎么样的。</p><p>我们需要切换到爬虫目录下，并启动 Jupter Notebook：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd path/to/kuaidi100/src</span><br><span class="line">jupter notebook # 启动服务</span><br></pre></td></tr></table></figure><p>紧接着，选择 <code>src/heatmap.ipynb</code> 文件打开：<br><img src="https://pic2.zhimg.com/80/v2-af251174caa70eb0ca1f9285db7423ef.png" alt=""></p><p>菜单栏 <code>Cell-&gt;Run All</code> 执行所有代码，可以看到简单的热点地图如下所示：<br><img src="https://pic4.zhimg.com/80/v2-1c41db550a36616d2df8808bfaa61540.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个折腾的过程就完结咯。主要时间花费在确定爬重的方案，以及使用灵活的方式定位元素上。在实际测试中，也遇到一些小问题，并做了部分优化：</p><ol><li>比如某些情况下元素 <code>click</code> 会失败，这时为了保证爬虫的健壮性，需要做异常捕获；页面加载未完成时，可能无法查找到指定元素，导致爬虫程序挂了，这里就需要配置 Selenium 隐式等待 10s。</li><li>为了方便观察 Selenium 正在操纵的元素，这里借助了 <code>driver.execute_script()</code> 的方式给选中的元素添加红色边框。</li><li>另外，考虑到爬取频率过快，可能导致触发反爬策略，这里简单做了延迟等待（<code>time.sleep()</code>）。</li></ol><p>整体而言，写得比较简单，所以这里也就简单记录下。完整的代码仓库参见：<a href="https://gitee.com/ifaceless/kuaidi100-spider" target="_blank" rel="noopener">kuaidi100-spider</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://pyecharts.org/#/zh-cn/geography_charts" target="_blank" rel="noopener">pyecharts 地理图标文档</a></li><li><a href="https://blog.csdn.net/qq_31362537/article/details/90667814" target="_blank" rel="noopener">pyecharts 在地图上根据经纬度和量值，画出散点图/热力图</a></li><li><a href="http://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding" target="_blank" rel="noopener">百度地图文档</a></li><li><a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">XPath 语法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;应求开发一个简单的爬虫，用于从&lt;a href=&quot;https://www.kuaidi100.com/network/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快递 100&lt;/a&gt; 抓取快递网点的分布，输入省份+城市+区县，然后是快递公司名称，抓取其对应的快递网点的信息（包括名称、地址、电话、坐标等）。说起来，开发这样一个简单的爬虫其实没什么难度，也没什么技术含量（没有时间要求、不需要分布式抓取、没什么反反爬策略加持等），不过这期间也遇到一些比较有趣的问题，特此记录下。&lt;/p&gt;
&lt;p&gt;另外就是第一次接触了 &lt;a href=&quot;https://pyecharts.org/#/zh-cn/geography_charts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pyecharts&lt;/a&gt; 这个数据可视化工具，用起来还挺方便的。样式配置好，还是会带来很好的视觉冲击的！当然，关键是利用这种工具有助于增加对抓取数据的理解（看具体需要的分析维度了）。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ifaceless.space/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://ifaceless.space/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="http://ifaceless.space/tags/Python/"/>
    
      <category term="数据可视化" scheme="http://ifaceless.space/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>理解文件描述符与文件句柄</title>
    <link href="http://ifaceless.space/2019/12/19/understand-file-descriptor-and-file-description/"/>
    <id>http://ifaceless.space/2019/12/19/understand-file-descriptor-and-file-description/</id>
    <published>2019-12-19T05:26:37.000Z</published>
    <updated>2019-12-19T05:39:40.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在《Linux 系统编程手册》5.4 节，关于文件描述符和打开的文件关系是这样描述的：「内核为所有打开的文件维护了一个系统级的<strong>描述表（open file description table）</strong>，有时也称之为<strong>打开文件表（open file table）</strong>，并将表中的每个条目称为<strong>打开文件句柄（open file handle）</strong>。而针对每个进程，内核又为其维护了<strong>打开文件的描述符表（open file descriptor table）</strong>」。</p><a id="more"></a><p><img src="https://pic4.zhimg.com/80/v2-3064b2743259ac1b79da998a595b7c3b.png" alt=""></p><p>后来在这篇文章 <a href="https://juejin.im/entry/5b56f9045188251b157bb645" target="_blank" rel="noopener">Linux 文件句柄的这些技术内幕，只有 1% 的人知道</a> 中，看到了这样的的描述：「简单来说，每个进程都有一个<strong>打开的文件表（fdtable)</strong>。表中的每一项是struct file类型，包含了打开文件的一些属性比如偏移量，读写访问模式等，这是真正意义上的文件句柄」。</p><p><img src="https://pic1.zhimg.com/80/v2-c315f6671cc7038e8199346a98d4e300.png" alt=""></p><p>那么这里提到的「打开的文件表」又是什么呢，怎么又变成了每个进程都有的呢？《Linux 系统编程手册》中不是说「打开文件表（open file table）」是独立于进程的系统级表吗？是不是觉得有点困惑和矛盾呢？</p><p>为了能够解答困惑，加深对文件描述符的理解，特地深扒了下 Linux 内核的相关源码。接下来，我们将会看到上文提到的<strong>描述表（open file description table）</strong>、<strong>打开文件表（open file table）</strong>、<strong>打开文件句柄（open file handle）</strong>这三种抽象的数据结构具体是怎么实现的？以便能够更好地理解书中的概念。</p><h1 id="文件描述符与打开的文件关系"><a href="#文件描述符与打开的文件关系" class="headerlink" title="文件描述符与打开的文件关系"></a>文件描述符与打开的文件关系</h1><p>在区分这些概念前，我们先来看看 <code>open()</code> 系统调用的 <code>man page</code> 中提到的一段说明：</p><blockquote><p>A call to open() creates a new <strong>open file description</strong>, an entry in the<br>system-wide <strong>table of open files</strong>. The open file description records<br>the file offset and the file status flags (see below). A <strong>file<br>descriptor</strong> is a reference to an open file description; this reference<br>is unaffected if pathname is subsequently removed or modified to<br>refer to a different file…</p></blockquote><p>在看完上面的介绍后，结合《Linux 系统编程手册》提到的名词，我们可以作出这样的映射：</p><ol><li>open file description: 打开的文件句柄（open file handle），它才会关联到真正地文件 inode</li><li>table of open files: 就是书中提到的系统级描述表（open file table）</li><li>file descriptor: 其实就是一个针对文件句柄的引用</li></ol><p>好啦，下面来看看与文件描述符相关的实现细节，并了解几个重要的系统调用 实现。</p><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><p>以下代码摘自 <a href="https://github.com/torvalds/linux/tree/v5.4" target="_blank" rel="noopener">Linux Kernel 5.4</a>，考虑到内核代码非常复杂，处理细节也很多，这里并没有把每个函数或数据结构所有代码都贴出来，只保留了一些和本文焦点有关的代码行。</p><h2 id="Linux-内核中相关的数据结构"><a href="#Linux-内核中相关的数据结构" class="headerlink" title="Linux 内核中相关的数据结构"></a>Linux 内核中相关的数据结构</h2><p>每个进程都关联指向了一个 <code>files_struct</code>，即打开的文件信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Filesystem information*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span></span></span><br><span class="line"><span class="class">    /* <span class="title">Open</span> <span class="title">file</span> <span class="title">information</span>*/</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">files_struct</span>        *<span class="title">files</span>;</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，打开的文件信息长什么样呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">// 引用计数，可以和其它 task 共享</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">bool</span> resize_in_progress;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> resize_wait;</span><br><span class="line">    <span class="comment">// fdtable 是每个进程相关的文件描述符表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> next_fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而关于 fdtable （这个可以理解为进程独立的<strong>打开文件的描述符表（open file descriptor table）</strong>）的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_fds;</span><br><span class="line">    <span class="comment">// 这里 fd 数组，维护了进程关联的文件描述符及其文件句柄的指针</span></span><br><span class="line">    <span class="comment">// 文件句柄可以共享（比如，dup 系统调用）</span></span><br><span class="line">    <span class="comment">// 但是在使用 open 系统调用的时候会创建新的 file，即文件句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span> <span class="comment">/* current fd array */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *close_on_exec;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *open_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *full_fds_bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看文件句柄（即 open file description）是什么？它维护了和打开文件有关的重要信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>        <span class="title">f_path</span>;</span></span><br><span class="line">    <span class="comment">// 指向真正的文件，inode 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">f_inode</span>;</span>    <span class="comment">/* cached value */</span></span><br><span class="line">    <span class="comment">// 文件相关的操作</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">     * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        f_lock;</span><br><span class="line">    <span class="keyword">enum</span> rw_hint        f_write_hint;</span><br><span class="line">    <span class="comment">// 引用计数，只有 count 为 0 时，才会被真正地回收</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>        f_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_flags;</span><br><span class="line">    <span class="keyword">fmode_t</span>            f_mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">f_pos_lock</span>;</span></span><br><span class="line">    <span class="comment">// 文件偏移</span></span><br><span class="line">    <span class="keyword">loff_t</span>            f_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>    <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>    *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line">    u64            f_version;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画了一个图，方便了解上述数据结构关系：<br><img src="https://pic1.zhimg.com/v2-f3e683ab99b911d184e6e1dd244bdba4.jpg" alt="file-descriptor-file-description"></p><h2 id="三个重要的系统调用实现"><a href="#三个重要的系统调用实现" class="headerlink" title="三个重要的系统调用实现"></a>三个重要的系统调用实现</h2><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p><code>open()</code>  系统调用会分配新的文件句柄（file description），用来维护与打开文件相关的元信息（如偏移量、路径、操作方法等），并会给进程返回一个文件描述符（其实就是个小整数）。它对应的实现流程如下：</p><p><img src="https://pic4.zhimg.com/v2-57c48d5ad99dc3fca76727492cbd8a8d.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">open_flags</span> <span class="title">op</span>;</span></span><br><span class="line">    <span class="comment">// 不要被名字 fd 迷惑了，其实这里返回的是错误信息（非 0 表示出错了！）</span></span><br><span class="line">    <span class="keyword">int</span> fd = build_open_flags(flags, mode, &amp;op);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (fd)</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    tmp = getname(filename);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配文件描述符</span></span><br><span class="line">    fd = get_unused_fd_flags(flags);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配文件句柄</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> = <span class="title">do_filp_open</span>(<span class="title">dfd</span>, <span class="title">tmp</span>, &amp;<span class="title">op</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">            put_unused_fd(fd);</span><br><span class="line">            fd = PTR_ERR(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fsnotify_open(f);</span><br><span class="line">            <span class="comment">// 注册到进程的 fdtable 中</span></span><br><span class="line">            fd_install(fd, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    putname(tmp);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/namei.c</span></span><br><span class="line"><span class="function">struct file *<span class="title">do_filp_open</span><span class="params">(<span class="keyword">int</span> dfd, struct filename *pathname,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct open_flags *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">    filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> filp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct file *<span class="title">path_openat</span><span class="params">(struct nameidata *nd,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct open_flags *op, <span class="keyword">unsigned</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    file = alloc_empty_file(op-&gt;open_flag, current_cred());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fd_install(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    __fd_install(current-&gt;files, fd, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __fd_install(struct files_struct *files, <span class="keyword">unsigned</span> <span class="keyword">int</span> fd,</span><br><span class="line">        struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p><code>dup()</code> 系统调用实际上是会分配一个新的文件描述符，但是底层还是会指向传入的文件描述符关联的文件句柄（file description）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file.c</span></span><br><span class="line">SYSCALL_DEFINE1(dup, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fildes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -EBADF;</span><br><span class="line">    <span class="comment">// 基于传入的文件描述，查找到关联的文件句柄</span></span><br><span class="line">    <span class="comment">// 隐藏了一些错误判断逻辑</span></span><br><span class="line">    <span class="comment">// fget_raw 会调用 __fget 函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">fget_raw</span>(<span class="title">fildes</span>);</span></span><br><span class="line">    ret = get_unused_fd_flags(<span class="number">0</span>);</span><br><span class="line">    fd_install(ret, file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/file.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">fget</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">fd</span>, <span class="title">fmode_t</span> <span class="title">mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">refs</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 得到当前进程关联的打开文件表（Open file info table）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="comment">// 查找 fd -&gt; 文件句柄</span></span><br><span class="line">    file = fcheck_files(files, fd);</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="comment">/* File object ref couldn't be taken.</span></span><br><span class="line"><span class="comment">         * dup2() atomicity guarantee is the reason</span></span><br><span class="line"><span class="comment">         * we loop to catch the new file (or NULL pointer)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_mode &amp; mask)</span><br><span class="line">            file = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!get_file_rcu_many(file, refs))</span><br><span class="line">            <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p><code>close()</code> 系统调会回收文件描述符，同时会给文件描述符指向的文件句柄（file description）的引用计数减 1，并在需要的时候进行回收。该系统调用的实现流程总结如下：</p><p><img src="https://pic1.zhimg.com/v2-2152cb65cd8c5d140c444b4bda0be2f4.jpg" alt=""></p><p>其对应的代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(close, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = __close_fd(current-&gt;files, fd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/file.c</span></span><br><span class="line"><span class="comment">// __close_fd 关闭文件描述符，其中 `files` 指向的是当前进程关联的</span></span><br><span class="line"><span class="comment">// 打开文件描述符表。</span></span><br><span class="line"><span class="keyword">int</span> __close_fd(struct files_struct *files, <span class="keyword">unsigned</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line">    fdt = files_fdtable(files);</span><br><span class="line">    <span class="comment">// 判断传入的 file descriptor 有效性</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= fdt-&gt;max_fds)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">// 查找到关联的 file description，即文件句柄</span></span><br><span class="line">    file = fdt-&gt;fd[fd];</span><br><span class="line">    <span class="comment">// 回收 file descriptor</span></span><br><span class="line">    rcu_assign_pointer(fdt-&gt;fd[fd], <span class="literal">NULL</span>);</span><br><span class="line">    __put_unused_fd(files, fd);</span><br><span class="line">    spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">    <span class="comment">// 关闭 file description</span></span><br><span class="line">    <span class="keyword">return</span> filp_close(file, files);</span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">    <span class="keyword">return</span> -EBADF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filp_close 关闭指向的 file description，其中 id 为</span></span><br><span class="line"><span class="comment">// POSIX 线程 ID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filp_close</span><span class="params">(struct file *filp, <span class="keyword">fl_owner_t</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果文件引用计数为 0，说明存在错误，无法关闭</span></span><br><span class="line">    <span class="keyword">if</span> (!file_count(filp)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">"VFS: Close: file count is 0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_op-&gt;flush)</span><br><span class="line">        retval = filp-&gt;f_op-&gt;flush(filp, id);</span><br><span class="line">    <span class="comment">// 可能会回收 file description，但是会考虑其引用计数</span></span><br><span class="line">    fput(filp);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下定义在：fs/file_table.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fput</span><span class="params">(struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 给 file description 的引用计数减 1</span></span><br><span class="line">    fput_many(file, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fput_many</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> refs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 原子操作：&amp;file-&gt;f_count -= refs</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_long_sub_and_test(refs, &amp;file-&gt;f_count)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了下文件描述符和打开文件的关系，并简要讲解了 Linux 内核中关于这些抽象概念的具体实现。同时，还简单介绍了下 <code>open()</code>, <code>dup()</code> 和 <code>close()</code> 系统调用的实现。相信在看完这些后，能够更加深入和清晰地理解这三个概念：<strong>系统级打开文件表（open file table）/描述表（open file description table）</strong>、<strong>文件句柄（open file handle）/文件描述（file description）</strong>以及<strong>文件描述符（file descriptor）</strong>。</p><p>最后，回答下本文开头提到的问题。其实，站在进程的角度来看，作者在 <a href="https://juejin.im/entry/5b56f9045188251b157bb645" target="_blank" rel="noopener">Linux 文件句柄的这些技术内幕，只有 1% 的人知道</a> 中提到「每个进程都有一个<strong>打开的文件表（fdtable)</strong>」这样的说法其实也没什么问题。只是此处<strong>打开的文件表（fdtable)</strong>和《Linux 系统编程》中提到的系统级<strong>打开文件表（open file table）</strong>并非一个概念。作者提到的<strong>打开的文件表（fdtable)</strong>其实正是抽象的<strong>进程文件描述符（file descriptor）</strong>表。当然，我们没必要为此纠结，咬文嚼字也没什么意义，不过对于困惑的东西还是能够搞清楚才好。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/entry/5b56f9045188251b157bb645" target="_blank" rel="noopener">Linux 文件句柄的这些技术内幕，只有 1% 的人知道</a></li><li><a href="https://zhuanlan.zhihu.com/p/34280875" target="_blank" rel="noopener">Linux 内核文件描述符表的演变</a></li><li><a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener">man open(2)</a></li><li><a href="https://zhuanlan.zhihu.com/p/46031338" target="_blank" rel="noopener">Linux IO核心数据结构之一</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在《Linux 系统编程手册》5.4 节，关于文件描述符和打开的文件关系是这样描述的：「内核为所有打开的文件维护了一个系统级的&lt;strong&gt;描述表（open file description table）&lt;/strong&gt;，有时也称之为&lt;strong&gt;打开文件表（open file table）&lt;/strong&gt;，并将表中的每个条目称为&lt;strong&gt;打开文件句柄（open file handle）&lt;/strong&gt;。而针对每个进程，内核又为其维护了&lt;strong&gt;打开文件的描述符表（open file descriptor table）&lt;/strong&gt;」。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="文件描述符" scheme="http://ifaceless.space/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    
      <category term="文件句柄" scheme="http://ifaceless.space/tags/%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实现 Redis 字典</title>
    <link href="http://ifaceless.space/2019/12/17/implement-redis-dict-in-go/"/>
    <id>http://ifaceless.space/2019/12/17/implement-redis-dict-in-go/</id>
    <published>2019-12-17T09:18:10.000Z</published>
    <updated>2019-12-19T05:26:12.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://pic3.zhimg.com/80/v2-c3ed9fd26f9d28528282d51827b76e91.png" alt=""></p><p>字典在 Redis 中是一个非常重要的数据结构，因为 Redis 本身就是一个键值数据库。我们先来回顾下在 <a href="https://ifaceless.space/2019/12/15/redis-low-level-data-structures/">Redis 源码学习之基本数据结构</a>  中提到的 Redis 字典实现的一些特点：</p><ol><li>支持海量 <code>&lt;key, value&gt;</code> 存储；</li><li>使用渐进式 Rehash 策略，避免因为需要迁移的 buckets 太多导致阻塞时间过久（Redis 核心处理逻辑是单线程模型）；</li><li>默认使用 SipHash 算法计算键的 hash 值；</li><li>对于哈希冲突问题，采用了常见的链地址法，且新加入的节点会插入到链表的头部；</li><li>字典内部维护了两张哈希表，其中第二个哈希表会在扩容期间（Rehash）使用；</li><li>提供了安全和非安全的迭代器，方便对整个字典进行迭代。</li></ol><a id="more"></a><p>在看了 Redis 字典源码，搞懂它的工作原理后，有没有想要自己实现下呢？所以，本文将介绍如何使用 Go 语言来山寨一个 Redis 字典实现，虽然「容貌」有异，但「内核」还是基本一致的。为了简单起见，我们在实现的时候先不考虑 goroutine 安全问题，焦点放在 Redis 字典实现的核心思想上。所以后面的实现，都假设只有一个 goroutine 在对字典进行操作。由于 Go 语言自带 GC，所以使用它来实现就不用烦心内存管理的问题了（在 Redis <code>dict.c</code> 实现中，还有很多代码是涉及内存申请和释放的），这样就能让我们更加容易地理解核心的实现策略。</p><h1 id="一点说明"><a href="#一点说明" class="headerlink" title="一点说明"></a>一点说明</h1><p>正所谓「入乡随俗」嘛，所以在使用 Go 语言实现的字典中，并没有照搬原先 Redis 中字典的接口，而是提供了一组类似于标准库 <code>sync.Map</code> 的接口。</p><p>另外，什么样的 key 可以作为字典的键呢？首先，必须要是方便计算哈希值的；其次，方便进行直接比较。我们知道在 Redis 的字典实现中提供了一组接口，供实际使用字典存储的数据类型实现。之所以这样做，也是为了更好的扩展性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>不过为了简单起见，在使用 Go 语言实现时字典时，传入的 <code>key</code> 和 <code>value</code> 均为 <code>interface{}</code>  类型，并没有强制的接口实现要求。另外，针对 <code>key</code> 将只支持 <code>string</code> 和 <code>int</code> 类型及其变种。这种可以满足基本的使用场景，同时也能够拥有和 <code>sync.Map</code> 一样的接口签名。</p><p>最后，来看下字典的接口设计：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store 向字典中添加新的 key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">Store</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Load</span> 从字典中获取指定 <span class="title">key</span> 对应的值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">LoadOrStore</span> 用于根据指定 <span class="title">key</span> 先查找对应值，如果存在则返回对应值；</span></span><br><span class="line"><span class="function">// 否则，会将给定 <span class="title">key</span>-<span class="title">value</span> 存储到字典中，并返回传入的 <span class="title">value</span>。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">LoadOrStore</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Delete</span> 删除指定的 <span class="title">key</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Len</span> 返回字典的元素个数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">uint64</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Cap</span> 返回字典的容量</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">uint64</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Range</span> 模拟 <span class="title">Redis</span> 字典普通迭代器行为，不支持非安全的操作</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">Range</span><span class="params">(fn <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">RangeSafely</span> 模拟 <span class="title">Redis</span> 字典安全迭代器行为，迭代期间不做 <span class="title">rehash</span> 操作</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">RangeSafely</span><span class="params">(fn <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Resize</span> 用于调整字典容量（扩容或缩容，但是 <span class="title">rehash</span> 还是渐进式的）</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">Resize</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">RehashForAWhile</span> 执行一段时间的 <span class="title">rehash</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(d *Dict)</span> <span class="title">RehashForAWhile</span><span class="params">(duration time.Duration)</span></span></span><br></pre></td></tr></table></figure><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dict <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashTables []*hashTable</span><br><span class="line">    rehashIdx <span class="keyword">int64</span></span><br><span class="line">    iterators <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hashTable <span class="keyword">struct</span> &#123;</span><br><span class="line">    buckets []*entry</span><br><span class="line">    size <span class="keyword">uint64</span></span><br><span class="line">    sizemask <span class="keyword">uint64</span></span><br><span class="line">    used <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    next *entry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典初始化"><a href="#字典初始化" class="headerlink" title="字典初始化"></a>字典初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New 实例化一个字典。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Dict</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Dict&#123;</span><br><span class="line">        <span class="comment">// 初始化的时候，准备两张哈希表，默认使用哈希表 1</span></span><br><span class="line">        <span class="comment">// 在进行扩容时，会将哈希表 1 中的所有元素迁移到</span></span><br><span class="line">        <span class="comment">// 哈希表 2。</span></span><br><span class="line">        hashTables: []*hashTable&#123;&#123;&#125;, &#123;&#125;&#125;,</span><br><span class="line">        rehashIdx: <span class="number">-1</span>,</span><br><span class="line">        iterators: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在哈希表中查找指定的键"><a href="#在哈希表中查找指定的键" class="headerlink" title="在哈希表中查找指定的键"></a>在哈希表中查找指定的键</h2><p>下面这个函数将基于指定的 key 计算出对应的 hash 值（使用 SipHash 算法，Redis 字典中默认使用的哈希算法），并且通过查询哈希表来确定对应的 key 是否存在于字典中。这个函数比较重要，在后面的 <code>Load</code> 和 <code>Store</code> 函数中都有应用，下面来看看它的具体实现吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keyIndex 基于指定的 key 获得对应的 bucket 索引</span></span><br><span class="line"><span class="comment">// 如果 key 已经存在于字典中，则直接返回关联的 entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">keyIndex</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(idx <span class="keyword">uint64</span>, existed *entry)</span></span> &#123;</span><br><span class="line">    hash := SipHash(key)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        ht := d.hashTables[i]</span><br><span class="line">        idx = ht.sizemask &amp; hash</span><br><span class="line">        <span class="keyword">for</span> ent := ht.buckets[idx]; ent != <span class="literal">nil</span>; ent = ent.next &#123;</span><br><span class="line">            <span class="keyword">if</span> ent.key == key &#123;</span><br><span class="line">                <span class="keyword">return</span> idx, ent</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !d.isRehashing() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果字典处于 rehashing 中，上面的循环可以保证最后的 idx 一定位于</span></span><br><span class="line">    <span class="comment">// 第二个哈希表，从而保证依赖该接口的地方存储的新键一定进入到新的哈希表</span></span><br><span class="line">    <span class="keyword">return</span> idx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询键值对"><a href="#查询键值对" class="headerlink" title="查询键值对"></a>查询键值对</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load 从字典中加载指定的 key 对应的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() &#123;</span><br><span class="line">        d.rehashStep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, existed := d.keyIndex(key)</span><br><span class="line">    <span class="keyword">if</span> existed != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> existed.value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="存储键值对"><a href="#存储键值对" class="headerlink" title="存储键值对"></a>存储键值对</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store 向字典中添加 key-value。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">Store</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ent, loaded := d.loadOrStore(key, value)</span><br><span class="line">    <span class="keyword">if</span> loaded &#123;</span><br><span class="line">        ent.value = value <span class="comment">// 直接更新 value 即可</span></span><br><span class="line">    &#125; <span class="comment">// 否则，上述函数调用会自动添加 (key, value) 到字典中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loadOrStore 先尝试使用 key 查找，如果查找到则直接返回对应 entry，</span></span><br><span class="line"><span class="comment">// 否则，会添加新的 entry 到字典中，同时返回 nil，表示之前不存在。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">loadOrStore</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(ent *entry, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() &#123;</span><br><span class="line">        d.rehashStep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ = d.expandIfNeeded() <span class="comment">// 这里简单起见，假设一定是可以扩容成功的，忽略了错误</span></span><br><span class="line">    idx, existed := d.keyIndex(key)</span><br><span class="line">    ht := d.hashTables[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() &#123;</span><br><span class="line">        ht = d.hashTables[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> existed != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> existed, <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，需要在指定 bucket 添加新的 entry</span></span><br><span class="line">        <span class="comment">// 对于哈希冲突的情况，采用链地址法，在插入新的 entry 时，</span></span><br><span class="line">        <span class="comment">// 采用头插法，保证最近添加的在最前面</span></span><br><span class="line">        entry := &amp;entry&#123;key: key, value: value, next: ht.buckets[idx]&#125;</span><br><span class="line">        ht.buckets[idx] = entry</span><br><span class="line">        ht.used++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h2><p>删除操作值得一提的是，在查找到要删除的 Entry 后，需要记得调整哈希桶的头指针，可能被删除的 Entry 恰好就是头节点。代码实现比较简单，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete 从字典中删除指定的 key，如果 key 不存在，则什么也</span></span><br><span class="line"><span class="comment">// 不做。</span></span><br><span class="line"><span class="comment">// 实现描述：</span></span><br><span class="line"><span class="comment">// 1. 遍历哈希表，定位到对应的 buckets</span></span><br><span class="line"><span class="comment">// 2. 删除 buckets 中匹配的 entry。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 不要做无畏的挣扎！</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() &#123;</span><br><span class="line">        d.rehashStep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hash := SipHash(key)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        ht := d.hashTables[i]</span><br><span class="line">        idx := ht.sizemask &amp; hash</span><br><span class="line">        <span class="keyword">var</span> prevEntry *entry</span><br><span class="line">        <span class="keyword">for</span> ent := ht.buckets[idx]; ent != <span class="literal">nil</span>; ent = ent.next &#123;</span><br><span class="line">            <span class="keyword">if</span> ent.key == key &#123;</span><br><span class="line">                <span class="comment">// 此时需要释放 ent 节点</span></span><br><span class="line">                <span class="keyword">if</span> prevEntry != <span class="literal">nil</span> &#123;</span><br><span class="line">                    prevEntry.next = ent.next</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明待释放的节点是头节点，需要调整 buckets[idx] 指向下一个节点</span></span><br><span class="line">                    ht.buckets[idx] = ent.next</span><br><span class="line">                &#125;</span><br><span class="line">                ent.next = <span class="literal">nil</span></span><br><span class="line">                ht.used--</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            prevEntry = ent</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !d.isRehashing() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容和缩容"><a href="#扩容和缩容" class="headerlink" title="扩容和缩容"></a>扩容和缩容</h2><p>在给字典添加键值对时，会调用 <code>loadOrStore</code> 方法，而在该方法内部调用了一次 <code>d.expandIfNeeded()</code> 方法尝试给字典按需扩容。那么，字典扩容的时机是什么呢？扩容的策略又是怎样的呢？且看源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _initialHashtableSize <span class="keyword">uint64</span> = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">expandIfNeeded</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() &#123;</span><br><span class="line">        <span class="comment">// 此时表明扩容已经成功，正在进行迁移（rehash）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d.hashTables[<span class="number">0</span>].size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次扩容，需要一定的空间存放新的 keys</span></span><br><span class="line">        <span class="keyword">return</span> d.resizeTo(_initialHashtableSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，根据负载因子判断是否需要进行扩容</span></span><br><span class="line">    <span class="comment">// 扩容策略简单粗暴，至少要是已有元素个数的二倍</span></span><br><span class="line">    <span class="keyword">if</span> d.hashTables[<span class="number">0</span>].used == d.hashTables[<span class="number">0</span>].size &#123;</span><br><span class="line">        <span class="keyword">return</span> d.resizeTo(d.hashTables[<span class="number">0</span>].used * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">resizeTo</span><span class="params">(size <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里主要是要保证扩容大小符合要求，至少要比现有元素个数多</span></span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() || d.hashTables[<span class="number">0</span>].used &gt; size &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"failed to resize"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = d.nextPower(size)</span><br><span class="line">    <span class="keyword">if</span> size == d.hashTables[<span class="number">0</span>].size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备开始扩容</span></span><br><span class="line">    <span class="keyword">var</span> ht *hashTable</span><br><span class="line">    <span class="keyword">if</span> d.hashTables[<span class="number">0</span>].size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次执行扩容，给 ht[0] 准备好，接下来 keys 可以直接放进来</span></span><br><span class="line">        ht = d.hashTables[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ht = d.hashTables[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 表明需要开始进一步扩容，迁移 ht[0] -&gt; ht[1]</span></span><br><span class="line">        d.rehashIdx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ht.size = size</span><br><span class="line">    ht.sizemask = size - <span class="number">1</span></span><br><span class="line">    ht.buckets = <span class="built_in">make</span>([]*entry, ht.size)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextPower 找到匹配 size 的扩容大小</span></span><br><span class="line"><span class="comment">// 2^2 -&gt; 2^3 -&gt; 2^4 -&gt; 2^5 -&gt; ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">nextPower</span><span class="params">(size <span class="keyword">uint64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> size &gt;= math.MaxUint64 &#123;</span><br><span class="line">        <span class="keyword">return</span> math.MaxUint64</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := _initialHashtableSize</span><br><span class="line">    <span class="keyword">for</span> i &lt; size &#123;</span><br><span class="line">        i &lt;&lt;= <span class="number">1</span> <span class="comment">// i*= 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道了扩容是何时进行的了， 但是看起来并没有在删除元素时执行缩容操作呢？那缩容会在什么时候执行呢？在 Redis 中，是由字典的使用者来确定缩容的时机的，比如在删除键值对后，或者在 <code>serverCron</code> 中执行（具体调用链路为：<code>serverCron-&gt;databasesCron-&gt;tryResizeHashTables-&gt;dictResize</code>）。该方法的实现很简单，用 Go 语言表达如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resize 让字典扩容或者缩容到一定大小。</span></span><br><span class="line"><span class="comment">// 注意，这里只是会准备好用于扩容的第二个哈希表，但真正的迁移还是分散</span></span><br><span class="line"><span class="comment">// 在多次 Rehash 操作中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">Resize</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.isRehashing() &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"dict is rehashing"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := d.hashTables[<span class="number">0</span>].used</span><br><span class="line">    <span class="keyword">if</span> size &lt; _initialHashtableSize &#123;</span><br><span class="line">        size = _initialHashtableSize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d.resizeTo(size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>渐进式 Rehash 的思想很简单，就是将大量的工作分成很多步完成。在上面的源码中可以看到，<code>Load</code>, <code>Store</code>, <code>Delete</code> 方法中，都有调用 <code>d.rehashStep()</code>，进而又会调用 <code>d.rehash(1)</code>。下面我们来看看渐进式 Rehash 是怎么实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rehash 实现渐进式 Rehash 策略。基本思想就是，每次对最多</span></span><br><span class="line"><span class="comment">// steps 个 buckets 进行迁移。另外，考虑到可能旧的哈希表中</span></span><br><span class="line"><span class="comment">// 会连续遇到较多的空 buckets，导致耗费时间不受限制，这里还</span></span><br><span class="line"><span class="comment">// 限定最多遇到 10 * steps 个空 buckets 就退出。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">rehash</span><span class="params">(steps <span class="keyword">uint64</span>)</span> <span class="params">(finished <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !d.isRehashing() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxEmptyBucketsMeets := <span class="number">10</span> * steps</span><br><span class="line">    src, dst := d.hashTables[<span class="number">0</span>], d.hashTables[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> ; steps &gt; <span class="number">0</span> &amp;&amp; src.used != <span class="number">0</span>; steps-- &#123;</span><br><span class="line">        <span class="comment">// 扫描哈希表直到遇到非空的 bucket</span></span><br><span class="line">        <span class="keyword">for</span> src.buckets[d.rehashIdx] == <span class="literal">nil</span> &#123;</span><br><span class="line">            d.rehashIdx++</span><br><span class="line">            maxEmptyBucketsMeets--</span><br><span class="line">            <span class="keyword">if</span> maxEmptyBucketsMeets &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把整个 bucket 上所有的 entry 都迁移走</span></span><br><span class="line">        <span class="keyword">for</span> ent := src.buckets[d.rehashIdx]; ent != <span class="literal">nil</span>; &#123;</span><br><span class="line">            next := ent.next</span><br><span class="line">            idx := SiphHash(ent.key) &amp; dst.sizemask</span><br><span class="line">            ent.next = dst.buckets[idx]</span><br><span class="line">            dst.buckets[idx] = ent</span><br><span class="line">            src.used--</span><br><span class="line">            dst.used++</span><br><span class="line">            ent = next</span><br><span class="line">        &#125;</span><br><span class="line">        src.buckets[d.rehashIdx] = <span class="literal">nil</span> <span class="comment">// 清空旧的 bucket</span></span><br><span class="line">        d.rehashIdx++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果迁移完毕，需要将 ht[0] 指向迁移后的哈希表</span></span><br><span class="line">    <span class="keyword">if</span> src.used == <span class="number">0</span> &#123;</span><br><span class="line">        d.hashTables[<span class="number">0</span>] = dst</span><br><span class="line">        d.hashTables[<span class="number">1</span>] = &amp;hashTable&#123;&#125;</span><br><span class="line">        d.rehashIdx = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典迭代器"><a href="#字典迭代器" class="headerlink" title="字典迭代器"></a>字典迭代器</h2><p>迭代器的数据结构定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterator 实现了一个对字典的迭代器。</span></span><br><span class="line"><span class="comment">// 不过考虑到我们将为字典提供 `Range` 方法，故该迭代器就不往外暴露了。</span></span><br><span class="line"><span class="keyword">type</span> iterator <span class="keyword">struct</span> &#123;</span><br><span class="line">    d *Dict</span><br><span class="line">    tableIndex <span class="keyword">int</span></span><br><span class="line">    safe <span class="keyword">bool</span></span><br><span class="line">    fingerprint <span class="keyword">int64</span></span><br><span class="line">    entry *entry</span><br><span class="line">    bucketIndex <span class="keyword">uint64</span></span><br><span class="line">    waitFirstIteration <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIterator</span><span class="params">(d *Dict, safe <span class="keyword">bool</span>)</span> *<span class="title">iterator</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;iterator&#123;</span><br><span class="line">        d: d,</span><br><span class="line">        safe: safe,</span><br><span class="line">        waitFirstIteration: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Redis 的字典中，提供了两种类型的迭代器，分别通过 <code>dictGetIterator</code> 和 <code>dictGetSafeIterator</code> 获得。普通迭代器只能执行和字典关联的 <code>dictNext</code> 方法，不允许执行 <code>dictFind</code>，<code>dictAdd</code> 等操作，这主要是因为这些操作可能会引起 Rehash，从而导致在迭代期间可能会扫描到重复的键值对（比如在执行 Rehash 期间，某些键值对被迁移到了新的哈希表，但是我们是优先扫描第一个哈希表，然后再扫描第二个哈希表，而此时可能会遇到之前扫描过的元素）。当然，Redis 的普通迭代器是没法阻止你在迭代期间执行不安全的操作的，但是它会通过计算迭代前后字典的指纹信息，并在最后进行比对，若指纹不匹配，则无法通过 <code>assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d))</code> 断言。</p><p>那么安全迭代器又是如何做到可以允许 <code>dictFind</code> 和 <code>dictAdd</code> 等操作执行的呢？其实它是通过阻止字典 <code>rehash</code> 实现的，正因为如此，它才可以放心大胆地扫描哈希表中的 Entries，而不用担心遇到重复的 Entries。在上面的代码中可以看到，在 <code>Load</code>、<code>Store</code> 和 <code>Delete</code> 中都有直接或间接地调用 <code>d.rehashStep()</code> 方法，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dict)</span> <span class="title">rehashStep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.iterators == <span class="number">0</span> &#123;</span><br><span class="line">        d.rehash(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们来看看迭代器最重要的 <code>next()</code> 方法实现，就可以看到安全迭代器和普通迭代器的区别了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next 会依次扫描字典中哈希表的所有 buckets，并将其中的 entry 一一返回。</span></span><br><span class="line"><span class="comment">// 如果字典正在 rehash，那么会在扫描完哈希表 1 后，继续扫描哈希表 2。需要</span></span><br><span class="line"><span class="comment">// 注意的是，如果在迭代期间，继续向字典中添加数据可能没法被扫描到！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *iterator)</span> <span class="title">next</span><span class="params">()</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> it.entry == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> it.waitFirstIteration &#123;</span><br><span class="line">                <span class="comment">// 第一次迭代，要做点特别的事情~</span></span><br><span class="line">                <span class="keyword">if</span> it.safe &#123;</span><br><span class="line">                    <span class="comment">// 告诉 dict，有正在运行的安全迭代器，进而阻止某些操作时的 Rehash 操作</span></span><br><span class="line">                    it.d.iterators++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    it.fingerprint = it.d.fingerprint()</span><br><span class="line">                &#125;</span><br><span class="line">                it.waitFirstIteration = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ht := it.d.hashTables[it.tableIndex]</span><br><span class="line">            <span class="keyword">if</span> it.bucketIndex &gt;= ht.size &#123;</span><br><span class="line">                <span class="keyword">if</span> !it.d.isRehashing() || it.tableIndex != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换到第二个哈希表继续扫描</span></span><br><span class="line">                it.tableIndex = <span class="number">1</span></span><br><span class="line">                it.bucketIndex = <span class="number">0</span></span><br><span class="line">                ht = it.d.hashTables[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it.entry = ht.buckets[it.bucketIndex]</span><br><span class="line">            it.bucketIndex++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            it.entry = it.entry.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> it.entry != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> it.entry</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := dict.New()</span><br><span class="line">    d.Store(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    d.Store(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">    fmt.Println(d.Load(<span class="string">"hello"</span>))</span><br><span class="line">    fmt.Println(d.LoadOrStore(<span class="string">"language"</span>, <span class="string">"Eng"</span>))</span><br><span class="line">    d.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        fmt.Println(key, <span class="string">"=&gt;"</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    _ = d.Resize()</span><br><span class="line">    d.RehashForAWhile(<span class="number">1</span> * time.Microsecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好啦，关于 Redis 字典的实现介绍就到此为止啦。相信看完上面的代码后，应该可以了解到 Redis 字典的扩容机制、渐进式 Rehash 策略，以及哈希冲突解决方案。完整的实现代码及其单元测试参见 <a href="https://gitee.com/ifaceless/go-redis-dict" target="_blank" rel="noopener">go-redis-dict</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-c3ed9fd26f9d28528282d51827b76e91.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;字典在 Redis 中是一个非常重要的数据结构，因为 Redis 本身就是一个键值数据库。我们先来回顾下在 &lt;a href=&quot;https://ifaceless.space/2019/12/15/redis-low-level-data-structures/&quot;&gt;Redis 源码学习之基本数据结构&lt;/a&gt;  中提到的 Redis 字典实现的一些特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持海量 &lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt; 存储；&lt;/li&gt;
&lt;li&gt;使用渐进式 Rehash 策略，避免因为需要迁移的 buckets 太多导致阻塞时间过久（Redis 核心处理逻辑是单线程模型）；&lt;/li&gt;
&lt;li&gt;默认使用 SipHash 算法计算键的 hash 值；&lt;/li&gt;
&lt;li&gt;对于哈希冲突问题，采用了常见的链地址法，且新加入的节点会插入到链表的头部；&lt;/li&gt;
&lt;li&gt;字典内部维护了两张哈希表，其中第二个哈希表会在扩容期间（Rehash）使用；&lt;/li&gt;
&lt;li&gt;提供了安全和非安全的迭代器，方便对整个字典进行迭代。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ifaceless.space/categories/Redis/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="Redis" scheme="http://ifaceless.space/tags/Redis/"/>
    
      <category term="字典" scheme="http://ifaceless.space/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码学习之基本数据结构</title>
    <link href="http://ifaceless.space/2019/12/15/redis-low-level-data-structures/"/>
    <id>http://ifaceless.space/2019/12/15/redis-low-level-data-structures/</id>
    <published>2019-12-15T06:11:14.000Z</published>
    <updated>2019-12-15T06:17:36.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://pic4.zhimg.com/v2-1d46ebdc21d0364fefecf710d01f473d.jpeg" alt=""></p><p>Redis 底层的基础数据结构包括：动态字符串（sds）、跳表（skiplist）、压缩列表（ziplist）、字典（dict）、整数集合（intset），快速链表（quicklist）等，<code>t_hash</code>，<code>t_set</code>, <code>t_zset</code>, <code>t_list</code> 等对外类型的内部实现都依赖于这些数据结构，所以非常值得学习。</p><a id="more"></a><p>在学习每种数据结构时，需要重点关注如下几个问题：</p><ol><li>为什么这样设计，做了什么样的权衡？比如，有些数据结构是为了节约内存而设计的，所以会牺牲一定的查找效率；</li><li>每种数据结构的基本特点是什么？具体在什么场景下应用到？</li><li>一些数据结构接口的平均时间复杂度是什么？</li><li>很多数据结构在上层使用时，会根据需要选择，必要时会进行转换。需要了解转换的时机和触发的条件是什么？</li><li>某些数据结构内部会按需扩容或者缩容，需要关注它们扩容或者缩容的策略如何？什么情况下触发？</li></ol><p>本文的源码学习笔记是基于 Redis 5.0.7 版本做的，自己做了些中文注释，推送到了 <a href="https://github.com/iFaceless/redis/blob/comment-src/src" target="_blank" rel="noopener">redis comment-src 分支</a>，参考书籍为《Redis 5 源码设计与分析》。</p><p><strong>做了一个简单的思维导图，简单总结了各个数据结构的基本特点和一些值得阅读源码的 APIs</strong>，如果想要快速了解的话，可以直接跳到本文最后一节查看~</p><h1 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h1><p>动态字符串（SDS, Simple Dynamic String）是 Redis 中最常用的数据类型之一，可以用来存储字符串和整数。并且它是二进制安全的，还兼容 C 语言字符串的结束符 ‘\0’，所以部分 C 标准库中的字符串函数也可以对 SDS 进行操作。</p><p>动态字符串元信息及存储字符串的 buf 是由 sdshdr* 维护的，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __attribute__ ((__packed__)) 使用这种方式，要求编译器编译时，按照实际的字节数进行对齐。</span></span><br><span class="line"><span class="comment">// 这样做的好处有两个：</span></span><br><span class="line"><span class="comment">// 1. 节约内存（否则不同的 sdshdr* 因为不同的字节对齐方式，而导致占据较多内存）</span></span><br><span class="line"><span class="comment">// 2. 通过 header 获得 buf 地址时，不用考虑繁琐的字节对齐问题而导致计算复杂</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="comment">// flags 的低三位表示类型，高三位表示字符串长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="comment">// len 字符串长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="comment">// alloc 表示柔性数组分配的长度（不包含 header 和字符串终止符号）</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="comment">// flags 低三位表示类型，高 5 位保留</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外还有 sdshdr16, sdshdr32, sdshdr64，区别仅在于 len, alloc 使用的整数字节长度</span></span><br></pre></td></tr></table></figure><p>关于 SDS 的几个问题：</p><ol><li><strong>如何兼容 C 语言字符串标准？</strong> SDS 返回的就是指向存储字符串 buf 的指针，且以 ‘\0’ 结尾。</li><li><strong>如何节约内存？</strong> SDS 中根据字符串长度，提供了不同类型的结构体表示（sdshdr5, sdshdr8, sdshdr16, sdshdr32, sdshdr64），并且结构体中的字段按照单字节对齐（<code>((__packed__))</code>）进一步减少因默认字节对齐方式带来了内存消耗；同时按照单字节对齐，也方便基于 header 指针计算出柔性数组的指针。</li><li><strong>如何做到二进制安全？</strong> SDS Header 结构体中拥有 <code>len</code> 字段，记录了实际字符串的长度（不含结束符），因此在读取的时候可以确切地知道在哪儿停止，不会受到中间的 ‘\0’ 影响。</li><li><strong>SDS 在创建空字符串时，为何将 sdshdr5 转成 sdshdr8？</strong> 考虑到 sdshdr5 可能需要频繁扩容，导致内存复制开销。使用 sdshdr8 可以有效缓解。</li><li><strong>SDS 对于短字符串为何使用 sdshdr5？</strong> 很简单，还是为了节省内存空间，多数的字符串可能都是短字符串（长度 32 以内）。</li><li><strong>SDS 在写入时可能会扩容，那么它的扩容策略是怎样的？</strong>它的策略比较简单，如果 buf 剩余空间（alloc-len）能够放下新增的字符串长度，则不会有实质的扩容发生；如果剩余空间不够，则需要看 len+newLen 的长度值，如果小于 1MB，则按照 2 倍扩容；否则每次增加 1MB。在扩容后，还要看新的 header 类型（flags 字段表示）是否和之前一样，如果一样，则直接使用 realloc 原地扩容即可；否则需要使用 malloc 开辟新空间，并使用 <code>memcopy</code> 复制数据。完成扩容后，需要更新 SDS 的一些统计信息，并返回新的 buf 指针（也可能指向原来位置，具体看扩容时的策略执行）。</li></ol><h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><p>详细的源码注释参见 <a href="https://github.com/iFaceless/redis/blob/9366cba9171ea96f54b96f7d83e654958fe9b71f/src/sds.c#L90" target="_blank" rel="noopener">这里</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sdsnewlen 创建一个新的 sds 对象，并使用 init 指向的内容初始化</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">// 空字符串创建通常都需要执行 append 追加字符串。使用 type 8 比较适合，</span></span><br><span class="line">    <span class="comment">// type 5 可能空间不足，还需要执行扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type); <span class="comment">// 根据数据类型确定 header 长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 分配 sds 内存，+1 为了存储 '\0'</span></span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 内存初始化为 0</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen; <span class="comment">// 拿到指向 buf 的指针</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// point to flag, 注意 flag 其实是 unsigned char 类型</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="comment">// type 5 的 flag 比较特殊，类型保留在低 3 位</span></span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// SDS_TYPE_16, SDS_TYPE_32, SDS_TYPE_64...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 将用户指定区域的数据拷贝过来，不考虑 \0，二进制安全</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>; <span class="comment">// C 语言字符串以 '\0' 结尾</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// s 实际指向的是 buf 位置，这里需要计算出 header 指针</span></span><br><span class="line">    <span class="comment">// flag 始终位于 buf 前面，所以 s[-1] 可以得到 flag，进而</span></span><br><span class="line">    <span class="comment">// 确定 type，从而可以计算出 header 长度</span></span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s); <span class="comment">// 确定 buf 剩余的空间（alloc-len）</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="comment">// 如果剩余空间足够，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 确定现有字符串长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">// 获得字符串对应的 sdshdr 指针</span></span><br><span class="line">    sh = (<span class="keyword">char</span> *)s - sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">// 这里的新长度是后面扩容策略执行的依据</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 目前是 1MB 以内，2 倍扩容</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则都是加 1MB</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5)</span><br><span class="line">        type = SDS_TYPE_8;</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype == type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果类型不变，则执行扩容</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen + newlen + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 获取新的 sds 指向</span></span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        <span class="comment">// 由于 header 大小发生了变化，这里需要使用 malloc 开辟空间了</span></span><br><span class="line">        newsh = s_malloc(hdrlen + newlen + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 将 sds 中的内容拷贝到新的空间，包括 \0</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放旧的内存</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        <span class="comment">// 获取新的 sds 指针</span></span><br><span class="line">        s = (<span class="keyword">char</span> *)newsh + hdrlen;</span><br><span class="line">        <span class="comment">// 更新 flags</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        <span class="comment">// 更新长度信息</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新分配的空间大小</span></span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳表（skiplist）"><a href="#跳表（skiplist）" class="headerlink" title="跳表（skiplist）"></a>跳表（skiplist）</h1><p>跳表是 Redis 集合（zset）底层的实现方式之一（另一种是 ziplist）。跳表的特点如下：</p><ol><li>原理简单，实现难度远低于平衡树（红黑树）；</li><li>对于查找、插入和删除，平均 O(logN) 时间复杂度，效率和红黑树相当；</li><li>内存开销相对平衡树并没有特别大；</li><li>特别容易实现 Redis zset 中范围查询。</li></ol><p>跳表核心要素：<strong>分层</strong> + <strong>有序链表</strong>。</p><p>跳表查找过程描述：从最上层依次向后查找，如果本层的 next 节点大于要查找的值，或者 next 节点为 NULL，则从本节点开始，降低一层继续往后查找。如果找到目标节点，则返回；否则返回 NULL。</p><p><em>此前使用 Go 语言尝试实现了下 Redis 跳表，相关文章参见 <a href="https://zhuanlan.zhihu.com/p/96849002" target="_blank" rel="noopener">Go 语言实现 Redis 跳表</a>，源码及注释参见 <a href="https://link.zhihu.com/?target=https%3A//gitee.com/ifaceless/goskiplist/tree/master" target="_blank" rel="noopener">此处</a>。感兴趣的童鞋可以阅读下~</em></p><h2 id="Redis-跳表实现特点"><a href="#Redis-跳表实现特点" class="headerlink" title="Redis 跳表实现特点"></a>Redis 跳表实现特点</h2><p><img src="https://pic1.zhimg.com/80/v2-102788cac4f586778ffbf6767eb99d4f.png" alt=""></p><ol start="0"><li>最多有 64 层，可以表示 2^64 个元素；</li><li>拥有 backward 后退指针，方便反向遍历；</li><li>添加了 span 字段，记录 forward 指向的节点和当前节点的间隔。span 越大，跳过的节点会越多。在计算排名（rank）时，就可以通过 span 计算得到；</li><li>新增节点时，层高是通过 <code>zlsRandomLevel()</code> 函数随机生成的，范围是 [1, 64]。但是该函数会保证越高 level 值的出现的概率越低。节点的层高确定后，将不会改边；</li><li>节点中的 score 允许重复。</li></ol><h2 id="跳表的具体应用"><a href="#跳表的具体应用" class="headerlink" title="跳表的具体应用"></a>跳表的具体应用</h2><p>zset 会使用跳表存储数据，但是它会根据配置 <code>zset-max-ziplist-entries 128</code> 和 <code>zset-max-ziplist-value 64</code> 值来确定该使用跳表还是 ziplist。另外，在新增元素时，如果原先是 ziplist，当临界条件达到时，会被转换成 skiplist，而且转变后就不可逆了。</p><h2 id="核心源码-1"><a href="#核心源码-1" class="headerlink" title="核心源码"></a>核心源码</h2><p>与跳表相关的几个重要的函数作了注释，参见 <a href="https://github.com/iFaceless/redis/blob/9366cba9171ea96f54b96f7d83e654958fe9b71f/src/t_zset.c#L144" target="_blank" rel="noopener">此处</a>。需要重点关注的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span></span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span></span></span><br></pre></td></tr></table></figure></p><p>在看源码时，会经常看到 <code>update[]</code> 数组，这个数组是用来存放每一层需要被更新的节点（在增加、删除节点时会用到），把它看成 <code>pending_update_nodes</code> 或许会更好理解点。<br>另外，在增、删、改的时候，都会涉及到 <code>span</code> 的更新，需要仔细斟酌计算逻辑，一不小心就算错了。</p><h1 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h1><p>压缩表本质上就是一个字节数组，是一种为节约内存而设计的数据结构。可以存储多个元素，且每个元素可以是整数或者字符串（这里其实也可以理解为二进制安全的字节数组）。两端操作（pop/push）时间复杂度为 O(1)，但考虑到它每次插入或删除元素时，都需要调整内存（扩容或者缩小内存占用），所以实际的时间复杂度和它占用的内存有关。</p><p>ziplist 在<strong>散列表、列表和有序集合</strong>中均有（直接或间接地）应用。我们可以通过 <code>object encoding &lt;key&gt;</code> 来查看具体的使用的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd visitors 1.0 a</span><br><span class="line">&gt; object encoding visitors</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>在 Redis 的 <code>ziplist.c</code> 中，作者在注释中给出了压缩列表存储布局，并且给出了非常详细的说明和示例，值得阅读。整体来看，压缩列表的内存布局如下：<br><img src="https://pic4.zhimg.com/80/v2-0da8094f90661a53f47145881faf3315.png" alt=""></p><table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>压缩表字节长度（包括 <code>zlbytes</code> 自己）</td></tr><tr><td>zltail</td><td>uint32_t</td><td>尾元素相对于压缩列表起始地址的偏移，如此方便快速 pop 最后一个元素</td></tr><tr><td>zllen</td><td>uint16_t</td><td>表示 entries 的个数，最大有效值为 <code>2^16-2</code>，一旦超出，该值固定为 <code>2^16-1</code>，并且需要遍历整个列表才能得到准确的长度</td></tr><tr><td>zlend</td><td>uint8_t</td><td>固定为 <code>0xff</code>，表示压缩列表的结尾</td></tr></tbody></table><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>接下来，我们看看每个 entry 究竟是什么样子的，如下所示：<br><img src="https://pic4.zhimg.com/80/v2-84cb4d8cd05b321b4f611a492471c88a.png" alt=""></p><p>其中，<code>prevlen</code> 表示前一个 <code>entry</code> 的字节数，便于从后向前遍历；<code>encoding</code> 则表示当前 <code>entry</code> 的编码（整数类型？字符串类型？）；而 <code>entry-data</code> 则是真实存储内容的部分。当然，为了节约内存，这里的 <code>prevlen</code> 和 <code>encoding</code> 都是变长的，而 <code>entry-data</code> 则可能没有（比如存储小整数 0~12 时）。</p><p>默认情况下，<code>prevlen</code> 采用 <code>uint8_t</code> 类型，可表示最多 253 字节长度，超出 253 后，将会使用 5 个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 常规情况下</span><br><span class="line">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;</span><br><span class="line">// 长度超过 253 后</span><br><span class="line">0xFE &lt;4 字节，小端序 prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</span><br></pre></td></tr></table></figure><p><code>encoding</code> 字段也比较有趣，它占用多少个字节，和实际要存储的内容有关：</p><ul><li>如果是字符串类型，则 <code>encoding</code> 的前两位表示类型，剩下的则表示字符串的长度：<ul><li><code>|00pppppp|</code>：表示长度小于 64 字节的字符串，<code>pppppp</code> 表示 6 位无符号整数</li><li><code>|01pppppp|qqqqqqqq| - 2 字节</code>：表示长度小于 2^14 字节的字符串</li><li><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 字节</code>：表示长度小于 2^32 的字符串 </li></ul></li><li>如果是整数类型，则 <code>encoding</code> 的前两位总是 1，紧接着的两位则表示具体的整数类型：<ul><li><code>|11000000|</code>：int16</li><li><code>|11010000|</code>：int32</li><li><code>|11100000|</code>：int64</li><li><code>|11110000|</code>：24 位有符号整数</li><li><code>|11111110|</code>：8 位有符号整数</li><li><code>|1111xxxx|</code>：表示 4 位立即整数（imediate integer），0~12 无符号整数，此时没有 <code>entry-data</code> 字段了</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据上面描述的 ziplist 编码，我们来看看什么条件下它会占用较多内存？为什么说 ziplist 适合存储个数较少，且长度较短的元素呢？</p><ol><li>通过 <code>zzlen</code> 可知，如果元素个数超出 <code>2^16-2</code> 时，需要遍历整个 ziplist 元素才可以知道具体的长度，效率自然会降低很多；</li><li>通过 <code>prevlen</code> 可知，如果前一个 <code>entry</code> 超出其表示的范围时（253 字节），就需要由原来的 1 个字节变成 5 字节表示；</li><li>通过 <code>encoding</code> 可知，对于字符串类型元素，长度越长，<code>encoding</code> 需要占用的字节越多。尤其是在超出 <code>2^14-1</code>  时，新的 <code>encoding</code> 还要浪费第一个字节中的后 6 位，而使用后面的 32 位整数来表示字符串长度。</li></ol><p>综上所述，影响内存占用和执行效率的主要因素如下：</p><ol><li>元素个数；</li><li>元素类型；</li><li>元素长度。</li></ol><h2 id="核心源码-2"><a href="#核心源码-2" class="headerlink" title="核心源码"></a>核心源码</h2><p>为了方便获得每个 entry 相关的元信息，在 <code>ziplist.c</code> 中定义了一个 <code>zlentry</code> 结构体，但需要注意的是该结构体并非 entry 实际编码的布局。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zlentry 存在的目的就是保存每个 entry 解码后的元信息。因为实际每次对 length, encoding</span></span><br><span class="line"><span class="comment">// 等进行解码是比较复杂的运算，这里缓存下来也便于后续操作。</span></span><br><span class="line"><span class="comment">// 所以，需要注意的是，zlentry 并非真实的 entry 编码结构。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">// prevrawlensize 表示 `prevlen` 占用了几个字节来表示前一个 entry 的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="comment">// prevrawlen 表示前一个 entry 的实际长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen; <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="comment">// lensize 表示 `encoding` 占用了几个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize; <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="comment">// len 表示 entry 内容真正的长度。如果是字符串，就表示字符串长度；如果是整数</span></span><br><span class="line">    <span class="comment">// 则可能的值为 0（4 位小整数），1，2，3，4，8（和具体的 int 类型有关）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len; <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="comment">// headersize 表示整个 header 部分长度：&lt;prevlen&gt; + &lt;encoding&gt;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize; <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="comment">// encoding 表示具体的编码方式，如果 `ZIP_STR_*`,`ZIP_INT_*`</span></span><br><span class="line">    <span class="comment">// 这里需要注意的是，如果是小整数，还要做范围检查</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding; <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="comment">// p 指向元素开头的指针，实际指向的就是 `prevlen` 位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p; <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure></p><p>为了方便理解，画一个示例图如下：<br><img src="https://pic2.zhimg.com/v2-74aa62891936d8a5ebd929fe2fcf4656.jpg" alt=""></p><p>ziplist 相关的源码参见 <a href="https://github.com/iFaceless/redis/blob/comment-src/src/ziplist.c" target="_blank" rel="noopener">此处</a>。值得重点关注的几个函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span></span>;</span><br></pre></td></tr></table></figure><p>ziplist 中比较晦涩或者枯燥的部分是编码、解码操作；其次，每次增加或者移除元素时，都涉及到很多内存操作（分配空间、内存拷贝）以及 entry header 的调整。想要写出可靠的代码来，还是需要心思缜密，逻辑清晰才可以，大佬们的编码能力实在是太强悍了！</p><p>这里需要提一点的是，元素的插入和删除，可能会产生<strong>连锁更新</strong>问题。也就是说，可能会导致自插入点（或删除点）后续的 entry prevlen 都需要修改（还记得前面提到的 entry prevlen 是变长的吗，所以可能需要将 prevlen 增长到 5 字节容纳更大的值；但是反过来，并没有允许缩容）。不过这种情况，只有在后续元素的大小接近于 <code>ZIP_BIG_PREVLEN</code> 才可能发生，概率比较低，所以实际上也没做什么优化。具体策略的实现可以参考 <code>__ziplistCascadeUpdate()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line">    <span class="comment">// 遍历所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算当前 entry 长度存储需要的字节数：rawlensize</span></span><br><span class="line">        zipEntry(p, &amp;cur);</span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        rawlensize = zipStorePrevEntryLength(<span class="literal">NULL</span>, rawlen);</span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        zipEntry(p + rawlen, &amp;next);</span><br><span class="line">        <span class="comment">// 如果长度不变，则直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            <span class="comment">// 下一个元素的 prevlen 需要更多字节来存储 prevrawlen 值</span></span><br><span class="line">            offset = p - zl;</span><br><span class="line">            extra = rawlensize - next.prevrawlensize;</span><br><span class="line">            <span class="comment">// 扩容以支持存储更长的 rawlen</span></span><br><span class="line">            zl = ziplistResize(zl, curlen + extra); <span class="comment">// 增加 extra 空间</span></span><br><span class="line">            p = zl + offset;</span><br><span class="line">            np = p + rawlen;</span><br><span class="line">            noffset = np - zl;</span><br><span class="line">            <span class="comment">// 更新 tail 偏移，最后一个元素会被移动到新的位置</span></span><br><span class="line">            <span class="keyword">if</span> ((zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np)</span><br><span class="line">            &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + extra);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将后续 entry 搬移，腾挪出空间存放新的长度值</span></span><br><span class="line">            memmove(np + rawlensize,</span><br><span class="line">                    np + next.prevrawlensize,</span><br><span class="line">                    curlen - noffset - next.prevrawlensize - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// next entry prevlen 记录下之前 entry 的长度值        </span></span><br><span class="line">            zipStorePrevEntryLength(np, rawlen);</span><br><span class="line">            <span class="comment">// ...继续下一个元素，每次都可能涉及到内存的扩容和元素的 memmove 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 阻止进行缩容，目的是为了防止后续插入时，可能频繁地 shrink 或者 grow 导致</span></span><br><span class="line">            <span class="comment">// 更多地开销。</span></span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                zipStorePrevEntryLengthLarge(p + rawlen, rawlen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                zipStorePrevEntryLength(p + rawlen, rawlen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h1><p>字典在 Redis 中是一个非常重要的数据结构，因为 Redis 本身就是一个 Key-Value 数据库。Redis 中的字典实现特点如下：</p><ol><li>可以支持海量的 key-value 映射；</li><li>key 的类型可以是字符串、整数等类型（<code>void *</code>）；value 可以是复杂的数据类型（string, hash, list, set, sorted set）或者是整数、浮点数等；</li><li>为了避免哈希冲突，采用了链地址法，将冲突的 Entry 串联了起来；</li><li>为了避免在进行扩容或者缩容时，需要对海量 keys 进行 rehash 而导致阻塞时间过久，采用了渐进式 rehash 策略；</li><li>提供了安全和非安全的迭代器，方便对整个字典进行迭代；</li><li>对于 keys 非常大的字典，提供了 <code>dictScan</code> 方法，间断迭代，避免因为普通迭代时阻塞其它操作。</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表真正的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// sizemask = size-1，这里用于 hash &amp; sizemask 计算出 slot</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 哈希表中的 keys 个数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// 依赖数据抽象的操作接口</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 私有数据，配合 type 字段指向的函数使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 有两个 hash table</span></span><br><span class="line">    <span class="comment">// rehashidx 表示 rehash 的进度</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// iterators 当前正在运行的迭代器数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>字典整体结构可以用下图来表示：<br><img src="https://pic3.zhimg.com/80/v2-c3ed9fd26f9d28528282d51827b76e91.png" alt=""></p><h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>在执行 <code>dictAddRaw()</code> 时，会尝试进行扩容，调用流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dictAddRaw()</span><br><span class="line">  _dictKeyIndex()</span><br><span class="line">    _dictExpandIfNeeded()</span><br><span class="line">      dictExpand()</span><br><span class="line">        _dictNextPower()</span><br></pre></td></tr></table></figure><p>所以扩容或者缩容的核心逻辑在 <code>dictExpand()</code> 函数，我们来看看该函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确保我们要扩容的大小可以容纳目前的元素</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 得到目标扩容大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="comment">// 扩容时比较耗时的操作，避免无效扩容</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 初始化新的哈希表</span></span><br><span class="line">    dictht n;</span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ht[1] 指向的哈希表供渐进式 rehash 使用。</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// 表示 rehash 准备完毕，进度为 0</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容策略：4 -&gt; 4 * 2 -&gt; 4 * 2 * 2 -&gt; ...</span></span><br><span class="line"><span class="comment">// 按照 2 的倍数增加，直到第一个可以容纳 size 大小的数找到为止</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX)</span><br><span class="line">        <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要的时候，Redis 可以对字典执行缩容操作，具体可以调用 <code>dictResize()</code> 函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渐进式-Rehash"><a href="#渐进式-Rehash" class="headerlink" title="渐进式 Rehash"></a>渐进式 Rehash</h2><p>为了避免在 rehash 期间，因为要迁移的 keys 太多，导致阻塞其它操作时间太久，Redis 的字典实现中，使用了渐进式 rehash 的策略，从而将对大量 keys 的迁移分散在 N 次操作中，直到最终完成，具体实现参见 <a href="https://github.com/iFaceless/redis/blob/4c5a6f422b60500816e9c507bb0265495f483dda/src/dict.c#L206" target="_blank" rel="noopener">dictRehash()</a>。</p><p>采用了渐进式 rehash 策略后，每次在执行查找、插入、更新、删除以及 Redis 服务器空闲时，可以执行一部分 keys 的 rehash 操作。具体执行时机如下：</p><ol><li><p><code>_dictRehashStep() -&gt; dictRehash(d, 1)</code>：</p><ol><li><code>dictAddRaw()</code></li><li><code>dictDelete()</code></li><li><code>dictUnlink()</code></li><li><code>dictFind()</code></li><li><code>dictGetRandomKey()</code></li><li><code>dictGetSomeKeys()</code></li></ol></li><li><p><code>incrementallyRehash() -&gt; dictRehashMilliseconds(d, 1) -&gt; dictRehash(d, 100)</code>：Server 处于空闲时执行 1ms 的 rehash 工作。</p></li></ol><h2 id="普通迭代器与安全迭代器"><a href="#普通迭代器与安全迭代器" class="headerlink" title="普通迭代器与安全迭代器"></a>普通迭代器与安全迭代器</h2><p>迭代器是一种常见的设计模式，它可以方便我们对容器中的元素进行遍历，但不需要了解容器内部实现细节。Redis 的字典也我们提供了迭代器数据结构，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="comment">// table 指向的当前在迭代 table，safe 表明是否为安全的迭代器</span></span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">// fingerprint 用来检查非安全迭代器在使用期间是否执行了不允许的操作</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>;</span><br></pre></td></tr></table></figure><p>安全迭代器和普通迭代器的区别：</p><ul><li>安全迭代器允许我们在迭代期间，执行查找、删除、新增等对 dict 有副作用的操作（如执行 <code>keys *</code> 命令时会创建安全迭代器）；</li><li>普通迭代器则只能允许我们执行 <code>dictNext()</code> 进行迭代，其它操作是不允许的（如执行 <code>sort</code> 会创建非安全迭代器）。</li></ul><p>那么，为什么会有这样的限制呢？这主要是因为在迭代期间，如果有执行查找、添加、删除等操作，可能会发生 rehash，进而导致扫描到重复的 entry。</p><p>普通迭代器在迭代开始时，计算出当前 dict 的指纹，并在迭代结束时再次计算 dict 的指纹，从而确定 dict 在此期间是否发生过修改过，相关实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 开始迭代，计算下 fp</span></span><br><span class="line">                iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，安全迭代器又是如何做到安全的呢？其实策略很简单，就是在执行对 dict 有副作用的操作时，阻止其进行 rehash 即可，这样可以保证底层的 hash tables 不会有 keys 的迁移。具体实现如下：</p><ul><li>迭代器初始化时，<code>safe</code> 字段置 1；</li><li>初次迭代时，执行 <code>iter-&gt;d-&gt;iterators++</code>，告诉 <code>dict</code> 当前存在安全的迭代器在运行；</li><li><code>_dictRehashStep</code> 时，如果 <code>dict-&gt;iterators != 0</code> 则不会执行 rehash。</li></ul><h2 id="间断迭代器"><a href="#间断迭代器" class="headerlink" title="间断迭代器"></a>间断迭代器</h2><p>为了避免扫描所有的 keys 而造成长时间的阻塞（事实上，我们的生产环境是禁用 <code>keys</code> 命令的），Redis 在 2.8 之后加入了 <code>scan</code> 操作，从而能够间断地迭代整个字典。<code>zscan</code> 和 <code>hscan</code> 底层都会执行间断迭代操作，它的具体实现参见 <a href="https://github.com/iFaceless/redis/blob/4c5a6f422b60500816e9c507bb0265495f483dda/src/dict.c#L878" target="_blank" rel="noopener">dictScan</a>，核心是围绕一个游标进行的，关于它的具体策略可以参见源码的详细描述。</p><p>这里总结下 <code>dictScan</code> 算法的主要特点：</p><ol><li><strong>迭代器本身是无状态的（和上面的两个相比）</strong>，迭代位置是基于游标计算的，而游标会返回给用户，由用户保存，并在迭代时传入；</li><li><strong>可能会迭代到重复的元素</strong>，但由于采用了 <em>reverse binary iteration</em> 算法，能够保证不漏遍历且尽可能不重复遍历；</li><li><strong>每次迭代会返回多个元素</strong>，这主要是因为避免 rehash 的影响，每次会将一个 bucket 上所有的 keys 都返回出去。</li></ol><h1 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h1><p>顾名思义，intset 是转门用于<strong>存储整数</strong>的集合。它实际上也是为了节约内存而设计的，随着元素中最大的元素的类型发生变化，它也会按需扩容。intset 还有个特点是<strong>有序且不重复</strong>（可以想到查找时就可以光明正大地利用二分算法了）。</p><p>intset 实际上是 Redis 集合类型底层使用的数据结构之一，<strong>当元素为 64 位以内有符号整数（支持 <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>），且元素个数不多</strong>（取决于 <code>set_max_intset_entries</code> 设置）时使用。当元素个数超出设定值，或者新增元素类型非整数，<strong>intset 就会被转换成 hashtable</strong>，也就是使用 dict 来存储。具体可以看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">setTypeCreate</span><span class="params">(sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value, &amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr, llval, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 元素个数超出范围，需要转换成字典存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject, OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非整数类型，转换成字典</span></span><br><span class="line">            setTypeConvert(subject, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 整数长度：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 整数个数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>简单画了个内存布局图如下，相信可以直观地表达这个数据结构的特点：<br><img src="https://pic1.zhimg.com/80/v2-c565192165aad2be79d17ae7e6517bc1.png" alt=""></p><h2 id="核心源码-3"><a href="#核心源码-3" class="headerlink" title="核心源码"></a>核心源码</h2><p>intset 的核心 API 比较少，且实现比较简单，很容易看懂，所以在这里不多赘述了，相关源码中文注释直接看 <a href="https://github.com/iFaceless/redis/blob/c4e3ab7aa976ff1bde948803a6212c1cb2764b76/src/intset.c#L97" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span></span>; <span class="comment">// O(N)</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span></span>; <span class="comment">// O(N)</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value); <span class="comment">// O(logN)</span></span><br><span class="line"><span class="keyword">int64_t</span> intsetRandom(intset *is); <span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetGet(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value); <span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">uint32_t</span> intsetLen(<span class="keyword">const</span> intset *is); <span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">size_t</span> intsetBlobLen(intset *is); <span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure><h1 id="快速链表（quicklist）"><a href="#快速链表（quicklist）" class="headerlink" title="快速链表（quicklist）"></a>快速链表（quicklist）</h1><p>快速链表（quicklist）本质上也是一个双向链表，但是它的每个节点存储的元素位于 ziplist 中，并且中间节点的 ziplist 还可以使用 LZF 算法进行压缩，进一步节省内存。总的来说，quicklist 是一个综合了双向链表和 ziplist 优点的数据结构。ziplist 最大的特点是节约内存，但不适宜存储过多的元素；而链表则便于从头部或者尾部执行插入或查找。</p><p>因此，quicklist 算是为 Redis 列表类型 <code>t_list</code> 特别定制的数据结构，兼顾了时间和空间效率。我们通常使用的 <code>LPUSH</code>, <code>LPOP</code>, <code>RPUSH</code>, <code>RPOP</code> 命令，实际上只需要操作列表两端即可，而 qucklist 恰好维护了 head 和 tail 的节点指针，方便快速定位。</p><p><img src="https://pic2.zhimg.com/80/v2-5eace6803426c11a9f2b27a83ff5d94f.png" alt=""></p><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quicklist 是对快速链表这种数据结构的抽象，其中存储了一些元信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// head, tail 指向链表的头尾</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// count 记录了所有 ziplists 的元素个数之和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count; <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="comment">// len 记录了有多少个 Nodes</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="comment">// fill 表示每个节点最多可以包含的数据项，正数表示最多可以含有的元素个数</span></span><br><span class="line">    <span class="comment">// 负数则表示每个节点 ziplist 的最大长度（字节数）：</span></span><br><span class="line">    <span class="comment">// -1, 4KB</span></span><br><span class="line">    <span class="comment">// -2, 8KB</span></span><br><span class="line">    <span class="comment">// -3, 16KB</span></span><br><span class="line">    <span class="comment">// -4, 32KB</span></span><br><span class="line">    <span class="comment">// -5, 64KB</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>; <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="comment">// compress 表示两端不被压缩的节点个数。一般对于 list 的操作通常是在两端进行的</span></span><br><span class="line">    <span class="comment">// 所以，为了方便 LPUSH/LPOP/RPUSH/RPOP 命令，这里可以选择对两端不做压缩。</span></span><br><span class="line">    <span class="comment">// 但是为了节约内存，会对中间节点进行压缩（ziplist 已经够节约内存了，但是还是要压缩</span></span><br><span class="line">    <span class="comment">// 更进一步地节约内存），代价就是消耗点 CPU 时间用于压缩或者解压缩。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistNode 实际上是对 ziplist 的描述，元素存储于 ziplist 中。</span></span><br><span class="line"><span class="comment">// 为什么需要在 quicklistNode 中位于 ziplist 的一些元信息呢？这主要是因为</span></span><br><span class="line"><span class="comment">// 节点指向的 ziplist 可以被压缩，这样就不能快速获取一些元信息了（元素个数等）。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 双向链表，自然需要前后关联</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 指向 ziplist 指针（如果是压缩节点，实际指向的是 quicklistLZF）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="comment">// ziplist 的大小（bytes）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="comment">// ziplist 中存储的元素个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>; <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="comment">// 表示 ziplist 进行了压缩编码，RAW=1 表示没有压缩；2 表示使用了 LZF 算法压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>; <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="comment">// 容器类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>; <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="comment">// 当前节点是否被压缩过？如果压缩过还需要在使用前进行解压</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="comment">// 当前节点太小了，无法压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistLZF 表示 ziplist 压缩后的数据结构，它是一个 4+N 字节大小的结构体。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="comment">// sz 表示 LZF 压缩后的数据大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="comment">// compressed 存储压缩后的数据</span></span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistEntry 是对 quicklistNode 下 ziplist 某个元素的抽象，</span></span><br><span class="line"><span class="comment">// 方便我们获取元素的内容。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// quicklist 指向 quicklist 的指针</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist;</span><br><span class="line">    <span class="comment">// quicklistNode 当前 entry 关联的节点</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="comment">// zi 关联的 ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;</span><br><span class="line">    <span class="comment">// value 指向 string 类型的元素位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value;</span><br><span class="line">    <span class="comment">// longvalue 元素转换为整数的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval;</span><br><span class="line">    <span class="comment">// sz 表示 value 的有效长度（string 类型编码时，encoding 中的长度部分就是这个）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="comment">// offset 表示在当前 ziplist 中的偏移量</span></span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure><p>通过下图可以对 quicklist 有个直观的感受，便于理解这种数据结构：<br><img src="https://pic1.zhimg.com/80/v2-1f634fd2892ebc00aef8aeb8f03ceb09.png" alt=""></p><h2 id="核心源码-4"><a href="#核心源码-4" class="headerlink" title="核心源码"></a>核心源码</h2><p>quicklist 的源码比较多，就不再本文中赘述了，详细的源码注释可以在 <a href="https://github.com/iFaceless/redis/blob/152cb8a4be4ce107a34135314020ec69bca93216/src/quicklist.c#L94" target="_blank" rel="noopener">此处</a> 查看。值得重点关注的几个函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 为 quicklist 节点个数，m 表示内部 ziplist 的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="keyword">int</span> where)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *node, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *node, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistIndex</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> index, quicklistEntry *entry)</span></span>; <span class="comment">// O(n+m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data, <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span></span>;  <span class="comment">// O(m)</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里就不多废话了，对于基本的数据结构做了点总结，放在下面的思维导图中。其中 APIs 分支并非每个数据结构全部的接口，而是一些比较有趣，值得阅读源码的接口，有兴趣地话可以欣赏下它们的内部实现。如果有任何问题，欢迎留言指正~</p><p><img src="https://pic2.zhimg.com/80/v2-82b204f0b41afb79e21e84d76a4806ef.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">Redis 为什么用跳表而不用平衡树？</a></li><li><a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">《Redis 5 设计与源码分析》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1d46ebdc21d0364fefecf710d01f473d.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Redis 底层的基础数据结构包括：动态字符串（sds）、跳表（skiplist）、压缩列表（ziplist）、字典（dict）、整数集合（intset），快速链表（quicklist）等，&lt;code&gt;t_hash&lt;/code&gt;，&lt;code&gt;t_set&lt;/code&gt;, &lt;code&gt;t_zset&lt;/code&gt;, &lt;code&gt;t_list&lt;/code&gt; 等对外类型的内部实现都依赖于这些数据结构，所以非常值得学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ifaceless.space/categories/Redis/"/>
    
    
      <category term="源码学习" scheme="http://ifaceless.space/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Redis" scheme="http://ifaceless.space/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实现 Redis 跳表</title>
    <link href="http://ifaceless.space/2019/12/11/implement-redis-skiplist-in-go/"/>
    <id>http://ifaceless.space/2019/12/11/implement-redis-skiplist-in-go/</id>
    <published>2019-12-11T12:58:39.000Z</published>
    <updated>2019-12-15T06:08:45.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://pic1.zhimg.com/80/v2-102788cac4f586778ffbf6767eb99d4f.png" alt=""><br>读过 Redis 源码的童鞋，想必会知道 zset 实现时，使用了「跳表」（Skiplist）这种数据结构吧。它的原理非常容易理解，如果对链表比较熟悉，那么也会很容易理解「跳表」的工作原理（核心：<strong>有序链表</strong> + <strong>分层</strong>）。当然，本文并不会详细讲解「跳表」的工作原理，以及对于 Redis 跳表源码的详细分析。因为已经有前辈们产出了非常丰富的文章来讲解 Redis 跳表，需要的话，推荐阅读 <a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">这篇文章</a> 了解更多细节。</p><a id="more"></a><p>总的来说，Redis 的 zset 实现中，选用「跳表」的主要原因如下：</p><ol><li><strong>原理清晰易懂，且容易实现，方便维护</strong>：对比下平衡树或者红黑树（可能就像 Raft v.s. Paxos 的感觉一样），不管是原理还是实现都简单了很多。平衡树或者红黑树在实现时，还要时刻维护节点关系，必要时还需要执行树的左旋或者右旋来保持平衡；</li><li><strong>拥有媲美平衡树或者红黑树的查询效率</strong>：插入、删除、查找的平均时间复杂度可以达到 O(logN)。</li></ol><p>当然，相对于 William Pugh 在他的论文中所描述的「跳表」算法而言，作者在实现 Redis 中的「跳表」时，给它加了点「料」：</p><ol><li>允许重复的分数存在；</li><li>在进行比较时，不仅会比较 score，还会考虑关联的数据；</li><li>添加了一个回退指针，从而构成了一个双向链表（level[0]），便于倒序遍历链表（<code>ZREVRANGE</code>）使用。</li></ol><p>好了，废话完毕。接下来进入正题，看看如何使用 Go 语言来实现「跳表」吧（贴代码模式开启~）。</p><h1 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h1><p>以下仅仅列出了几个比较有趣且关键的方法实现，即：插入、删除和更新分数。完整的实现源码可以参考 <a href="https://gitee.com/ifaceless/goskiplist/tree/master" target="_blank" rel="noopener">这里</a> 或者 <a href="https://github.com/iFaceless/always-coding/tree/master/datastructure/skiplist" target="_blank" rel="noopener">这里</a>，包含了比较详细的单元测试。</p><h2 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h2><p>需要说明的是，为了简单起见，假设存储的元素是字符串类型（要是使用 <code>interface{}</code> 的话，又得加些代码支持元素之间的比较了）。但是在 Redis 中，实际的 <code>element</code>  类型是 <code>sds</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MaxLevel = <span class="number">64</span> <span class="comment">// 足以容纳 2^64 个元素</span></span><br><span class="line">    P = <span class="number">0.25</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    elem <span class="keyword">string</span></span><br><span class="line">    score <span class="keyword">float64</span></span><br><span class="line">    backward *Node</span><br><span class="line">    level []skipLevel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> skipLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// forward 每层都要有指向下一个节点的指针</span></span><br><span class="line">    forward *Node</span><br><span class="line">    <span class="comment">// span 间隔定义为：从当前节点到 forward 指向的下个节点之间间隔的节点数</span></span><br><span class="line">    span <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;</span><br><span class="line">    header, tail *Node</span><br><span class="line">    level <span class="keyword">int</span> <span class="comment">// 记录跳表的实际高度</span></span><br><span class="line">    length <span class="keyword">int</span> <span class="comment">// 记录跳表的长度（不含头节点）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h2><p>考虑到在实现时，经常需要比较 score 和 element，所以这里直接给 <code>Node</code> 实现了一些比较方法，便于使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">Compare</span><span class="params">(other *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node.score &lt; other.score || (node.score == other.score &amp;&amp; node.elem &lt; other.elem) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node.score &gt; other.score || (node.score == other.score &amp;&amp; node.elem &gt; other.elem) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">Lt</span><span class="params">(other *Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node.Compare(other) &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">Lte</span><span class="params">(other *Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node.Compare(other) &lt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">Gt</span><span class="params">(other *Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node.Compare(other) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">Eq</span><span class="params">(other *Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node.Compare(other) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert 向跳表中插入一个新的元素。</span></span><br><span class="line"><span class="comment">// 步骤：</span></span><br><span class="line"><span class="comment">// 1. 查找插入位置</span></span><br><span class="line"><span class="comment">// 2. 创建新节点，并在目标位置插入节点</span></span><br><span class="line"><span class="comment">// 3. 调整跳表 backward 指针等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *Skiplist)</span> <span class="title">Insert</span><span class="params">(score <span class="keyword">float64</span>, elem <span class="keyword">string</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        <span class="comment">// update 用于记录每层待更新的节点</span></span><br><span class="line">        update [MaxLevel]*Node</span><br><span class="line">        <span class="comment">// rank 用来记录每层经过的节点记录（可以看成到头节点的距离）</span></span><br><span class="line">        rank [MaxLevel]<span class="keyword">int</span></span><br><span class="line">        <span class="comment">// 构建一个新节点，用于下面的大小判断，其 level 在后面设置</span></span><br><span class="line">        node = &amp;Node&#123;score: score, elem: elem&#125;</span><br><span class="line">    )</span><br><span class="line">    cur := sl.header</span><br><span class="line">    <span class="keyword">for</span> i := sl.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == sl.header &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rank[i] = rank[i+<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与同层的后一个节点比较，如果后一个比目标值小，则可以继续向后</span></span><br><span class="line">        <span class="comment">// 否则下降到一层查找。注意这里的大小比较是按照 score 和</span></span><br><span class="line">        <span class="comment">// elem 综合计算得到的。</span></span><br><span class="line">        <span class="keyword">for</span> cur.level[i].forward != <span class="literal">nil</span> &amp;&amp; cur.level[i].forward.Lt(node) &#123;</span><br><span class="line">            rank[i] += cur.level[i].span</span><br><span class="line">            <span class="comment">// 同层继续往后查找</span></span><br><span class="line">            cur = cur.level[i].forward</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整跳表高度</span></span><br><span class="line">    level := sl.randomLevel()</span><br><span class="line">    <span class="keyword">if</span> level &gt; sl.level &#123;</span><br><span class="line">        <span class="comment">// 初始化每层</span></span><br><span class="line">        <span class="keyword">for</span> i := level - <span class="number">1</span>; i &gt;= sl.level; i-- &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span></span><br><span class="line">            update[i] = sl.header</span><br><span class="line">            update[i].level[i].span = sl.length</span><br><span class="line">        &#125;</span><br><span class="line">        sl.level = level</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新节点 level，并插入新节点</span></span><br><span class="line">    node.setLevel(level)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; level; i++ &#123;</span><br><span class="line">        <span class="comment">// 更新每层的节点指向</span></span><br><span class="line">        node.level[i].forward = update[i].level[i].forward</span><br><span class="line">        update[i].level[i].forward = node</span><br><span class="line">        <span class="comment">// 更新 span 信息</span></span><br><span class="line">        node.level[i].span = update[i].level[i].span - (rank[<span class="number">0</span>] - rank[i])</span><br><span class="line">        update[i].level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对新增节点 level &lt; sl.level 的情况，需要更新上面没有扫到的层 span</span></span><br><span class="line">    <span class="keyword">for</span> i := level; i &lt; sl.level; i++ &#123;</span><br><span class="line">        update[i].level[i].span++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整 backward 指针</span></span><br><span class="line">    <span class="comment">// 如果前一个节点是头节点，则 backward 为 nil</span></span><br><span class="line">    <span class="comment">// 否则 backward 指向之前节点</span></span><br><span class="line">    <span class="keyword">if</span> update[<span class="number">0</span>] != sl.header &#123;</span><br><span class="line">        <span class="comment">// update[0] 就是和新增节点相邻的前一个节点</span></span><br><span class="line">        node.backward = update[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新增节点是最后一个，则需要更新 tail 指针</span></span><br><span class="line">    <span class="keyword">if</span> node.level[<span class="number">0</span>].forward == <span class="literal">nil</span> &#123;</span><br><span class="line">        sl.tail = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 中间节点，需要更新后一个节点的回退指针</span></span><br><span class="line">        node.level[<span class="number">0</span>].forward.backward = node</span><br><span class="line">    &#125;</span><br><span class="line">    sl.length++</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// randomLevel 对于新增节点，返回一个随机的 level</span></span><br><span class="line"><span class="comment">// 返回的 level 范围为 [1, MaxLevel]。并且，采用的</span></span><br><span class="line"><span class="comment">// 算法会保证，更大的 level 返回的概率越低。</span></span><br><span class="line"><span class="comment">// 每个 level 出现的概率计算：(1-p) * p^(level-1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *Skiplist)</span> <span class="title">randomLevel</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    level := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> rand.Float64() &lt; P &amp;&amp; level &lt; MaxLevel &#123;</span><br><span class="line">        level++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete 用于删除跳表中指定的节点。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *Skiplist)</span> <span class="title">Delete</span><span class="params">(score <span class="keyword">float64</span>, elem <span class="keyword">string</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一步，找到需要删除节点</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        update [MaxLevel]*Node</span><br><span class="line">        targetNode = &amp;Node&#123;elem: elem, score: score&#125;</span><br><span class="line">    )</span><br><span class="line">    cur := sl.header</span><br><span class="line">    <span class="keyword">for</span> i := sl.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> cur.level[i].forward != <span class="literal">nil</span> &amp;&amp; cur.level[i].forward.Lt(targetNode) &#123;</span><br><span class="line">            cur = cur.level[i].forward</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标节点找到后，这里需要判断下 elem 是否相等</span></span><br><span class="line">    <span class="comment">// score 可以重复，所以必须要谨慎</span></span><br><span class="line">    nodeToBeDeleted := update[<span class="number">0</span>].level[<span class="number">0</span>].forward</span><br><span class="line">    <span class="keyword">if</span> nodeToBeDeleted == <span class="literal">nil</span> || !nodeToBeDeleted.Eq(targetNode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    sl.deleteNode(update, nodeToBeDeleted)</span><br><span class="line">    <span class="keyword">return</span> nodeToBeDeleted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *Skiplist)</span> <span class="title">deleteNode</span><span class="params">(update [64]*Node, nodeToBeDeleted *Node)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这时我们要删除的节点就是 nodeToBeDeleted</span></span><br><span class="line">    <span class="comment">// 调整每层待更新节点，修改 forward 指向</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sl.level; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> update[i].level[i].forward == nodeToBeDeleted &#123;</span><br><span class="line">            update[i].level[i].forward = nodeToBeDeleted.level[i].forward</span><br><span class="line">            update[i].level[i].span += nodeToBeDeleted.level[i].span - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i].level[i].span--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整回退指针：</span></span><br><span class="line">    <span class="comment">// 1. 如果被删除的节点是最后一个节点，需要更新 sl.tail</span></span><br><span class="line">    <span class="comment">// 2. 如果被删除的节点位于中间，则直接更新后一个节点 backward 即可</span></span><br><span class="line">    <span class="keyword">if</span> sl.tail == nodeToBeDeleted &#123;</span><br><span class="line">        sl.tail = nodeToBeDeleted.backward</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nodeToBeDeleted.level[<span class="number">0</span>].forward.backward = nodeToBeDeleted.backward</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整层数</span></span><br><span class="line">    <span class="keyword">for</span> sl.header.level[sl.level<span class="number">-1</span>].forward == <span class="literal">nil</span> &#123;</span><br><span class="line">        sl.level--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少节点计数</span></span><br><span class="line">    sl.length--</span><br><span class="line">    nodeToBeDeleted.backward = <span class="literal">nil</span></span><br><span class="line">    nodeToBeDeleted.level[<span class="number">0</span>].forward = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新分数"><a href="#更新分数" class="headerlink" title="更新分数"></a>更新分数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UpdateScore 用于更新节点的分数。该函数会保证更新分数后，</span></span><br><span class="line"><span class="comment">// 节点的有序性依然可以维持。</span></span><br><span class="line"><span class="comment">// 策略如下：</span></span><br><span class="line"><span class="comment">// 1. 快速判断能否原节点修改，如果可以则直接修改并返回；</span></span><br><span class="line"><span class="comment">// 2. 采用更加昂贵的操作：删除再添加。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *Skiplist)</span> <span class="title">UpdateScore</span><span class="params">(curScore <span class="keyword">float64</span>, elem <span class="keyword">string</span>, newScore <span class="keyword">float64</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        update [MaxLevel]*Node</span><br><span class="line">        targetNode = &amp;Node&#123;elem: elem, score: curScore&#125;</span><br><span class="line">    )</span><br><span class="line">    cur := sl.header</span><br><span class="line">    <span class="comment">// 第一步，找到符合条件的目标节点</span></span><br><span class="line">    <span class="keyword">for</span> i := sl.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> cur.level[i].forward != <span class="literal">nil</span> &amp;&amp; cur.level[i].forward.Lt(targetNode) &#123;</span><br><span class="line">            cur = cur.level[i].forward</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    node := cur.level[<span class="number">0</span>].forward</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> || !node.Eq(targetNode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sl.canUpdateScoreFor(node, newScore) &#123;</span><br><span class="line">        node.score = newScore</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要删除旧节点，增加新节点</span></span><br><span class="line">        sl.deleteNode(update, node)</span><br><span class="line">        <span class="keyword">return</span> sl.Insert(newScore, node.elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// canUpdateScoreFor 确定能否直接在原有的节点上进行修改</span></span><br><span class="line"><span class="comment">// 什么条件才可以直接原地更新 score 呢？</span></span><br><span class="line"><span class="comment">// 1. node 是唯一一个数据节点（node.backward == NULL &amp;&amp; node-&gt;level[0].forward == NULL）</span></span><br><span class="line"><span class="comment">// 2. node 是第一个数据节点，且新的分数要比 node 之后节点分数要小（这样才能保证有序）</span></span><br><span class="line"><span class="comment">// 即：node.backward == NULL &amp;&amp; node-&gt;level[0].forward-&gt;score &gt; newScore）</span></span><br><span class="line"><span class="comment">// 3. node 是最后一个数据节点，且 node 之前节点的分数要比新改的分数小</span></span><br><span class="line"><span class="comment">// 即：node-&gt;backward-&gt;score &lt; newScore &amp;&amp; node-&gt;level[0].forward == NULL</span></span><br><span class="line"><span class="comment">// 4. node 是修改的后的分数恰好还能保证位于前一个和后一个节点分数之间</span></span><br><span class="line"><span class="comment">// 即：node-&gt;backward-&gt;score &lt; newscore &amp;&amp; node-&gt;level[0].forward-&gt;score &gt; newscore</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *Skiplist)</span> <span class="title">canUpdateScoreFor</span><span class="params">(node *Node, newScore <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.backward == <span class="literal">nil</span> || node.backward.score &lt; newScore) &amp;&amp;</span><br><span class="line">        (node.level[<span class="number">0</span>].forward == <span class="literal">nil</span> || node.level[<span class="number">0</span>].forward.score &gt; newScore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>俗话说，「说起来容易，做起来难」。在实现「跳表」的时候感受颇深，似乎看完 Redis 的「跳表」源码和网上诸多前辈编写的文章后，自以为懂得了原理（可能确实懂了），但是在具体实现的时候还是踩了不少坑。比如，空指针引起 panic；<code>i--</code> 写成了 <code>i++</code> 导致查找失败；一些边界情况的判断等。总之，细节决定成败，需要在保持思路清晰的同时，更加谨慎一些才能写出足够健壮的代码来。当然，这期间自然少不了单元测试的助攻，否则有很多问题可能都没法暴露出来~</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/53975333" target="_blank" rel="noopener">漫画：什么是跳表？</a></li><li><a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">Redis 为什么用跳表而不用平衡树？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-102788cac4f586778ffbf6767eb99d4f.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;读过 Redis 源码的童鞋，想必会知道 zset 实现时，使用了「跳表」（Skiplist）这种数据结构吧。它的原理非常容易理解，如果对链表比较熟悉，那么也会很容易理解「跳表」的工作原理（核心：&lt;strong&gt;有序链表&lt;/strong&gt; + &lt;strong&gt;分层&lt;/strong&gt;）。当然，本文并不会详细讲解「跳表」的工作原理，以及对于 Redis 跳表源码的详细分析。因为已经有前辈们产出了非常丰富的文章来讲解 Redis 跳表，需要的话，推荐阅读 &lt;a href=&quot;https://juejin.im/post/57fa935b0e3dd90057c50fbc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt; 了解更多细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ifaceless.space/categories/Redis/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="Redis" scheme="http://ifaceless.space/tags/Redis/"/>
    
      <category term="跳表" scheme="http://ifaceless.space/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis 5 源码初探</title>
    <link href="http://ifaceless.space/2019/12/08/primitive-exploration-of-redis5/"/>
    <id>http://ifaceless.space/2019/12/08/primitive-exploration-of-redis5/</id>
    <published>2019-12-08T07:01:24.000Z</published>
    <updated>2019-12-15T06:10:30.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="https://github.com/iFaceless/redis/tree/5.0" target="_blank" rel="noopener">Redis, REmote DIctionary Server</a> 因其高效、简单、丰富的数据结构支持、高性能、持久化和集群支持等特性得到了程序员们的青睐，并被广泛部署和应用在众多互联网公司。而因为它采用了比较简单的文本协议，使得客户端实现比较简单，因此也拥有众多编程语言实现的客户端；甚至也有一些其它类型的 K-V 数据库兼容了 Redis 协议！</p><p>结合我们目前的业务来看，有非常多的场景使用到了 Redis：</p><ol><li>记录用户通知、短信发送标志，避免重复发送；</li><li>使用 Redis 集合维护一些白名单用户表；</li><li>为支持快速获得用户会员时长等基本信息，将这些信息在 Redis 集群中也维护了一份，并采取相关措施维持与 MySQL 数据库的最终一致性。</li></ol><p>当然还有很多场景可以例举，但就我们常使用的 Redis 数据结构来看，主要就是<strong>字符串、集合（有序/无序）、字典、列表</strong>等。虽说 Redis 给我们提供了其它丰富的内存数据结构，但是我们在生产环境用到的并不多。</p><a id="more"></a><p>既然 Redis 这么重要，自然很有必要花时间去研究下 Redis，并阅读它的源码来学习它的一些设计思想，编程风格等。不得不说，Redis 官方文档非常给力，源码注释很充分，代码风格、质量都是非常一流的。</p><p>我们已经了解了 Redis 是什么？为什么那么重要？接下来就是怎么来学习它？然后是期望达成什么样的目标？</p><p>首先，<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a> 和 <a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">《Redis 5 设计与源码分析》</a> 将作为学习 Redis 源码的主要参考书籍（「站在巨人的肩膀上」）；其次是阅读下 Redis 官方文档中比较重要的部分；当然，最后且最重要的是自己要认真阅读源码。</p><p>最后一个问题，期望在学习完 Redis 达成的目标，我想主要有如下几点：</p><ol><li>培养阅读知名开源项目源码的耐心，掌握阅读源码的技巧和工具；</li><li>加深对 Redis 的理解，了解它的架构设计；</li><li>掌握 Redis 常用的数据结构设计思想，并能在实际项目中合理运用各种数据结构实现需求；</li><li>吸收精髓，提升自身的技术水平，业余时间还可以尝试折腾个简单的数据库。</li></ol><h1 id="Redis-特点"><a href="#Redis-特点" class="headerlink" title="Redis 特点"></a>Redis 特点</h1><p>第一个值得称道的特点就是<strong>高性能</strong>，Redis 的高性能得益于如下几点原因：</p><ol><li>它是基于内存的数据库，内存的读写速度很快；</li><li>拥有合理设计的内存数据结构，增删改查很简单，并且能够高效利用内存；</li><li>使用了 I/O 多路复用的机制（select, poll, epoll, kqueue），高效处理高并发的网络连接；</li><li>采用了单进程模型（Redis Server 会有多个线程），且只有一个线程专门处理网络请求，避免线程调度带来的上下文切换开销、多线程同步开销（如加锁、释放锁等）。</li></ol><p>除此之外，还有如下特点：</p><ol><li><code>&lt;key, value&gt;</code> 中的 value 除了普通的字符串，还支持复杂的数据类型（如集合、字典、位图等）；</li><li>支持数据持久化，可在重启后恢复，支持 AOF、RDB 和 AOF + RDB 三种持久化方案；</li><li>支持主从结构，从节点可做数据备份，也可对外提供读服务；</li><li>支持集群。</li></ol><h1 id="源码概览"><a href="#源码概览" class="headerlink" title="源码概览"></a>源码概览</h1><p><em>后面的源码学习会基于 Redis 最新的稳定版 5.0.7，参见仓库：<a href="https://github.com/iFaceless/redis/tree/5.0" target="_blank" rel="noopener">https://github.com/iFaceless/redis/tree/5.0</a>，源码注释会推送到该仓库的 <code>comment-src</code> 分支下。</em></p><p>关于 Redis 源码的结构，在 Redis 的 <a href="https://github.com/antirez/redis/tree/5.0#source-code-layout" target="_blank" rel="noopener">README.md</a> 中有所介绍。具体来说，有如下几个重要的目录：</p><ul><li><code>src</code>: Redis 核心实现（C 语言）</li><li><code>tests</code>: 单元测试代码（Tcl 语言）</li><li><code>deps</code>: Redis 依赖的一些库。其中包含 <code>jemalloc</code> 源码，它是 Redis 在 Linux 下默认的内存分配库，用来替代标准库 <code>malloc</code>，以期减少内存分配碎片</li></ul><h2 id="server-h"><a href="#server-h" class="headerlink" title="server.h"></a>server.h</h2><p><code>server.h</code> 中定义了 Redis Server 需要用到的一些数据结构，其中 <code>struct redisServer</code> 维护了 Redis 服务端配置和共享状态，几个比较重要的字段如下：</p><ul><li><code>db</code>: 表示 Redis 数据库，用来存储数据</li><li><code>commands</code>: 命令表</li><li><code>clients</code>: 连接到当前服务器的客户端链表</li><li><code>master</code>: replica 节点 master 客户端</li></ul><p>另外一个重要的数据结构是 <code>redisClient</code>，用来表示客户端。这里给介绍几个重要的字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 存放客户端请求</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    robj **argv;</span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">// reply &amp; buf 维护服务端要发给客户端的回复队列，当底层的 fd 可写时，会以渐进地方式发送缓冲区数据</span></span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">    ... many other fields ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个比较重要的数据结构是 <code>robj</code>，它表示一个 Redis 对象，在 Redis 内部实现中有很多地方在使用，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redisObject 基本上可以表示所有常用的 Redis 数据类型（lists, sets, strings 等）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// type 表示具体的数据类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">// refcount 表示对象引用次数，借助引用计数的方式，避免为重复对象分配内存</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">   <span class="comment">// ptr 指向底层的真正的对象表示，结合 `encoding` 进行解析</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><p>Redis Server 启动的入口定义在此处（参见 <code>main</code> 函数）。下面是 Redis Server 启动时需要进行的重要步骤：</p><ul><li><code>initServerConfig()</code> 用来配置 <code>struct server</code> 的默认值</li><li><code>initServer()</code> 分配一些必要的数据结构、配置监听的 socket 等</li><li><code>aeMain()</code> 启动 Event Loop，监听新的连接</li></ul><p>Event Loop 中会周期调用的两个特殊函数如下：</p><ul><li><code>serverCron()</code> 会被周期调用（参考 <code>server.hz</code> 配置的频率），执行一些周期性的任务，如检查客户端超时等</li><li><code>beforeSleep()</code> 会在每次进入事件驱动库主循环时调用，也就是在睡眠等待 ready 的文件描述符之前</li></ul><p>在 <code>server.c</code> 中还有几个函数专门处理其它类型的重要任务：</p><ul><li><code>call()</code> 会在指定的客户端上下文中执行指定命令时被使用</li><li><code>activeExpireCycle()</code> 用来处理过期的 keys</li><li><code>freeMemoryIfNeeded()</code> 当 Redis 内存使用超过 <code>maxmemory</code> 指定的值，且有新的写入进来时，会执行该函数清理内存</li><li><code>redisCommandTable</code> 维护了所有 Redis 命令，其中包含每个命令的名称、回调函数、参数个数及其它属性</li></ul><h2 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h2><p>在这个文件中定义了所有的 I/O 函数，用来和客户端、master 及 replicas 交互：</p><ul><li><code>createClient()</code> 初始化新的客户端</li><li><code>addReply*()</code> 函数族用于给客户端添加响应数据</li><li><code>writeToClient()</code> 用于将输出缓冲区的数据发送给客户端，它会被 <code>sendReplyToClient()</code> 调用</li><li><code>readQueryFromClient()</code> 用于聚集从客户端读取的数据到查询缓冲区</li><li><code>processInputBuffer()</code> 是从客户端查询缓冲区（query buffer）根据 Redis 协议解析查询命令的入口函数。一旦命令可以处理了，就会调用 <code>processCommand()</code> 来真正执行命令</li><li><code>freeClient()</code> 释放客户端</li></ul><h2 id="aof-c-和-rdb-c"><a href="#aof-c-和-rdb-c" class="headerlink" title="aof.c 和 rdb.c"></a>aof.c 和 rdb.c</h2><p>顾名思义，这是 Redis 两种持久化方案的具体实现文件。Redis 的持久化模型比较有趣，它会通过 <code>fork()</code> 系统调用创建一个单独的线程，并能访问主线程共享的内存区域；接下来这个备份线程会将内存内容持久化到磁盘中。<code>rdb.c</code> 在创建快照时会使用这种机制；<code>aof.c</code> 在执行 AOF 重写（避免 Append Only 文件过大）时也会用到这个机制。</p><h2 id="db-c"><a href="#db-c" class="headerlink" title="db.c"></a>db.c</h2><p><code>db.c</code> 中定义了一些通用的操作命令，它们都是针对 key 进行的操作，而非对应的数据，比如 <code>DEL</code> 和 <code>EXPIRE</code> 等。此外，<code>db.c</code> 中还提供了一些特殊的 API 用于在 Redis 数据集上执行某些操作时，不用访问内部具体的数据结构。</p><p>以下是许多命令实现中都会用到的函数：</p><ul><li><code>lookupKeyRead()</code> 和 <code>lookupKeyWrite()</code> 用于基于指定 key 得到对应值的指针，如果 key 不存在，则返回 <code>NULL</code></li><li><code>dbAdd()</code> 及更抽象的函数 <code>setKey()</code> 是用来在 Redis 中创建新的 key</li><li><code>dbDelete()</code> 移除 key 及关联的 value</li><li><code>emptyDb()</code> 移除指定的数据库或者所有的数据库</li></ul><h2 id="object-c"><a href="#object-c" class="headerlink" title="object.c"></a>object.c</h2><p><code>struct robj</code> 是 Redis 对象的定义，在 <code>object.c</code> 中有很多应用于 Redis 对象的操作，其中比较关键的函数如下：</p><ul><li><code>incrRefcount()</code> 和 <code>decrRefCount()</code> 维护对象的引用计数。当引用值为 0 时才会真正释放对象</li><li><code>createObject()</code> 用于分配新的对象。此外，还有一些针对特殊内容分配字符串对象的函数，如 <code>createStringObjectFromLongLong()</code> 等</li></ul><h2 id="replication-c"><a href="#replication-c" class="headerlink" title="replication.c"></a>replication.c</h2><p><code>replication.c</code> 文件中实现了 master 和 replica 角色。但这块内容比较复杂，建议对 Redis 其它部分代码有所了解后再来学习它。</p><p>该文件中有个比较重要的函数 <code>replicationFeedSlaves()</code>，它用来将命令发送给从节点，从而保证和主节点数据同步。在该文件中还实现了 <code>SYNC</code> 和 <code>PSYNC</code> 命令，它们用于从节点初次初始化同步，或者在连接断开并重连后继续保持同步。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><code>t_hash.c</code>, <code>t_list.c</code>, <code>t_set.c</code>, <code>t_string.c</code> 和 <code>t_zset.c</code>  是 Redis 数据类型的底层实现</li><li><code>ae.c</code> Redis 事件循环实现</li><li><code>sds.c</code> Redis 动态变长字符串</li><li><code>anet.c</code> 对内核提供的网络接口做了封装，从而能够以更加简单的方式使用 POSIX 网络接口</li><li><code>dict.c</code> 非阻塞、渐进 rehash 字典实现</li><li><code>scripting.c</code> 实现了 Luc 脚本</li><li><code>cluster.c</code> Redis 集群实现。在了解这块代码前，记得参考下 <a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis 集群说明</a></li></ul><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://pic1.zhimg.com/80/v2-f63c98a65e85898b828f3446f260a060.png" alt=""></p><h1 id="构建-amp-调试"><a href="#构建-amp-调试" class="headerlink" title="构建 &amp; 调试"></a>构建 &amp; 调试</h1><p>Redis 官方文档中有关于构建和运行它的详细说明，我们也可以使用 gdb 进行调试。但是，作为一个 IDE 死忠党，自然是要在 <a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">Clion</a> 中构建和调试 Redis 的。需要注意的是，Clion 使用了 cmake 来管理项目，所以我们需要在 Redis 源码根目录下为它创建好 CMakeLists.txt 才能进行构建。具体可参考 <a href="https://lijinglin.dev/post/2019/debug-redis-with-clion/" target="_blank" rel="noopener">使用 Clion 来调试 Redis 源码</a> 这篇文章~</p><p>在完成上一步后，切到 <code>src</code> 目录下，执行 <code>./mkreleasehdr.sh</code> 脚本生成 <code>src/release.h</code> 文件，否则构建可能会失败。然后在源码目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure><p>接下来，我们可以在 Clion 打开 <code>src/server.c</code> ，并找到 <code>main</code> 函数，点击工具栏中的运行或调试按钮，或者点击 <code>main</code> 函数左侧的按钮选择运行或调试。</p><p><img src="https://pic1.zhimg.com/v2-823df912ab47cf9dbe7ccc53a0eae03f.jpg" alt=""></p><p>Redis 服务启动时，默认会使用 6379 端口，也可以在 Clion 中配置参数，使用自定义的端口等：<br><img src="https://pic2.zhimg.com/v2-66bb67315fc0d86701b95ae306679eeb.jpg" alt=""></p><p>至此，我们已经可以使用 Clion 来阅读、运行或者调试 Redis 代码啦。有了神器助攻，便于我们通过调试工具追踪调用链，并了解执行步骤中各个中间状态。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/antirez/redis/tree/5.0" target="_blank" rel="noopener">Redis README</a></li><li><a href="https://sunznx.com/redis/redis-source-debug-with-clion.html" target="_blank" rel="noopener">Clion 调试 Redis 源码</a></li><li><a href="https://lijinglin.dev/post/2019/debug-redis-with-clion/" target="_blank" rel="noopener">使用 Clion 来调试 Redis 源码</a></li><li><a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">《Redis 5 设计与源码分析》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/iFaceless/redis/tree/5.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis, REmote DIctionary Server&lt;/a&gt; 因其高效、简单、丰富的数据结构支持、高性能、持久化和集群支持等特性得到了程序员们的青睐，并被广泛部署和应用在众多互联网公司。而因为它采用了比较简单的文本协议，使得客户端实现比较简单，因此也拥有众多编程语言实现的客户端；甚至也有一些其它类型的 K-V 数据库兼容了 Redis 协议！&lt;/p&gt;
&lt;p&gt;结合我们目前的业务来看，有非常多的场景使用到了 Redis：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录用户通知、短信发送标志，避免重复发送；&lt;/li&gt;
&lt;li&gt;使用 Redis 集合维护一些白名单用户表；&lt;/li&gt;
&lt;li&gt;为支持快速获得用户会员时长等基本信息，将这些信息在 Redis 集群中也维护了一份，并采取相关措施维持与 MySQL 数据库的最终一致性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然还有很多场景可以例举，但就我们常使用的 Redis 数据结构来看，主要就是&lt;strong&gt;字符串、集合（有序/无序）、字典、列表&lt;/strong&gt;等。虽说 Redis 给我们提供了其它丰富的内存数据结构，但是我们在生产环境用到的并不多。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://ifaceless.space/categories/Redis/"/>
    
    
      <category term="源码学习" scheme="http://ifaceless.space/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Redis" scheme="http://ifaceless.space/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>gcache 源码学习</title>
    <link href="http://ifaceless.space/2019/12/03/gcache-code-analysis/"/>
    <id>http://ifaceless.space/2019/12/03/gcache-code-analysis/</id>
    <published>2019-12-03T12:36:43.000Z</published>
    <updated>2019-12-08T07:11:32.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="https://github.com/iFaceless/redis/tree/5.0" target="_blank" rel="noopener">Redis, REmote DIctionary Server</a> 因其高效、简单、丰富的数据结构支持、高性能、持久化和集群支持等特性得到了程序员们的青睐，并被广泛部署和应用在众多互联网公司。而因为它采用了比较简单的文本协议，使得客户端实现比较简单，因此也拥有众多编程语言实现的客户端；甚至也有一些其它类型的 K-V 数据库兼容了 Redis 协议！</p><p>结合我们目前的业务来看，有非常多的场景使用到了 Redis：</p><ol><li>记录用户通知、短信发送标志，避免重复发送；</li><li>使用 Redis 集合维护一些白名单用户表；</li><li>为支持快速获得用户会员时长等基本信息，将这些信息在 Redis 集群中也维护了一份，并采取相关措施维持与 MySQL 数据库的最终一致性。</li></ol><p>当然还有很多场景可以例举，但就我们常使用的 Redis 数据结构来看，主要就是 <code>string</code>, <code>set</code>, <code>zset</code>, <code>list</code>, <code>hash map</code>。虽说 Redis 给我们提供了其它丰富的内存数据结构，但是我们在生产环境用到的并不多。</p><a id="more"></a><p>既然 Redis 这么重要，自然很有必要花时间去研究下 Redis，并阅读它的源码来学习它的一些设计思想，编程风格等。不得不说，Redis 官方文档非常给力，源码注释很充分，代码风格、质量都是非常一流的。</p><p>我们已经了解了 Redis 是什么？为什么那么重要？接下来就是怎么来学习它？然后是期望达成什么样的目标？</p><p>首先，<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a> 和 <a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">《Redis 5 设计与源码分析》</a> 将作为学习 Redis 源码的主要参考书籍（「站在巨人的肩膀上」）；其次是阅读下 Redis 官方文档中比较重要的部分；当然，最后且最重要的是自己要认真阅读源码。</p><p>最后一个问题，期望在学习完 Redis 达成的目标，我想主要有如下几点：</p><ol><li>培养阅读知名开源项目源码的耐心，掌握阅读源码的技巧和工具；</li><li>加深对 Redis 的理解，了解它的架构设计；</li><li>掌握 Redis 常用的数据结构设计思想，并能在实际项目中合理运用各种数据结构实现需求；</li><li>吸收精髓，提升自身的技术水平，业余时间还可以尝试折腾个简单的数据库。</li></ol><h1 id="Redis-特点"><a href="#Redis-特点" class="headerlink" title="Redis 特点"></a>Redis 特点</h1><p>Redis 之所以能够有很高的性能，主要有如下几点原因：</p><ol><li>它是基于内存的数据库，内存的读写速度很快；</li><li>拥有合理设计的内存数据结构，增删改查很简单，并且能够高效利用内存；</li><li>使用了 I/O 多路复用的机制（select, poll, epoll, kqueue），高效处理高并发的网络连接；</li><li>采用了单进程模型（Redis Server 会有多个线程），且只有一个线程专门处理网络请求，避免线程调度带来的上下文切换开销、多线程同步开销（如加锁、释放锁等）。</li></ol><p>除此之外，还有如下特点：</p><ol><li><code>&lt;key, value&gt;</code> 中的 value 除了普通的字符串，还支持复杂的数据类型（如集合、字典、位图等）；</li><li>支持数据持久化，可在重启后恢复，支持 AOF、RDB 和 AOF + RDB 三种持久化方案；</li><li>支持主从结构，从节点可做数据备份，也可对外提供读服务；</li><li>支持集群。</li></ol><h1 id="源码概览"><a href="#源码概览" class="headerlink" title="源码概览"></a>源码概览</h1><p><em>后面的源码学习会基于 Redis 最新的稳定版 5.0.7，参见仓库：<a href="https://github.com/iFaceless/redis/tree/5.0" target="_blank" rel="noopener">https://github.com/iFaceless/redis/tree/5.0</a>，源码注释会推送到该仓库的 <code>comment-src</code> 分支下。</em></p><p>关于 Redis 源码的结构，在 Redis 的 <a href="https://github.com/antirez/redis/tree/5.0#source-code-layout" target="_blank" rel="noopener">README.md</a> 中有所介绍。具体来说，有如下几个重要的目录：</p><ul><li><code>src</code>: Redis 核心实现（C 语言）</li><li><code>tests</code>: 单元测试代码（Tcl 语言）</li><li><code>deps</code>: Redis 依赖的一些库。其中包含 <code>jemalloc</code> 源码，它是 Redis 在 Linux 下默认的内存分配库，用来替代标准库 <code>malloc</code>，以期减少内存分配碎片</li></ul><h2 id="server-h"><a href="#server-h" class="headerlink" title="server.h"></a>server.h</h2><p><code>server.h</code> 中定义了 Redis Server 需要用到的一些数据结构，其中 <code>struct redisServer</code> 维护了 Redis 服务端配置和共享状态，几个比较重要的字段如下：</p><ul><li><code>db</code>: 表示 Redis 数据库，用来存储数据</li><li><code>commands</code>: 命令表</li><li><code>clients</code>: 连接到当前服务器的客户端链表</li><li><code>master</code>: replica 节点 master 客户端</li></ul><p>另外一个重要的数据结构是 <code>redisClient</code>，用来表示客户端。这里给介绍几个重要的字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 存放客户端请求</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    robj **argv;</span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">// reply &amp; buf 维护服务端要发给客户端的回复队列，当底层的 fd 可写时，会以渐进地方式发送缓冲区数据</span></span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">    ... many other fields ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个比较重要的数据结构是 <code>robj</code>，它表示一个 Redis 对象，在 Redis 内部实现中有很多地方在使用，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redisObject 基本上可以表示所有常用的 Redis 数据类型（lists, sets, strings 等）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// type 表示具体的数据类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">// refcount 表示对象引用次数，借助引用计数的方式，避免为重复对象分配内存</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">   <span class="comment">// ptr 指向底层的真正的对象表示，结合 `encoding` 进行解析</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><p>Redis Server 启动的入口定义在此处（参见 <code>main</code> 函数）。下面是 Redis Server 启动时需要进行的重要步骤：</p><ul><li><code>initServerConfig()</code> 用来配置 <code>struct server</code> 的默认值</li><li><code>initServer()</code> 分配一些必要的数据结构、配置监听的 socket 等</li><li><code>aeMain()</code> 启动 Event Loop，监听新的连接</li></ul><p>Event Loop 中会周期调用的两个特殊函数如下：</p><ul><li><code>serverCron()</code> 会被周期调用（参考 <code>server.hz</code> 配置的频率），执行一些周期性的任务，如检查客户端超时等</li><li><code>beforeSleep()</code> 会在每次进入事件驱动库主循环时调用，也就是在睡眠等待 ready 的文件描述符之前</li></ul><p>在 <code>server.c</code> 中还有几个函数专门处理其它类型的重要任务：</p><ul><li><code>call()</code> 会在指定的客户端上下文中执行指定命令时被使用</li><li><code>activeExpireCycle()</code> 用来处理过期的 keys</li><li><code>freeMemoryIfNeeded()</code> 当 Redis 内存使用超过 <code>maxmemory</code> 指定的值，且有新的写入进来时，会执行该函数清理内存</li><li><code>redisCommandTable</code> 维护了所有 Redis 命令，其中包含每个命令的名称、回调函数、参数个数及其它属性</li></ul><h2 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h2><p>在这个文件中定义了所有的 I/O 函数，用来和客户端、master 及 replicas 交互：</p><ul><li><code>createClient()</code> 初始化新的客户端</li><li><code>addReply*()</code> 函数族用于给客户端添加响应数据</li><li><code>writeToClient()</code> 用于将输出缓冲区的数据发送给客户端，它会被 <code>sendReplyToClient()</code> 调用</li><li><code>readQueryFromClient()</code> 用于聚集从客户端读取的数据到查询缓冲区</li><li><code>processInputBuffer()</code> 是从客户端查询缓冲区（query buffer）根据 Redis 协议解析查询命令的入口函数。一旦命令可以处理了，就会调用 <code>processCommand()</code> 来真正执行命令</li><li><code>freeClient()</code> 释放客户端</li></ul><h2 id="aof-c-和-rdb-c"><a href="#aof-c-和-rdb-c" class="headerlink" title="aof.c 和 rdb.c"></a>aof.c 和 rdb.c</h2><p>顾名思义，这是 Redis 两种持久化方案的具体实现文件。Redis 的持久化模型比较有趣，它会通过 <code>fork()</code> 系统调用创建一个单独的线程，并能访问主线程共享的内存区域；接下来这个备份线程会将内存内容持久化到磁盘中。<code>rdb.c</code> 在创建快照时会使用这种机制；<code>aof.c</code> 在执行 AOF 重写（避免 Append Only 文件过大）时也会用到这个机制。</p><h2 id="db-c"><a href="#db-c" class="headerlink" title="db.c"></a>db.c</h2><p><code>db.c</code> 中定义了一些通用的操作命令，它们都是针对 key 进行的操作，而非对应的数据，比如 <code>DEL</code> 和 <code>EXPIRE</code> 等。此外，<code>db.c</code> 中还提供了一些特殊的 API 用于在 Redis 数据集上执行某些操作时，不用访问内部具体的数据结构。</p><p>以下是许多命令实现中都会用到的函数：</p><ul><li><code>lookupKeyRead()</code> 和 <code>lookupKeyWrite()</code> 用于基于指定 key 得到对应值的指针，如果 key 不存在，则返回 <code>NULL</code></li><li><code>dbAdd()</code> 及更抽象的函数 <code>setKey()</code> 是用来在 Redis 中创建新的 key</li><li><code>dbDelete()</code> 移除 key 及关联的 value</li><li><code>emptyDb()</code> 移除指定的数据库或者所有的数据库</li></ul><h2 id="object-c"><a href="#object-c" class="headerlink" title="object.c"></a>object.c</h2><p><code>struct robj</code> 是 Redis 对象的定义，在 <code>object.c</code> 中有很多应用于 Redis 对象的操作，其中比较关键的函数如下：</p><ul><li><code>incrRefcount()</code> 和 <code>decrRefCount()</code> 维护对象的引用计数。当引用值为 0 时才会真正释放对象</li><li><code>createObject()</code> 用于分配新的对象。此外，还有一些针对特殊内容分配字符串对象的函数，如 <code>createStringObjectFromLongLong()</code> 等</li></ul><h2 id="replication-c"><a href="#replication-c" class="headerlink" title="replication.c"></a>replication.c</h2><p><code>replication.c</code> 文件中实现了 master 和 replica 角色。但这块内容比较复杂，建议对 Redis 其它部分代码有所了解后再来学习它。</p><p>该文件中有个比较重要的函数 <code>replicationFeedSlaves()</code>，它用来将命令发送给从节点，从而保证和主节点数据同步。在该文件中还实现了 <code>SYNC</code> 和 <code>PSYNC</code> 命令，它们用于从节点初次初始化同步，或者在连接断开并重连后继续保持同步。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><code>t_hash.c</code>, <code>t_list.c</code>, <code>t_set.c</code>, <code>t_string.c</code> 和 <code>t_zset.c</code>  是 Redis 数据类型的底层实现</li><li><code>ae.c</code> Redis 事件循环实现</li><li><code>sds.c</code> Redis 动态变长字符串</li><li><code>anet.c</code> 对内核提供的网络接口做了封装，从而能够以更加简单的方式使用 POSIX 网络接口</li><li><code>dict.c</code> 非阻塞、渐进 rehash 字典实现</li><li><code>scripting.c</code> 实现了 Luc 脚本</li><li><code>cluster.c</code> Redis 集群实现。在了解这块代码前，记得参考下 <a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis 集群说明</a></li></ul><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://pic4.zhimg.com/v2-aab236e8173ddcc8e76721fbf651ea53.jpg" alt=""></p><h1 id="构建-amp-调试"><a href="#构建-amp-调试" class="headerlink" title="构建 &amp; 调试"></a>构建 &amp; 调试</h1><p>Redis 官方文档中有关于构建和运行它的详细说明，我们也可以使用 gdb 进行调试。但是，作为一个 IDE 死忠党，自然是要在 <a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">Clion</a> 中构建和调试 Redis 的。需要注意的是，Clion 使用了 cmake 来管理项目，所以我们需要在 Redis 源码根目录下为它创建好 CMakeLists.txt 才能进行构建。具体可参考 <a href="https://lijinglin.dev/post/2019/debug-redis-with-clion/" target="_blank" rel="noopener">使用 Clion 来调试 Redis 源码</a> 这篇文章~</p><p>在完成上一步后，切到 <code>src</code> 目录下，执行 <code>./mkreleasehdr.sh</code> 脚本生成 <code>src/release.h</code> 文件，否则构建可能会失败。然后在源码目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure><p>接下来，我们可以在 Clion 打开 <code>src/server.c</code> ，并找到 <code>main</code> 函数，点击工具栏中的运行或调试按钮，或者点击 <code>main</code> 函数左侧的按钮选择运行或调试。</p><p><img src="https://pic1.zhimg.com/v2-823df912ab47cf9dbe7ccc53a0eae03f.jpg" alt=""></p><p>Redis 服务启动时，默认会使用 6379 端口，也可以在 Clion 中配置参数，使用自定义的端口等：<br><img src="https://pic2.zhimg.com/v2-66bb67315fc0d86701b95ae306679eeb.jpg" alt=""></p><p>至此，我们已经可以使用 Clion 来阅读、运行或者调试 Redis 代码啦。有了神器助攻，便于我们通过调试工具追踪调用链，并了解执行步骤中各个中间状态。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/antirez/redis/tree/5.0" target="_blank" rel="noopener">Redis README</a></li><li><a href="https://sunznx.com/redis/redis-source-debug-with-clion.html" target="_blank" rel="noopener">Clion 调试 Redis 源码</a></li><li><a href="https://lijinglin.dev/post/2019/debug-redis-with-clion/" target="_blank" rel="noopener">使用 Clion 来调试 Redis 源码</a></li><li><a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">《Redis 5 设计与源码分析》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/iFaceless/redis/tree/5.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis, REmote DIctionary Server&lt;/a&gt; 因其高效、简单、丰富的数据结构支持、高性能、持久化和集群支持等特性得到了程序员们的青睐，并被广泛部署和应用在众多互联网公司。而因为它采用了比较简单的文本协议，使得客户端实现比较简单，因此也拥有众多编程语言实现的客户端；甚至也有一些其它类型的 K-V 数据库兼容了 Redis 协议！&lt;/p&gt;
&lt;p&gt;结合我们目前的业务来看，有非常多的场景使用到了 Redis：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录用户通知、短信发送标志，避免重复发送；&lt;/li&gt;
&lt;li&gt;使用 Redis 集合维护一些白名单用户表；&lt;/li&gt;
&lt;li&gt;为支持快速获得用户会员时长等基本信息，将这些信息在 Redis 集群中也维护了一份，并采取相关措施维持与 MySQL 数据库的最终一致性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然还有很多场景可以例举，但就我们常使用的 Redis 数据结构来看，主要就是 &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;hash map&lt;/code&gt;。虽说 Redis 给我们提供了其它丰富的内存数据结构，但是我们在生产环境用到的并不多。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="缓存" scheme="http://ifaceless.space/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="LRU" scheme="http://ifaceless.space/tags/LRU/"/>
    
      <category term="LFU" scheme="http://ifaceless.space/tags/LFU/"/>
    
      <category term="ARC" scheme="http://ifaceless.space/tags/ARC/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中如何以优雅的姿势实现对象序列化？</title>
    <link href="http://ifaceless.space/2019/11/28/portal/"/>
    <id>http://ifaceless.space/2019/11/28/portal/</id>
    <published>2019-11-28T13:50:45.000Z</published>
    <updated>2019-11-28T09:41:31.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在我们的 Web 后端项目中，通常将数据源获取相关的结构体定义放在 models.go 中，不管其关联的数据是来自于数据库、Redis 还是 RPC，总之都是收敛在这一层以提供更好的复用性。</p><p>而针对不同的场景，如 C 端 HTTP API 要求返回的数据，则定义对应的 Schema struct，从而聚合需要的数据下发出去。当然，对于 Admin API 和 RPC API 也会根据需要定义不同的 Schema struct。但是，它们都会复用相同的 models。想必这些应该都是比较常规的操作了吧。<br><a id="more"></a><br>但在实际使用中，也遇到了诸多问题：</p><ol><li>API Schema 的字段类型和 Model 中定义的不同（比如我们使用发号器获得的 ID 在 Model struct 中定义的是 int64，但是为了避免 json.Marshal 时溢出（浏览器截断），统一返回了 string 类型的 ID），就需要手动进行类型转换；</li><li>API Schema 的字段名称和 Model 中定义的可能不同；</li><li>支持灵活的 Schema 字段过滤比较麻烦，不同的项目实现可能不同；</li><li>在某些情况下，如课程 API Schema 关联的一些数据来自于其它服务（需要通过 RPC 调用），这时如果能够并发加载就有提高接口响应速度的可能，但是需要每次在应用层重新实现（当然可以再抽一层出来，不过还是很麻烦，会有心智负担）。</li><li>……</li></ol><p>那么，有没有更加优雅的解决办法呢？</p><h1 id="怎么解决？-🤔"><a href="#怎么解决？-🤔" class="headerlink" title="怎么解决？ 🤔"></a>怎么解决？ 🤔</h1><p>我们之前在使用 Python 项目开发时，使用到了 <a href="https://github.com/marshmallow-code/marshmallow" target="_blank" rel="noopener">marshmallow</a> 这个轻量级的对象序列化框架。当然，它不仅仅提供序列化的能力，还有反序列化以及字段校验的能力。如果能够恰当的使用它，是可以提升开发效率的。如果在 Go 语言社区中存在这样一个框架的话，它是可以解决上面提到的一些问题的。</p><p>在经过一番思想斗争后，斗胆实现了一个类似的框架 <a href="https://github.com/iFaceless/portal" target="_blank" rel="noopener">portal</a> 用于解决上面提到的一些问题。<a href="https://github.com/iFaceless/portal" target="_blank" rel="noopener">portal</a> 聚焦于以优雅且一致的方式处理对象序列化的问题；而对于 Struct Fields 的校验问题，我们可以直接使用已有的第三方库如 <a href="https://github.com/go-playground/validator" target="_blank" rel="noopener">go-playground/validator</a> 或 <a href="https://github.com/asaskevich/govalidator" target="_blank" rel="noopener">asaskevich/govalidator</a>。</p><p>目前来说，核心功能均已按照最初的设计实现了，主要功能如下：</p><ol><li>提供简洁易用的 API 接口</li><li>支持非常灵活的字段过滤能力（任意深度的嵌套字段过滤）</li><li>自动尝试类型转换，远离手动编写太多没什么灵魂的类型转换代码（早点下班不好吗？）</li><li>支持并发填充字段值：<ol><li>可手动指定哪些字段异步加载</li><li>可设置全局的 goroutine 池大小</li></ol></li></ol><h1 id="使用-PORTAL"><a href="#使用-PORTAL" class="headerlink" title="使用 PORTAL"></a>使用 PORTAL</h1><p>可以通过下面的方式安装该包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get get -u github.com/ifaceless/portal</span><br></pre></td></tr></table></figure><p><strong>第一步：定义 Model 结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotificationModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="keyword">int</span></span><br><span class="line">    Title   <span class="keyword">string</span></span><br><span class="line">    Content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserModel)</span> <span class="title">Fullname</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="comment">// 名称甚至可以来自 RPC 调用等，只是一个示例</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"user:%d"</span>, u.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notifications 返回用户关联的一些通知信息列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserModel)</span> <span class="title">Notifications</span><span class="params">()</span> <span class="params">(result []*NotificationModel)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;NotificationModel&#123;</span><br><span class="line">            ID:      i,</span><br><span class="line">            Title:   fmt.Sprintf(<span class="string">"title_%d"</span>, i),</span><br><span class="line">            Content: fmt.Sprintf(<span class="string">"content_%d"</span>, i),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span></span><br><span class="line">    UserID <span class="keyword">int</span></span><br><span class="line">    Title  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 返回 Task 关联的用户是谁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TaskModel)</span> <span class="title">User</span><span class="params">()</span> *<span class="title">UserModel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserModel&#123;t.UserID&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：定义 API Schema 结构体</strong></p><p>以下 Schema 在定义时，都添加了 json tag，并且标记为 omitempty。这样做的目的是，<strong>当我们选择过滤某些字段的时候，portal 就不会填充对应的 Schema Fields</strong>。因此，标记了 omitempty 的字段在 json.Marshal 后就不会出现，从而达到字段过滤的目的。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotiSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="keyword">string</span> <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    Title   <span class="keyword">string</span> <span class="string">`json:"title,omitempty"`</span></span><br><span class="line">    Content <span class="keyword">string</span> <span class="string">`json:"content,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID                   <span class="keyword">string</span>        <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    <span class="comment">// 名称是从 User.Fullname() 方法中获取，我们把它称为 User 的一个属性，使用 `attr` 标记</span></span><br><span class="line">    Name                 <span class="keyword">string</span>        <span class="string">`json:"name,omitempty" portal:"attr:Fullname"`</span></span><br><span class="line">        <span class="comment">// nested 表明该字段的值是一个复合类型，portal 会自动将 notifications 数据填充到对应的 schema 列表</span></span><br><span class="line">    Notifications        []*NotiSchema <span class="string">`json:"notifications,omitempty" portal:"nested"`</span></span><br><span class="line">    AnotherNotifications []*NotiSchema <span class="string">`json:"another_notifications,omitempty" portal:"nested;attr:Notifications"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID          <span class="keyword">string</span>      <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    Title       <span class="keyword">string</span>      <span class="string">`json:"title,omitempty"`</span></span><br><span class="line">    Description <span class="keyword">string</span>      <span class="string">`json:"description,omitempty" portal:"meth:GetDescription"`</span></span><br><span class="line">    <span class="comment">// UserSchema is a nested schema</span></span><br><span class="line">    User        *UserSchema <span class="string">`json:"user,omitempty" portal:"nested"`</span></span><br><span class="line">    <span class="comment">// We just want `Name` field for `SimpleUser`.</span></span><br><span class="line">    <span class="comment">// Besides, the data source is the same with `UserSchema`</span></span><br><span class="line">    SimpleUser  *UserSchema <span class="string">`json:"simple_user,omitempty" portal:"nested;only:Name;attr:User"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDescription 我们可以通过自定义方法来提供想要的数据</span></span><br><span class="line"><span class="comment">// 一个常见的场景是，我们可以在自定义方法中根据用户状态返回不同的文案</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *TaskSchema)</span> <span class="title">GetDescription</span><span class="params">(model *model.TaskModel)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Custom description"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步：按需序列化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"github.com/ifaceless/portal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// log debug info</span></span><br><span class="line">    portal.SetDebug(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// set max worker pool size</span></span><br><span class="line">    portal.SetMaxPoolSize(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment">// make sure to clean up.</span></span><br><span class="line">    <span class="keyword">defer</span> portal.CleanUp()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write to a specified task schema</span></span><br><span class="line">    <span class="keyword">var</span> taskSchema schema.TaskSchema</span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel)</span><br><span class="line">    <span class="comment">// data: &#123;"id":"1","title":"Finish your jobs.","description":"Custom description","user":&#123;"id":"1","name":"user:1","notifications":[&#123;"id":"0","title":"title_0","content":"content_0"&#125;],"another_notifications":[&#123;"id":"0","title":"title_0","content":"content_0"&#125;]&#125;,"simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select specified fields</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Only(<span class="string">"Title"</span>, <span class="string">"SimpleUser"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"title":"Finish your jobs.","simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// select fields with alias defined in the json tag.</span></span><br><span class="line">    <span class="comment">// actually, the default alias tag is `json`, `portal.FieldAliasMapTagName("json")` is optional.</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Only(<span class="string">"title"</span>, <span class="string">"SimpleUser"</span>), portal.FieldAliasMapTagName(<span class="string">"json"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"title":"Finish your jobs.","simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you can keep any fields for any nested schemas</span></span><br><span class="line">    <span class="comment">// multiple fields are separated with ','</span></span><br><span class="line">    <span class="comment">// nested fields are wrapped with '[' and ']'</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Only(<span class="string">"ID"</span>, <span class="string">"User[ID,Notifications[ID],AnotherNotifications[Title]]"</span>, <span class="string">"SimpleUser"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"id":"1","user":&#123;"id":"1","notifications":[&#123;"id":"0"&#125;],"another_notifications":[&#123;"title":"title_0"&#125;]&#125;,"simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore specified fields</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Exclude(<span class="string">"Description"</span>, <span class="string">"ID"</span>, <span class="string">"User[Name,Notifications[ID,Content],AnotherNotifications], SimpleUser"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"title":"Finish your jobs.","user":&#123;"id":"1","notifications":[&#123;"title":"title_0"&#125;]&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dump multiple tasks</span></span><br><span class="line">    <span class="keyword">var</span> taskSchemas []schema.TaskSchema</span><br><span class="line">    portal.Dump(&amp;taskSchemas, &amp;taskModels, portal.Only(<span class="string">"ID"</span>, <span class="string">"Title"</span>, <span class="string">"User[Name]"</span>))</span><br><span class="line">    <span class="comment">// data: [&#123;"id":"0","title":"Task #1","user":&#123;"name":"user:100"&#125;&#125;,&#123;"id":"1","title":"Task #2","user":&#123;"name":"user:101"&#125;&#125;]</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上仅仅是 PORTAL 的一些简单场景的应用，详细可以查看<a href="https://github.com/iFaceless/portal/blob/master/examples/todo" target="_blank" rel="noopener">完整示例</a>，在<a href="https://github.com/iFaceless/portal/blob/master/USERGUIDE.md" target="_blank" rel="noopener">使用指南</a>中提供了一些详细的使用说明。</p><h1 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span> <span class="params">(*Chell, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Dump</span><span class="params">(dst, src <span class="keyword">interface</span>&#123;&#125;, opts ...Option)</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">DumpWithContext</span><span class="params">(ctx context.Context, dst, src <span class="keyword">interface</span>&#123;&#125;, opts ...Option)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SetDebug</span><span class="params">(v <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SetMaxPoolSize</span><span class="params">(size <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">CleanUp</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h1 id="关于并发加载的策略"><a href="#关于并发加载的策略" class="headerlink" title="关于并发加载的策略"></a>关于并发加载的策略</h1><ul><li>当某个 Schema 结构体字段标记了 <code>portal:&quot;async&quot;</code> 标签时会异步填充字段值；</li><li>当序列化 Schema 列表时，会分析 Schema 中有无标记了 <code>async</code> 的字段，如果存在的话，则使用并发填充策略；否则只在当前 goroutine 中完成序列化；</li><li>可以在 Dump 时添加 <code>portal.DisableConcurrency()</code> 禁用并发序列化的功能。</li></ul><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><p><strong>Q: 为什么需要全局 worker pool 存在？</strong><br><strong>A:</strong> 考虑到在 Web 服务中，每个请求过来都会启动一个新的 goroutine 处理。而在处理请求中，如果不限制 PORTAL 并发加载字段值时的 goroutine 数量，可能会导致非常严重的资源消耗问题。所以这里使用了 ants 框架。</p><p><strong>Q: 性能 v.s 开发效率？</strong><br><strong>A:</strong>其实引入这种框架，势必会对接口处理时的内存占用，处理性能产生影响。因为内部实现中也不可避免地大量使用了反射。所以，如果你追求的是高性能的话，那还是不推荐使用了。就我们的应用场景来说，很多接口的 QPS 并不高（尤其是一些后台接口），不管是 CPU 还是内存资源都是充足的。这个时候使用 PORTAL 是可以有效提高开发效率的（个人愚见），毕竟可以少写一些代码，让机器干些蠢活脏活。</p><p><strong>Q: 实际项目中是如何使用 portal 的？有什么体会？带来了什么收益？</strong><br><strong>A:</strong>历经将近一个月的实际项目实践，portal 目前已经趋于稳定，并且修复了大量问题，发布了 22 个版本。目前该工具包应应用在多个线上服务中（包括 HTTP RESTful API 和 RPC 中 Model 到 thrift 定义类型的映射），整体感受就是开发体验成倍提高，而且带来了性能影响并没有最开始认为的那么大。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人认为，框架的引入正是为了提高开发效率，提升项目质量的。框架层的抽象和封装可以让我们不用每次都在业务代码层编写重复机械式的代码，同时能够保证编写方式的一致性，提升项目的可维护性。<strong>所谓的性能问题，也许根本不是问题；所谓的提前优化，也许只是过度优化。</strong>我们应该用 20% 时间解决 80% 的常规问题，并且是高效率高质量的那种。而剩下 20% 的难题，完全可以用别的方法解决。切勿本末倒置！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在我们的 Web 后端项目中，通常将数据源获取相关的结构体定义放在 models.go 中，不管其关联的数据是来自于数据库、Redis 还是 RPC，总之都是收敛在这一层以提供更好的复用性。&lt;/p&gt;
&lt;p&gt;而针对不同的场景，如 C 端 HTTP API 要求返回的数据，则定义对应的 Schema struct，从而聚合需要的数据下发出去。当然，对于 Admin API 和 RPC API 也会根据需要定义不同的 Schema struct。但是，它们都会复用相同的 models。想必这些应该都是比较常规的操作了吧。&lt;br&gt;
    
    </summary>
    
      <category term="Web 开发" scheme="http://ifaceless.space/categories/Web-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="对象序列化" scheme="http://ifaceless.space/tags/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Web API" scheme="http://ifaceless.space/tags/Web-API/"/>
    
      <category term="portal" scheme="http://ifaceless.space/tags/portal/"/>
    
  </entry>
  
  <entry>
    <title>论文学习之 Linux 调度器</title>
    <link href="http://ifaceless.space/2019/11/17/guide-to-linux-scheduler/"/>
    <id>http://ifaceless.space/2019/11/17/guide-to-linux-scheduler/</id>
    <published>2019-11-17T15:20:14.000Z</published>
    <updated>2019-11-28T09:55:32.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><em>Linux Kernel Development</em> 一书中，关于 Linux 的进程调度器并没有讲解的很深入，只是提到了 CFS 调度器的基本思想和一些实现细节；并没有 Linux 早期的调度器介绍，以及最近这些年新增的在内核源码树外维护的调度器思想。所以在经过一番搜寻后，看到了这篇论文 <a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a>，对 Linux 的调度器历史进行了回顾，并且相对细致地讲解了 CFS 调度器。整体来说，虽然比较啰嗦，但是对于想要知道更多细节的我来说非常适合，所以就有了翻译它的冲动。当然，在学习过程也参考了其它论文。下面开启学习之旅吧~</p><a id="more"></a><p><em>需要注意的是，在 Linux 中，线程和进程都是由同一个结构体（task_struct，即任务描述符）表示的，所以文中会交叉使用进程、线程和任务等术语，可以将它们视作同义词。当然，也可以将线程（任务）称为最小执行单元。但 Linux 的调度算法（如 CFS）可以应用更加通用的调度单元（如线程、cgroup、用户等）。总之，不要过度纠结这里的术语，重要的是了解每种调度算法的思想！</em></p><h1 id="为什么需要调度"><a href="#为什么需要调度" class="headerlink" title="为什么需要调度"></a>为什么需要调度</h1><p>Linux 是一个多任务的操作系统，这就意味着它可以「同时」执行多个任务。在单核处理器上，任意时刻只能有一个进程可以执行（并发）；而在多核处理器中，则允许任务并行执行。然而，不管是何种硬件类型的机器上，可能同时还有很多在内存中无法得到执行的进程，它们正在等待运行，或者正在睡眠。负责将 CPU 时间分配给进程的内核组件就是「进程调度器」。</p><p>调度器负责维护进程调度顺序，选择下一个待执行的任务。如同多数其它的现代操作系统，Linux 实现了<strong>抢占式</strong>多任务机制。也就是说，调度器可以随时决定任意进程停止运行，而让其它进程获得 CPU 资源。这种违背正在运行的进程意愿，停止其运行的行为就是所谓的「抢占」。抢占通常可以在定时器中断时发生，当中断发生时，调度器会检查是否需要切换任务，如果是，则会完成进程上下文切换。每个进程所获得的运行时间叫做<strong>进程的时间片（timeslice）</strong>。</p><p>任务通常可以区分为<strong>交互式（I/O 密集型）</strong>和<strong>非交互式（CPU 密集型）</strong>任务。交互式任务通常会重度依赖 I/O 操作（如 GUI 应用），并且通常用不完分配给它的时间片。而非交互式任务（如数学运算）则需要使用更多的 CPU 资源。它们通常会用完自己的时间片之后被抢占，并不会被 I/O 请求频繁阻塞。</p><p>当然，现实中的应用程序可能同时包含上述两种分类任务。例如，文本编辑器，多数情况下，它会等待用户输入，但是在执行拼写检查时也会需要占用大量 CPU 资源。</p><p><strong>操作系统的调度策略就需要均衡这两种类型的任务，并且保证每个任务都能得到足够的执行资源，而不会对其它任务产生明显的性能影响。</strong> Linux 为了保证 CPU 利用率最大化，同时又能保证更快的响应时间，倾向于为非交互式任务分配更大的时间片，但是以较低的频率运行它们；而针对 I/O 密集型任务，则会在较短周期内频繁地执行。</p><h1 id="调度有关的进程描述符"><a href="#调度有关的进程描述符" class="headerlink" title="调度有关的进程描述符"></a>调度有关的进程描述符</h1><p>进程描述符（task_struct）中的很多字段会被调度机制直接使用。以下仅列出一些核心的部分，并在后文详细讨论。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line">    <span class="keyword">cpumask_t</span> cpus_allowed;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关于这些字段的说明如下：</p><ul><li><code>prio</code> 表示进程的优先级。进程运行时间，抢占频率都依赖于这些值。<code>rt_priority</code> 则用于实时（real-time）任务；</li><li><code>sched_class</code> 表示进程位于哪个调度类；</li><li><code>sched_entity</code> 的意义比较特殊。通常把一个线程（Linux 中的进程、任务同义词）叫作最小调度单元。但是 Linux 调度器不仅仅只能够调度单个任务，<strong>而且还可以将一组进程，甚至属于某个用户的所有进程作为整体进行调度</strong>。这就允许我们实现组调度，从而将 CPU 时间先分配到进程组，再在组内分配到单个线程。当引入这项功能后，可以大幅度提升桌面系统的交互性。比如，可以将编译任务聚集成一个组，然后进行调度，从而不会对交互性产生明显的影响。这里再次强调下，**Linux 调度器不仅仅能直接调度进程，也能对调度单元（schedulable entities）进行调度。这样的调度单元正是用 <code>struct sched_entity</code> 来表示的。需要说明的是，它并非一个指针，而是直接嵌套在进程描述符中的。当然，后面的谈论将聚焦在单进程调度这种简单场景。由于调度器是面向调度单元设计的，所以它会将单个进程也视为调度单元，因此会使用 <code>sched_entity</code> 结构体操作它们。<code>sched_rt_entity</code> 则是实时调度时使用的。</li><li><code>policy</code> 表明任务的调度策略：通常意味着针对某些特定的进程组（如需要更长时间片，更高优先级等）应用特殊的调度决策。Linux 内核目前支持的调度策略如下：<ul><li><code>SCHED_NORMAL</code>：普通任务使用的调度策略；</li><li><code>SCHED_BATCH</code>：不像普通任务那样被频繁抢占，可允许任务运行尽可能长的时间，从而更好地利用缓存，但是代价自然是损失交互性能。这种非常适合批量任务调度（批量的 CPU 密集型任务）;</li><li><code>SCHED_IDLE</code>：它要比 nice 19 的任务优先级还要低，但它并非真的空闲任务;</li><li><code>SCHED_FIFO</code> 和 <code>SCHED_RR</code> 是软实时进程调度策略。它们是由 POSIX 标准定义的，由 <code>&lt;kernel/sched/rt.c&gt;</code> 里面定义的实时调度器负责调度。RR 实现的是带有固定时间片的轮转调度方式；SCHED_FIFO 则使用的是先进先出的队列机制。</li></ul></li><li><code>cpus_allowed</code>：用来表示任务的 CPU 亲和性。用户空间可以通过 <code>sched_setaffinity</code> 系统调用来设置。</li></ul><h1 id="优先级-Priority"><a href="#优先级-Priority" class="headerlink" title="优先级 Priority"></a>优先级 Priority</h1><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><h3 id="普通任务优先级"><a href="#普通任务优先级" class="headerlink" title="普通任务优先级"></a>普通任务优先级</h3><p>所有的类 Unix 操作系统都实现了优先级调度机制。它的核心思想就是给任务设定一个值，然后通过该值决定任务的重要程度。如果任务的优先级一致，则一次重复运行它们。在 Linux 中，每一个普通任务都被赋予了一个 nice 值，它的范围是 -20 到 +19，任务默认 nice 值是 0。<br><img src="https://pic1.zhimg.com/v2-665ed41d133e9e332c4fdc6034240cb5.jpg" alt=""></p><p>nice 值越高，任务优先级越低（it’s nice to others）。Linux 中可以使用 <code>nice(int increment)</code> 系统调用来修改当前进程的优先级。该系统调用的实现位于 <code>&lt;kernel/shced/core.c&gt;</code> 中。默认情况下，用户只能为该用户启动的进程增加 nice 值（即降低优先级）。如果需要增加优先级（减少 nice 值），或者修改其它用户进程优先级，则必须以 root 身份操作。</p><h3 id="实时任务优先级"><a href="#实时任务优先级" class="headerlink" title="实时任务优先级"></a>实时任务优先级</h3><p>在 Linux 中，除了普通任务外，还有一类任务属于实时任务。实时任务是确保它们能够在一定时间范围内执行的任务，有两类实时任务，列举如下：</p><ul><li><strong>硬实时任务</strong>：会有严格的时间限制，任务必须在时限内完成。比如直升机的飞控系统，就需要及时响应驾驶员的操控，并做出预期的动作。然而，Linux 本身并不支持硬实时任务，但是有一些基于它修改的版本，如 RTLinux（它们通常被称为 RTOS）则是支持硬实时调度的。</li><li><strong>软实时任务</strong>：软实时任务其实也会有时间限制，但不是那么严格。也就是说，任务晚一点运行任务，并不会造成不可挽回的灾难性事故。实践中，软实时任务会提供一定的时间限制保障，但是不要过度依赖这种特性。例如，VOIP 软件会使用软实时保障的协议传来送音视频信号，但是即便因为操作系统负载过高，而产生一点延迟，也不会造成很大影响。<strong>无论如何，软实时任务总会比普通任务的优先级更高</strong>。</li></ul><p>Linux 中实时任务的优先级范围是 0~99，但是有趣的是，它和 nice 值的作用刚好相反，这里的优先级值越大，就意味着优先级越高。<br><img src="https://pic4.zhimg.com/v2-d5299a6846bcb492ec3340f1a725b323.jpg" alt=""></p><p>类似其它的 Unix 系统，Linux 也是基于 POSIX 1b 标准定义的 「Real-time Extensions」实现实时优先级。可以通过如下的命令查看系统中的实时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -eo pid, rtprio, cmd</span><br></pre></td></tr></table></figure><p>也可通过 <code>chrt -p pid</code> 查看单个进程的详情。Linux 中可以通过 <code>chrt -p prio pid</code> 更改实时任务优先级。这里需要注意的是，如果操作的是一个系统进程（通常并不会将普通用户的进程设置为实时的），则必须有 root 权限才可以修改实时优先级。</p><h2 id="内核视角下的进程优先级"><a href="#内核视角下的进程优先级" class="headerlink" title="内核视角下的进程优先级"></a>内核视角下的进程优先级</h2><p>实时上，内核看到的任务优先级和用户看到的并不相同，在计算和管理优先级时也需要考虑很多方面。Linux 内核中使用 0~139 表示任务的优先级，并且，<strong>值越小，优先级越高</strong>（注意和用户空间的区别）。其中 0~99 保留给实时进程，100~139（映射成 nice 值就是 -20~19）保留给普通进程。<br><img src="https://pic2.zhimg.com/v2-4d4d4645d2dc1a52bbea516e8d82171b.jpg" alt=""></p><p>我们可以在 <code>&lt;include/linux/sched/prio.h&gt;</code> 头文件中看到内核表示进程优先级的单位（scale）和宏定义（macros），它们用来将用户空间优先级映射到到内核空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NICE 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_NICE -20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NICE_WIDTH (MAX_NICE - MIN_NICE + 1)</span></span><br><span class="line">…</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USER_RT_PRIO 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RT_PRIO MAX_USER_RT_PRIO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Convert user-nice values [ -20 ... 0 ... 19 ]</span></span><br><span class="line"><span class="comment">* to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],</span></span><br><span class="line"><span class="comment">* and back.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 'User priority' is the nice value converted to something we</span></span><br><span class="line"><span class="comment">* can work with better when scaling various scheduler parameters,</span></span><br><span class="line"><span class="comment">* it's a [ 0 ... 39 ] range.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_PRIO(p) ((p)-MAX_RT_PRIO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_USER_PRIO(p) USER_PRIO((p)-&gt;static_prio)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USER_PRIO (USER_PRIO(MAX_PRIO))</span></span><br></pre></td></tr></table></figure></p><h2 id="优先级计算"><a href="#优先级计算" class="headerlink" title="优先级计算"></a>优先级计算</h2><p>在 <code>task_struct</code> 中有几个字段用来表示进程优先级：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br></pre></td></tr></table></figure></p><p><code>static_prio</code> 是由用户或系统设定的「静态」优先级映射成内核表示的优先级：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;static_prio = NICE_TO_PRIO(nice_value);</span><br></pre></td></tr></table></figure></p><p><code>normal_prio</code> 存放的是基于 <code>static_prio</code> 和进程调度策略（实时或普通）决定的优先级，相同的静态优先级，在不同的调度策略下，得到的正常优先级是不同的。子进程在 fork 时，会继承父进程的 <code>normal_prio</code>。</p><p><code>prio</code> 则是「动态优先级」，在某些场景下优先级会发生变动。一种场景就是，系统可以通过给某个任务优先级提升一段时间，从而抢占其它高优先级任务，一旦 <code>static_prio</code> 确定，<code>prio</code> 字段就可以通过下面的方式计算：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prio = effective_prio(p);</span><br><span class="line"><span class="comment">// kernel/sched/core.c 中定义了计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">effective_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If we are RT tasks or we were boosted to RT priority,</span></span><br><span class="line"><span class="comment">    * keep the priority unchanged. Otherwise, update priority</span></span><br><span class="line"><span class="comment">    * to the normal priority:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">        <span class="keyword">return</span> p-&gt;normal_prio;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">normal_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prio;</span><br><span class="line">    <span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">        prio = MAX_DL_PRIO<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">        prio = MAX_RT_PRIO<span class="number">-1</span> - p-&gt;rt_priority;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        prio = __normal_prio(p);</span><br><span class="line">    <span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __normal_prio(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;static_prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="负载权重（Load-Weights）"><a href="#负载权重（Load-Weights）" class="headerlink" title="负载权重（Load Weights）"></a>负载权重（Load Weights）</h2><p>优先级会让一些任务比别的任务更重要，因此也会获得更多的 CPU 使用时间。nice 值和时间片的比例关系是通过负载权重（Load Weights）进行维护的，我们可以在 <code>task_struct-&gt;se.load</code> 中看到进程的权重，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span> <span class="comment">/* for load-balancing */</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> weight;</span><br><span class="line">    u32 inv_weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了让 nice 值的变化反映到 CPU 时间变化片上更加合理，Linux 内核中定义了一个数组，用于映射 nice 值到权重：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line">    <span class="comment">/* -20 */</span> <span class="number">88761</span>, <span class="number">71755</span>, <span class="number">56483</span>, <span class="number">46273</span>, <span class="number">36291</span>,</span><br><span class="line">    <span class="comment">/* -15 */</span> <span class="number">29154</span>, <span class="number">23254</span>, <span class="number">18705</span>, <span class="number">14949</span>, <span class="number">11916</span>,</span><br><span class="line">    <span class="comment">/* -10 */</span> <span class="number">9548</span>, <span class="number">7620</span>, <span class="number">6100</span>, <span class="number">4904</span>, <span class="number">3906</span>,</span><br><span class="line">    <span class="comment">/* -5 */</span> <span class="number">3121</span>, <span class="number">2501</span>, <span class="number">1991</span>, <span class="number">1586</span>, <span class="number">1277</span>,</span><br><span class="line">    <span class="comment">/* 0 */</span> <span class="number">1024</span>, <span class="number">820</span>, <span class="number">655</span>, <span class="number">526</span>, <span class="number">423</span>,</span><br><span class="line">    <span class="comment">/* 5 */</span> <span class="number">335</span>, <span class="number">272</span>, <span class="number">215</span>, <span class="number">172</span>, <span class="number">137</span>,</span><br><span class="line">    <span class="comment">/* 10 */</span> <span class="number">110</span>, <span class="number">87</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">45</span>,</span><br><span class="line">    <span class="comment">/* 15 */</span> <span class="number">36</span>, <span class="number">29</span>, <span class="number">23</span>, <span class="number">18</span>, <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>来看看如何使用上面的映射表，假设有两个优先级都是 0 的任务，每个都能获得 50% 的 CPU 时间（1024 / (1024 + 1024) = 0.5）。如果突然给其中的一个任务优先级提升了 1 （nice 值 -1）。此时，一个任务应该会获得额外 10% 左右的 CPU 时间，而另一个则会减少 10% CPU 时间。来看看计算结果：1277 / (1024 + 1277) ≈ 0.55，1024 / (1024 + 1277) ≈ 0.45，二者差距刚好在 10% 左右，符合预期。完整的计算函数定义在 <code>&lt;kernel/sched/core.c&gt;</code> 中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_load_weight</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prio = p-&gt;static_prio - MAX_RT_PRIO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> *<span class="title">load</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>.<span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * SCHED_IDLE tasks get minimal weight:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;policy == SCHED_IDLE) &#123;</span><br><span class="line">        load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);</span><br><span class="line">        load-&gt;inv_weight = WMULT_IDLEPRIO;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    load-&gt;weight = scale_load(prio_to_weight[prio]);</span><br><span class="line">    load-&gt;inv_weight = prio_to_wmult[prio];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="调度类-Scheduling-Classes"><a href="#调度类-Scheduling-Classes" class="headerlink" title="调度类 Scheduling Classes"></a>调度类 Scheduling Classes</h1><p>虽说 Linux 内核使用的 C 语言并非所谓的 OOP 语言（没有类似 C++/Java 中的 class 概念），但是我们可以在内核代码中看到一些使用 C 语言结构体 + 函数指针（Hooks）的方式来模拟面向对象的方式，抽象行为和数据。调度类也是这样实现的（此外，还有 <code>inode_operations</code>, <code>super_block_operations</code> 等），它的定义如下（位于 <code>&lt;kernel/shced/sched.h&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简单起见，隐藏了部分代码（如 SMP 相关的）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 多个 sched_class 是链接在一起的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 该 hook 会在任务进入可运行状态时调用。它会将调度单元（如一个任务）放到</span></span><br><span class="line">    <span class="comment">// 队列中，同时递增 `nr_running` 变量（该变量表示运行队列中可运行的任务数）</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">// 该 hook 会在任务不可运行时调用。它会将任务移出队列，同时递减 `nr_running`</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">// 该 hook 可以在任务需要主动放弃 CPU 时调用，但是需要注意的是，它不会改变</span></span><br><span class="line">    <span class="comment">// 任务的可运行状态，也就是说依然会在队列中等待下次调度。类似于先 dequeue_task，</span></span><br><span class="line">    <span class="comment">// 再 enqueue_task</span></span><br><span class="line">    <span class="keyword">void</span> (*yield_task) (struct rq *rq);</span><br><span class="line">    <span class="comment">// 该 hook 会在任务进入可运行状态时调用并检查是否需要抢占当前任务</span></span><br><span class="line">    <span class="keyword">void</span> (*check_preempt_curr) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">// 该 hook 用来选择最适合运行的下一个任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>) (<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>);</span></span><br><span class="line">    <span class="comment">// 该 hook 会在任务修改自身的调度类或者任务组时调用</span></span><br><span class="line">    <span class="keyword">void</span> (*set_curr_task) (struct rq *rq);</span><br><span class="line">    <span class="comment">// 通常是在时钟中断时调用，可能会导致任务切换</span></span><br><span class="line">    <span class="keyword">void</span> (*task_tick) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> queued);</span><br><span class="line">    <span class="comment">// 当任务被 fork 时通知调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*task_fork) (struct task_struct *p);</span><br><span class="line">    <span class="comment">// 当任务挂掉时通知调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*task_dead) (struct task_struct *p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关于调度策略的具体细节的实现有如下几个模块：</p><ul><li><code>core.c</code> 包含调度器的核心部分；</li><li><code>fair.c</code> 实现了 CFS（Comple Faire Scheduler，完全公平任务调度器） 调度器，应用于普通任务；</li><li><code>rt.c</code> 实现了实时调度，应用于实时任务；</li><li><code>idle_task.c</code> 当没有其它可运行的任务时，会运行空闲任务。<br>内核是基于任务的调度策略（SCHED_*）来决定使用何种调度类实现，并会调用相应的方法。<code>SCHED_NORMAL</code>, <code>SCHED_BATCH</code> 和 <code>SCHED_IDLE</code> 进程会映射到 <code>fair_sched_class</code> （由 CFS 实现）；<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code> 则映射的 <code>rt_sched_class</code> （实时调度器）。</li></ul><h1 id="运行队列-Run-Queue"><a href="#运行队列-Run-Queue" class="headerlink" title="运行队列 Run Queue"></a>运行队列 Run Queue</h1><p>所有可运行的任务是放在运行队列中的，并且等待 CPU 运行。每个 CPU 核心都有自己的运行队列，每个任务任意时刻只能处于其中一个队列中。在多处理器机器中，会有负载均衡策略，任务就会转移到其它 CPU 上运行的可能。</p><p>运行队列数据结构定义如下（位于 <code>&lt;kernel/sched/sched.h&gt;</code>）:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简单起见，隐藏了部分代码（SMP 相关）</span></span><br><span class="line"><span class="comment">// 这个是每个 CPU 都会有的一个任务运行队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 表示当前队列中总共有多少个可运行的任务（包含所有的 sched class）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_running;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line">    <span class="comment">// 运行队列负载记录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">// 嵌套的 CFS 调度器运行队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span></span><br><span class="line">    <span class="comment">// 嵌套的实时任务调度器运行队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span></span><br><span class="line">    <span class="comment">// curr 指向当前正在运行的进程描述符</span></span><br><span class="line">    <span class="comment">// idle 则指向空闲进程描述符（当没有其它可运行任务时，该任务才会启动）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>, *<span class="title">idle</span>;</span></span><br><span class="line">    u64 clock;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="何时运行调度器？"><a href="#何时运行调度器？" class="headerlink" title="何时运行调度器？"></a>何时运行调度器？</h1><p>实时上，调度函数 <code>schedule()</code> 会在很多场景下被调用。有的是直接调用，有的则是隐式调用（通过设置 <code>TIF_NEED_RESCHED</code> 来提示操作系统尽快运行调度函数）。以下三个调度时机值得关注下：</p><ul><li><p><strong>时钟中断发生时，会调用 <code>scheduler_tick()</code> 函数</strong>，该函数会更新一些和调度有关的数据统计，并触发调度类的周期调度方法，从而间接地进行调度。以 2.6.39 源码为例，可能的调用链路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick</span><br><span class="line">└── task_tick</span><br><span class="line">    └── entity_tick</span><br><span class="line">        └── check_preempt_tick</span><br><span class="line">            └── resched_task</span><br><span class="line">                └── set_tsk_need_resched</span><br></pre></td></tr></table></figure></li><li><p><strong>当前正在运行的任务进入睡眠状态</strong>。在这种情况下，任务会主动释放 CPU。通常情况下，该任务会因为等待指定的事件而睡眠，它可以将自己添加到等待队列，并启动循环检查期望的条件是否满足。在进入睡眠前，任务可以将自己的状态设置为 <code>TASK_INTERRUPTABLE</code>（除了任务要等待的事件可唤醒外，也可以被信号唤醒）或者 <code>TASK_UNINTERRUPTABLE</code>（自然是不会理会信号咯），然后调用 <code>schedule()</code> 选择下一个任务运行。</p></li><li><p><strong>睡眠的任务被唤醒</strong>。任务等待的事件可以在关联的等待队列上调用 <code>wake_up()</code> 函数唤醒任务：相关任务会将自己设置为可运行状态，并加入运行队列。如果当前唤醒的任务优先级比运行队列中的任何任务都高，则会设置 <code>TIF_NEED_RESCHED</code> 标志，从而让操作系统尽快调用 <code>schedule()</code> 函数。</p></li></ul><h1 id="Linux-调度器"><a href="#Linux-调度器" class="headerlink" title="Linux 调度器"></a>Linux 调度器</h1><h2 id="早期版本"><a href="#早期版本" class="headerlink" title="早期版本"></a>早期版本</h2><p>Linux 0.0.1 版本就已经有了一个简单的调度器，当然并非适合拥有特别多处理器的系统。该调度器只维护了一个全局的进程队列，每次都需要遍历该队列来寻找新的进程执行，而且对任务数量还有严格限制（<code>NR_TASKS</code> 在最初的版本中只有 32）。下面来看看这个调度器是如何实现的吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'schedule()' is the scheduler function. </span></span><br><span class="line"><span class="comment">// This is GOOD CODE! There probably won't be any reason to change </span></span><br><span class="line"><span class="comment">// this, as it should work well in all circumstances (ie gives </span></span><br><span class="line"><span class="comment">// IO-bound processes good response etc)...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, next, c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 遍历所有任务，如果有信号，则需要唤醒 `TASK_INTERRUPTABLE` 的任务</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">                (*p)-&gt;signal |= (<span class="number">1</span> &lt;&lt; (SIGALRM - <span class="number">1</span>));</span><br><span class="line">                (*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;signal &amp;&amp; (*p)-&gt;state == TASK_INTERRUPTIBLE)</span><br><span class="line">                (*p)-&gt;state = TASK_RUNNING;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        <span class="comment">// 遍历所有任务，找到时间片最长的那个</span></span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 遍历任务，重新设值时间片</span></span><br><span class="line">        <span class="keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切换到下一个需要执行的任务</span></span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>2.4 版本的 Linux 内核使用的调度算法非常简单和直接，由于每次在寻找下一个任务时需要遍历系统中所有的任务（链表），因此被称为 O(n) 调度器（时间复杂度）。</p><p>当然，该调度器要比 0.01 版本内核中的调度算法稍微复杂点，它引入了 epoch 概念。也就是将时间分成纪元（epochs），也就是每个进程的生命周期。理论上来说，每个纪元结束，每个进程都应该运行过一次了，而且通常用光了它当前的时间片。但实际上，有些任务并没有完全用完时间片，那么它剩余时间片的一半将会和新的时间片相加，从而在下一个纪元运行更长的时间。</p><p>我们来看下 <code>schedule()</code> 算法的核心源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule() 算法会遍历所有的任务（O(N)），并且计算出每个任务的</span></span><br><span class="line"><span class="comment">// goodness 值，且挑选出「最好」的任务来运行。</span></span><br><span class="line"><span class="comment">// 以下是部分核心源码，主要是了解下它的思路。</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 任务（进程）描述符：</span></span><br><span class="line">    <span class="comment">// 1. prev: 当前正在运行的任务</span></span><br><span class="line">    <span class="comment">// 2. next: 下一个将运行的任务</span></span><br><span class="line">    <span class="comment">// 3. p: 当前正在遍历的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> this_cpu, c; <span class="comment">// c 表示权重值</span></span><br><span class="line">repeat_schedule:</span><br><span class="line">    <span class="comment">// 默认选中的任务</span></span><br><span class="line">    next = idle_task(this_cpu);</span><br><span class="line">    c = <span class="number">-1000</span>;</span><br><span class="line">    list_for_each(tmp, &amp;runqueue_head) &#123;</span><br><span class="line">        p = list_entry(tmp, struct task_struct, run_list);</span><br><span class="line">        <span class="keyword">if</span> (can_schedule(p, this_cpu)) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = goodness(p, this_cpu, prev-&gt;active_mm);</span><br><span class="line">            <span class="keyword">if</span> (weight &gt; c)</span><br><span class="line">                c = weight, next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>源码中的 <code>goodness()</code> 函数会计算出一个权重值，它的算法基本思想就是基于进程所剩余的时钟节拍数（时间片），再加上基于进程优先级的权重值。返回值如下：</p><ul><li>-1000 表示不要选择该进程运行</li><li>0 表示时间片用完了，需要重新计算 counters（可能会被选中运行）</li><li>正整数：表示 goodness 值（越大越好）</li><li>+1000 表示实时进程，接下来就要选择它运行</li></ul><p>最后，针对 O(n) 调度器做下总结：</p><ol><li>算法实现非常简单，但是不高效（任务越多，遍历耗费时间越久）</li><li>没有很好的扩展性，多核处理器怎么办？</li><li>对于实时任务调度支持较弱（无论如何作为优先级高的实时任务都需要在遍历完列表后才可以知道）</li></ol><h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><p><a href="https://en.wikipedia.org/wiki/Ingo_Moln%C3%A1r" target="_blank" rel="noopener">Ingo Molnár</a> 大佬在 2.6 版本的内核中加入了全新的调度算法，它能够在常数时间内调度任务，因此被称为 O(1) 调度器。我们来看看它引入的一些新特性：</p><ul><li>全局优先级单位，范围是 0~139，数值越低，优先级越高</li><li><strong>将任务拆分成实时（0~99）和正常（100~139）两部分</strong>。更高优先级任务获得更多时间片</li><li><strong>即刻抢占（early preemption）</strong>。当任务状态变成 <code>TASK_RUNNING</code> 时，内核会检查其优先级是否比当前运行的任务优先级更高，如果是的话，则抢占当前正在运行的任务，切换到该任务</li><li><strong>实时任务使用静态优先级</strong></li><li><strong>普通任务使用使用动态优先级</strong>。任务优先级会在其使用完自己的时间片后重新计算，内核会考虑它过去的行为，决定它的交互性等级。交互型任务更容易得到调度</li></ul><p>O(n) 的调度器会在每个纪元结束后（所有任务的时间片都使用过），才会重新计算任务优先级。而 O(1) 则是在每个任务时间片配额用完后就重新计算优先级。O(1) 调度器为<strong>每个 CPU 维护了两个队列，即 active 和 expired</strong>。active 队列存放的是时间片尚未用完的任务，而 expired 则是时间片已经耗尽的任务。当一个任务的时间片用完后，就会被转到 expired 队列，而且会重新计算它的优先级。<strong>当 active 队列任务全部转移到 expired 队列后，会交换二者（让 active 指向 expired 队列，expired 指向 active 队列）</strong>。可以看到，优先级的计算，队列切换都和任务数量多寡无关，能够在 O(1) 时间复杂度下完成。</p><p>在先前介绍的调度算法中，如果想要取一个优先级最高的任务，还需要遍历整个任务链表才可以。而 O(1) 调度器则很特别，它为每种优先级提供了一个任务链表。所有的可运行任务会被分散在不同优先级队应的链表中。</p><p>接下来看看全新的 <code>runqueue</code> 是怎么定义的吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">runqueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running; <span class="comment">/* 可运行的任务总数（某个 CPU） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> *<span class="title">active</span>;</span> <span class="comment">/* 指向 active 的队列的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> *<span class="title">expired</span>;</span> <span class="comment">/* 指向 expired 的队列的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> <span class="title">arrays</span>[2];</span> <span class="comment">/* 实际存放不同优先级对应的任务链表 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过下面的图可以直观感受下任务队列：<br><img src="https://pic4.zhimg.com/v2-a4e9ffb8e01f5adbb240bd0f3e19991f.jpg" alt=""></p><p>接下来看看 <code>prio_array</code> 是怎么定义的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_active; <span class="comment">/* 列表中的任务总数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bitmap[BITMAP_SIZE]; <span class="comment">/* 位图表示对应优先级链表是否有任务存在 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_PRIO</span>];</span> <span class="comment">/* 任务队列（每种优先级对应一个双向链表） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到，在 <code>prio_array</code> 中存在一个位图，它是用来标记每个 priority 对应的任务链表是否存在任务的。接下来看看为何 O(1) 调度器可以在常数时间找到需要运行的任务：</p><ol><li><strong>常数时间确定优先级</strong>：首先会在位图中查找到第一个设置为 1 的位（总共有 140 bits，从第一个 bit 开始搜索，这样可以保证高优先级的任务先得到机会运行），如果找到了就可以确定哪个优先级有任务，假设找到后的值为 <code>priority</code>；</li><li><strong>常数时间获得下一个任务</strong>：在 <code>queue[priority]</code> 对应的任务链表中提取第一个任务来执行（多个任务会轮转执行）。<br><img src="https://pic1.zhimg.com/v2-5dbbda39ff60d26fd2605ef6970dc468.jpg" alt=""></li></ol><p>好了，是时候总结下 O(1) 调度器的优缺点了：</p><ol><li>设计上要比 O(n) 调度器更加复杂精妙；</li><li>相对来说扩展性更好，性能更优，在任务切换上的开销更小；</li><li>用来标记任务是否为交互类型的算法还是过于复杂，且容易出错。</li></ol><h2 id="Staircase"><a href="#Staircase" class="headerlink" title="Staircase"></a>Staircase</h2><p><em>Staircase Scheduler</em> 是 Con Kolivas 为了改善桌面系统交互应用的响应时间而实现的调度器，但它并非内核官方支持的调度器。它的整体设计思想类似于 <em>Operating Systems: The Three Easy Pieces</em> 中提到的 MLFQ（Multilevel Feedback Queue，多级反馈队列）。</p><p>我们来看下它的设计思想：</p><ol><li>首先，它也是将任务按照优先级放在不同的任务链表中（类似上面的 active 队列）</li><li>调度器每次会从最高优先级的任务链表中获取一个要切换执行的任务，当任务时间片使用完毕后，会将其优先级调低一个等级，直到其优先级降到最低。</li><li>当处于最低优先级的任务用光了时间片后，它会被重新放到更高优先级的任务链表中（这个新的优先级是它之前最高优先级减 1 后的值），同时会获得两倍于之前的时间片</li><li>对于长时间睡眠的任务，会被放到最高优先级任务链表。所以交互式任务可以保持在最高优先级位置，从而保持良好的响应性能；而批处理任务则处于低优先级，但是会获得更多的执行时间。</li></ol><h2 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h2><h3 id="单核调度"><a href="#单核调度" class="headerlink" title="单核调度"></a>单核调度</h3><p>CFS 的全称是 Complete Fair Scheduler，也就是完全公平调度器。它实现了一个基于权重的公平队列算法，从而将 CPU 时间分配给多个任务（每个任务的权重和它的 nice 值有关，nice 值越低，权重值越高）。每个任务都有一个关联的虚拟运行时间 vruntime，它表示一个任务所使用的 CPU 时间除以其优先级得到的值。相同优先级和相同 vruntime 的两个任务实际运行的时间也是相同的，这就意味着 CPU 资源是由它们均分了。为了保证所有任务能够公平推进，每当需要抢占当前任务时，CFS 总会挑选出 <code>vruntime</code> 最小的那个任务运行。</p><p>内核版本在 2.6.38 之前，每个线程（任务）会被当成独立的调度单元，并且和系统中其它线程共享资源，这就意味着一个多线程的应用会比单线程的应用获得更多的资源。之后，CFS 不断改进，目前已经支持将一个应用中的线程打包到 cgroup 结构中，cgroup 的 vruntime 是其中所有线程的 vuntime 之和。然后 CFS 就可以将它的算法应用于cgroup 之间，从而保证公平性。当某个 cgroup 被选中后，其中拥有最小 vruntime 的线程会被执行，从而保证 cgroup 中的线程之间的公平性。cgroup 还可以嵌套，例如 systemd 会自动配置 cgroup 来保证不同用户之间的公平性，然后在用户运行的多个应用之间维持公平性。</p><p>CFS 通过在一定时间内运行调度所有的线程来避免饥饿问题。当运行的 线程数在 8 个及以下时，默认的时间周期是 48ms；而当多于 8 个线程时，时间周期就会随着线程数量而增加（6ms * 线程数，之所以选择 6ms，是为了避免频繁抢占，导致上下文切换频繁切换的开销）。由于 CFS 总是会挑选 vruntime 最小的线程执行，它就需要避免某个线程的 vruntime 太小，以至于其它线程需要等待很久才能得到调度（会有饥饿问题）。所以在实践中，CFS 会保证所有线程之间的 vruntime 之差低于抢占时间（6ms），它是通过如下两点来保证的：</p><ol><li>当线程创建时，它的 vruntime 值等于运行队列中等待执行线程的最大 vruntime；</li><li>当线程从睡眠中唤醒时，它的 vruntime 值会被更新为大于或等于所有待调度线程中最小的 vruntime。使用最小 vruntime 还可以保证频繁睡眠的线程优先被调度，这对于桌面系统非常适合，它会减少交互应用的响应延迟。</li></ol><p>CFS 还引入了启发式调度思想来改善高速缓存利用率。例如，当线程被唤醒时，它会检查该线程的 vruntime 和正在运行的线程 vruntime 之差是否非常显著（临界值是 1ms），如果不是的话，则不会抢占当前正在运行的任务。但是这种做法还是以牺牲调度延迟为代价的，算是一种权衡吧。</p><h3 id="多核负载均衡"><a href="#多核负载均衡" class="headerlink" title="多核负载均衡"></a>多核负载均衡</h3><p>在多核环境中，Linux CFS 会将<em>工作（work）</em>分摊到多个处理器核心中执行。但是这不等同于将线程均分到多个处理器。比如，一个 CPU 密集型的线程和 10 个频繁睡眠的线程可能分别在两个核上执行，其中一个专门执行 CPU 密集型线程；而另一个则处理那 10 个频繁睡眠的线程。</p><p>为了多个处理器上的工作量均衡，CFS 使用了 <code>load</code> 指标来衡量线程和处理器的负载情况。线程的负载和线程的 CPU 平均使用率相关：经常睡眠的线程负载要低于不睡眠的线程负载。类似 vruntime，线程的负载也是线程的优先级加权得到的。而处理器的负载是在该处理器上可运行线程的负载之和。CFS 会尝试均衡处理器的负载。</p><p>CFS 会在线程创建和唤醒时关注处理器的负载情况，调度器首先要决定将任务放在哪个处理器的运行队列中。这里也会涉及到启发式思想，比如，如果 CFS 检查到生产者-消费者模型，那么它会将消费者线程尽可能地分散到机器的多个处理器上，因为多数核心都适合处理唤醒的线程。</p><p>负载均衡还会周期性发生，每隔 4ms，每个处理器都会尝试从其它处理器偷取一些工作。当然，这种 work-stealing 均衡方法还会考虑机器的拓扑结构：处理器会尝试从距离它们「更近」的其它处理器上尝试窃取工作，而非距离「更远」的处理器（如远程 NUMA 节点）。当处理器决定要从其它处理器窃取任务时，它会尝试在二者之间均衡负载，并且会窃取多达 32 个线程。此外，当处理器进入空闲状态时，它也会立刻调用负载均衡器。</p><p>在大型的 NUMA 机器上，CFS 并不会粗暴地比较所有 CPU 的负载，而是以分层的方式进行负载均衡。以一台有两个 NUMA 节点的机器为例，CFS 会先在 NUMA 节点内部的处理器之间进行负载均衡，然后比较 NUMA 节点之间的负载（通过节点内部处理器负载计算得到），再决定要不要在两个节点之间进行负载均衡。如果 NUMA 节点之间的负载差距在 25% 以内，则不会进行负载均衡。总结来说，如果两个处理器（或处理器组）之间的距离越远，那么只有在不平衡性差距越大的情况下才会考虑负载均衡。</p><h3 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h3><p>CFS 引入了<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">红黑树</a>（本质上是一棵半平衡二叉树，对于插入和查找都有 O(log(N)) 的时间复杂度）来维护运行队列，树的节点值是调度单元的 vruntime，拥有最小 vruntime 的节点位于树的最左下边。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/2560px-Red-black_tree_example.svg.png" alt=""></p><p>接下来看看 <code>cfs_rq</code> 数据结构的定义（位于 <code>&lt;kernel/sched/sched.h&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 所有任务的累计权重值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">// 表示该队列中有多少个可运行的任务</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_running;</span><br><span class="line">    <span class="comment">// 运行队列中最小的 vruntime</span></span><br><span class="line">    u64 min_vruntime;</span><br><span class="line">    <span class="comment">// 红黑树的根节点，指向运行任务队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">tasks_timeline</span>;</span></span><br><span class="line">    <span class="comment">// 下一个即将被调度的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span></span><br><span class="line">    <span class="comment">// 指向当前正在运行的调度单元</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CFS 算法实际应用于调度单元（这是一个更通用的抽象，可以是线程、cgroups 等），调度单元数据结构定义如下（位于 <code>&lt;include/linux/sched.h&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 表示调度单元的负载权重（比如该调度单元是一个组，则该值就是该组下所有线程的负载权重的组合）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span> <span class="comment">/* for load-balancing */</span></span><br><span class="line">    <span class="comment">// 表示红黑树的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="comment">// 表示当前调度单元是否位于运行队列</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> on_rq;</span><br><span class="line">    <span class="comment">// 开始执行时间</span></span><br><span class="line">    u64 exec_start;</span><br><span class="line">    <span class="comment">// 总共运行的时间，该值是通过 `update_curr()` 更新的。</span></span><br><span class="line">    u64 sum_exec_runtime;</span><br><span class="line">    <span class="comment">// 基于虚拟时钟计算出该调度单元已运行的时间</span></span><br><span class="line">    u64 vruntime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录之前运行的时间之和</span></span><br><span class="line">    u64 prev_sum_exec_runtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="虚拟时钟"><a href="#虚拟时钟" class="headerlink" title="虚拟时钟"></a>虚拟时钟</h3><p>前面提到的 vruntime 究竟是什么呢？为什么叫作虚拟运行时间呢？接下来就要揭开它的神秘面纱。为了更好地实现公平性，CFS 使用了虚拟时钟来测量一个等待的调度单元在一个<strong>完全公平的处理器</strong>上允许执行的时间。然而，虚拟时钟并没有真实的实现，它只是一个抽象概念。</p><p>我们可以基于真实时间和任务的负载权重来计算出虚拟运行时间，该算法是在 <code>update_cur()</code> 函数中实现的，它会更新调度单元的时间记账信息，以及 CFS 运行队列的 <code>min_vruntime</code>（完整定义位于 <code>&lt;kernel/sched/fair.c&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_curr</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">    u64 now = rq_clock_task(rq_of(cfs_rq));</span><br><span class="line">    u64 delta_exec;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!curr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算出调度单元开始执行时间和当前之间的差值，即真实运行时间</span></span><br><span class="line">    delta_exec = now - curr-&gt;exec_start;</span><br><span class="line">    curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);</span><br><span class="line">    update_min_vruntime(cfs_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u64 <span class="title">calc_delta_fair</span><span class="params">(u64 delta, struct sched_entity *se)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务的优先级是默认的优先级（内部 nice 值是 120），那么虚拟运行时间</span></span><br><span class="line">    <span class="comment">// 就是真实运行时间。否则，会基于 `__calc_delta` 计算出虚拟运行时间。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">        <span class="comment">// 该计算过程基本等同于：</span></span><br><span class="line">        <span class="comment">// delta = delta_exec * NICE_0_LOAD / cur-&gt;load.weight;</span></span><br><span class="line">        delta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);</span><br><span class="line">    <span class="keyword">return</span> delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_min_vruntime</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;curr)</span><br><span class="line">        <span class="comment">// 如果此时有任务在运行，就更新最小运行时间为当前任务的 vruntime</span></span><br><span class="line">        vruntime = cfs_rq-&gt;curr-&gt;vruntime;</span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;rb_leftmost)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获得下一个要运行的调度单元</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = <span class="title">rb_entry</span>(<span class="title">cfs_rq</span>-&gt;<span class="title">rb_leftmost</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">struct</span> <span class="title">sched_entity</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">run_node</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (!cfs_rq-&gt;curr)</span><br><span class="line">            vruntime = se-&gt;vruntime;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保证 min_vruntime 是二者之间较小的那个值</span></span><br><span class="line">            vruntime = min_vruntime(vruntime, se-&gt;vruntime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里之所以去二者之间的最大值，是为了保证 min_vruntime 能够单调增长</span></span><br><span class="line">    <span class="comment">// 可以想想为什么需要这样做？</span></span><br><span class="line">    cfs_rq-&gt;min_vruntime = max_vruntime(cfs_rq-&gt;min_vruntime, vruntime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，来总结下使用虚拟时钟的意义：</p><ul><li>当任务运行时，它的虚拟时间总是会增加，从而保证它会被移动到红黑树的右侧；</li><li>对于高优先级的任务，虚拟时钟的节拍更慢，从而让它移动到红黑树右侧的速度就越慢，因此它们被再次调度的机会就更大些。<br><img src="https://pic3.zhimg.com/v2-bcc1970ab1806342e946bf4e9b6ff1d7.jpg" alt=""></li></ul><h3 id="选择下一个任务"><a href="#选择下一个任务" class="headerlink" title="选择下一个任务"></a>选择下一个任务</h3><p>CFS 可以在红黑树中一直找到最左（leftmost）边的节点作为下一个运行的任务。但是真正实现 <code>__pick_first_entity()</code> 的函数其实并没有真正地执行查找（虽然可以在 O(log(N)) 时间内找到），我们可以看下它的定义（完整定义位于 <code>&lt;kernel/sched/fair.c&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *__<span class="title">pick_first_entity</span>(<span class="title">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 其实这里取的是缓存的 leftmost 节点</span></span><br><span class="line">    <span class="comment">// 所以执行就会更快了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">rb_leftmost</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> rb_entry(left, struct sched_entity, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实时调度器"><a href="#实时调度器" class="headerlink" title="实时调度器"></a>实时调度器</h2><p>Linux 实时任务调度器实现位于 <code>&lt;kernel/sched/rt.c</code>，对于系统而言，实时任务属于贵客，一旦存在实时任务需要调度，那就应当尽可能及时地为它们服务。对于实时任务而言，有两种调度策略存在：</p><ul><li><p><code>SCHED_FIFO</code>: 这个其实就是一个先到先服务的调度算法。这类任务没有时间片限制，它们会一直运行直到阻塞或者主动放弃 CPU，亦或者被更高优先级的实时任务抢占。该类任务总会抢占 <code>SCHED_NORMAL</code> 任务。如果多个任务具有相同的优先级，那它们会以轮询的方式调度（也就是当一个任务完成后，会被放到队列尾部等待下次执行）；</p></li><li><p><code>SCHED_RR</code>: 这种策略类似于 <code>SCHED_FIFO</code>，只是多了时间片限制。相同优先级的任务会以轮询的方式被调度，每个运行的任务都会一直运行，直到其用光自己的时间片，或者被更高优先级的任务抢占。当任务的时间片用光后，它会重新补充能量，并被加入到队列尾部。默认的时间片是 100ms，可以在 <code>&lt;include/linux/sched/rt.h&gt;</code> 找到其定义。</p></li></ul><p>实时任务的优先级是静态的，不会像之前提到的算法，会重新计算任务优先级。用户可以通过 <code>chrt</code> 命令更改任务优先级。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>实时任务有自己的调度单元数据结构（位于 <code>&lt;include/linux/sched.h&gt;</code>），其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> watchdog_stamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> *<span class="title">back</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> *<span class="title">rt_rq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>SCHED_FIFO</code> 的时间片是 0，可以在 <code>&lt;kernel/sched/rt.c&gt;</code> 中看到具体定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sched_rr_timeslice = RR_TIMESLICE;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_rr_interval_rt</span><span class="params">(struct rq *rq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;policy == SCHED_RR)</span><br><span class="line">        <span class="keyword">return</span> sched_rr_timeslice;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">而关于运行队列的定义如下：</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* Real-Time classes' related field in a runqueue: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 所有相同优先级的实时任务都保存在 `active.queue[prio]` 链表中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_nr_running;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span> <span class="comment">/* main runqueue */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is the priority-queue data structure of the RT scheduling class:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* include 1 bit for delimiter */</span></span><br><span class="line">    <span class="comment">// 类似 O(1) 调度器，使用位图来标记对应优先级的链表是否为空</span></span><br><span class="line">    DECLARE_BITMAP(bitmap, MAX_RT_PRIO + <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_RT_PRIO</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>类似于 CFS 中的 <code>update_curr()</code> 函数，<code>update_curr_rt()</code> 函数用来跟踪实时任务的 CPU 占用情况，收集一些统计信息，更新时间片等，但这里使用的是真实时间，而没有虚拟时间的概念。完整定义可以参考 <a href="https://github.com/torvalds/linux/blob/a6ed68d6468bd5a3da78a103344ded1435fed57a/kernel/sched/rt.c#L955" target="_blank" rel="noopener">kernel/sched/rt.c#L955</a>。</p><h2 id="BFS-amp-MuqSS"><a href="#BFS-amp-MuqSS" class="headerlink" title="BFS &amp; MuqSS"></a>BFS &amp; MuqSS</h2><p>关于 BFS 和 MuqSS 的精彩介绍可以参考 <a href="https://mp.weixin.qq.com/s/kI3pFJ3qUgQJ2P_--G3ehQ" target="_blank" rel="noopener">这篇文章</a>，这里不再赘述。<br>总体来说，BFS 是一个适用于桌面或移动设备的调度器，设计地比较简洁，用于改善桌面应用的交互性，减小响应时间，提升用户体验。它采用了全局单任务队列设计，不再让每个 CPU 都有独立的运行队列。虽然使用单个全局队列，需要引入队列锁来保证并发安全性，但是对于桌面系统而言，处理器通常都比较少，锁的开销基本可以忽略。BFS 每次会在任务链表中选择具有最小 virtual deadline 的任务运行。</p><p>MuqSS 是作者后来基于 BFS 改进的一款调度器，同样是用于桌面环境任务调度。它主要解决了 BFS 的两个问题：</p><ol><li>每次需要在对应优先级链表中遍历查找需要执行任务，这个时间复杂度为 O(n)。所以新的调度器引入了跳表来解决该问题，从而将时间复杂度降低到 O(1)。</li><li>全局锁争夺的开销优化，采用 <code>try_lock</code> 替代 <code>lock</code>。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytXicPsWIWNWxe47NbURjISJ8rdLqdPkHHW9vngCa5CojQPoI8s7f3f2V6I1OMBJXB1rbOhlmb6wrg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></li></ol><h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><ul><li>《Linux 设计与实现 第三版》进程调度章节</li><li><a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a></li><li><a href="https://oska874.gitbooks.io/process-scheduling-in-linux/chapter1.html" target="_blank" rel="noopener">Process Scheduling in Linux</a></li><li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">内核文档：CFS Scheduler 设计</a></li><li>Linux 进程与线程：《Linux 系统编程手册 第 28 章及后续》<ul><li>可以关注下和进程线程有关的系统调用</li><li>Pthread 线程是怎么在 Linux 中实现的</li></ul></li><li><a href="https://opensource.com/article/19/2/fair-scheduling-linux" target="_blank" rel="noopener">Linux 公平调度</a><ul><li>对比了传统调度器和 CFS 的区别</li><li>简单介绍了 CFS 的实现</li></ul></li><li><a href="https://www.usenix.org/system/files/conference/atc18/atc18-bouron.pdf" target="_blank" rel="noopener">The Battle of Schedulers: FreeBSD ULE vs Linux CFS</a><ul><li>重点可以看下关于 CFS 的简述 &amp; 负载均衡部分</li><li>可以简单看看 ULE 是的实现原理（interactive, batch queue），为什么可能会有饿死的情况</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/33621500" target="_blank" rel="noopener">NUMA 架构深究</a><ul><li>早期的 x86 是 Universal Memory Arch, UMA 架构</li><li>NUMA 架构出来后，访问不同内存地址，速度是有差别了，和硬件架构有很大关系</li></ul></li><li><a href="https://jin-yang.github.io/post/linux-kernel-scheduler.html" target="_blank" rel="noopener">Kernel 调度系统</a><ul><li>重点关注作者关于 CFS 列出的几个灵魂拷问</li><li>vruntime 在什么时候发生改变？</li><li>vruntime 初始值是怎么设定的？</li></ul></li><li><a href="https://mp.weixin.qq.com/s/kI3pFJ3qUgQJ2P_--G3ehQ" target="_blank" rel="noopener">两个非常有意思的适合桌面使用的 Linux task 调度器: BFS 和 MuqSS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Linux Kernel Development&lt;/em&gt; 一书中，关于 Linux 的进程调度器并没有讲解的很深入，只是提到了 CFS 调度器的基本思想和一些实现细节；并没有 Linux 早期的调度器介绍，以及最近这些年新增的在内核源码树外维护的调度器思想。所以在经过一番搜寻后，看到了这篇论文 &lt;a href=&quot;https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A complete guide to Linux process scheduling&lt;/a&gt;，对 Linux 的调度器历史进行了回顾，并且相对细致地讲解了 CFS 调度器。整体来说，虽然比较啰嗦，但是对于想要知道更多细节的我来说非常适合，所以就有了翻译它的冲动。当然，在学习过程也参考了其它论文。下面开启学习之旅吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="调度器" scheme="http://ifaceless.space/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="CFS" scheme="http://ifaceless.space/tags/CFS/"/>
    
  </entry>
  
  <entry>
    <title>Linux 调度器学习资料整理</title>
    <link href="http://ifaceless.space/2019/11/05/linux-kernel-scheduler-papers/"/>
    <id>http://ifaceless.space/2019/11/05/linux-kernel-scheduler-papers/</id>
    <published>2019-11-05T13:18:35.000Z</published>
    <updated>2019-11-28T09:41:31.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://pic1.zhimg.com/80/v2-43f561d7d0646c34ed8c7bbf6fb52f23_hd.png" alt=""></p><p>系统中的 CPU 数量有限，而用户希望「同时」得到服务的进程（任务）常常会多于可用的 CPU 核数，这时就需要聪明的任务调度器来为我们实现 CPU 虚拟化，让每个进程都能得到服务。调度器需要照顾到任务的响应时间（否则用户会在敲击键盘后等很久，体验很渣），还要保证一定的周转时间（CPU 密集型的任务期望获得更多的连续运行时间，从而利用 CPU 缓存亲和性，频繁的任务切换会导致一些性能损失，尤其是现代系统 TLB miss, Page Fault 惩罚非常严重），同时还不能让某些低优先级的任务饿死。可见调度器是实现多任务的核心，现代操作系统必备。<br><a id="more"></a><br>一直以来，各路 Linux Hackers 都希望能为 Linux 提供这样一个调度器，它能够在桌面系统上有较好的交互性，而在高负载的服务器上有较好的吞吐量。</p><p>以下列举一些学习资料，可以进一步了解！</p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul><li>论文：<a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a>，这篇论文讲得比较好，准备翻译出来以供欣赏</li><li>GitBook: <a href="https://oska874.gitbooks.io/process-scheduling-in-linux/chapter1.html" target="_blank" rel="noopener">Process Scheduling in Linux</a></li><li>内核文档：<a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">Linux scheduler doc, CFS</a></li><li><p>Linux 进程与线程：《Linux 系统编程手册 第 28 章及后续》</p><ul><li>可以关注下和进程线程有关的系统调用</li><li>Pthread 线程是怎么在 Linux 中实现的</li></ul></li><li><p><a href="https://opensource.com/article/19/2/fair-scheduling-linux" target="_blank" rel="noopener">Linux 公平调度</a></p></li><li><p><a href="https://www.usenix.org/system/files/conference/atc18/atc18-bouron.pdf" target="_blank" rel="noopener">The Battle of Schedulers: FreeBSD ULE vs Linux CFS</a></p><ul><li>重点可以看下关于 CFS 的简述 &amp; 负载均衡部分</li><li>可以简单看看 ULE 是的实现原理（interactive, batch queue），为什么可能会有饿死的情况</li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/33621500" target="_blank" rel="noopener">NUMA 架构深究</a></p><ul><li>早期的 x86 是 Universal Memory Arch, UMA 架构</li><li>NUMA 架构出来后，访问不同内存地址，速度是有差别了，和硬件架构有很大关系</li></ul></li><li><p><a href="https://jin-yang.github.io/post/linux-kernel-scheduler.html" target="_blank" rel="noopener">Kernel 调度系统</a></p><ul><li>重点关注作者关于 CFS 列出的几个灵魂拷问</li><li>vruntime 在什么时候发生改变？</li><li>vruntime 初始值是怎么设定的？</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-43f561d7d0646c34ed8c7bbf6fb52f23_hd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;系统中的 CPU 数量有限，而用户希望「同时」得到服务的进程（任务）常常会多于可用的 CPU 核数，这时就需要聪明的任务调度器来为我们实现 CPU 虚拟化，让每个进程都能得到服务。调度器需要照顾到任务的响应时间（否则用户会在敲击键盘后等很久，体验很渣），还要保证一定的周转时间（CPU 密集型的任务期望获得更多的连续运行时间，从而利用 CPU 缓存亲和性，频繁的任务切换会导致一些性能损失，尤其是现代系统 TLB miss, Page Fault 惩罚非常严重），同时还不能让某些低优先级的任务饿死。可见调度器是实现多任务的核心，现代操作系统必备。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="调度器" scheme="http://ifaceless.space/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="CFS" scheme="http://ifaceless.space/tags/CFS/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel Development 学习与总结</title>
    <link href="http://ifaceless.space/2019/10/30/linux-kernel-dev-notes/"/>
    <id>http://ifaceless.space/2019/10/30/linux-kernel-dev-notes/</id>
    <published>2019-10-30T09:47:22.000Z</published>
    <updated>2019-11-28T09:41:31.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近抽时间把 <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener"><em>Operating Systems: Three Easy Pieces</em></a> 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（<em>Linux Kernel Development</em>）后找到想要的答案。当然，在学习中也针对很多部分搜集了不少学习资料，整理在文后，方便加深理解。<br><a id="more"></a><br>在学习之前，思考了一些问题，可以在学习中探索这些问题的答案：</p><ol><li>Linux 中进程、线程是如何实现的？各种调度策略是什么样的？又是怎么实现的呢？</li><li>并发问题肯定需要注意，Linux 中如何应对竞态条件 &amp; 数据竞争呢？各种常见的同步原语又是如何实现的？</li><li>Linux 的内存虚拟化是如何实现的？内存布局？虚拟地址空间？</li><li>文件系统有很多，操作系统是怎么进行抽象，并对用户提供一致优雅的系统调用接口的呢？</li><li>Linux 内核中有哪些非常经典的算法和数据结构的应用？它们使用场景是什么？怎么实现的呢？</li></ol><h1 id="Linux-内核简介"><a href="#Linux-内核简介" class="headerlink" title="Linux 内核简介"></a>Linux 内核简介</h1><p><img src="https://pic4.zhimg.com/80/v2-e0c1aced72034fd29160b2a0dbc73fa5_r.png" alt=""></p><p>说到 Linux，就不得不提到它的祖先 Unix 系统。Unix 在 1970 年左右被 Ken Thompson 首先在一台 PDP-7 机型上实现，而后移植到 PDP-11 机器上，1973 年它被使用 C 语言重写，提供了更加强大的可移植性。</p><p>经过多年发展，Unix 系统成为了一个强大、健壮且稳定的操作系统。其强大的根本原因如下：</p><ol><li>简洁，仅提供数百个设计目标明确的系统调用；</li><li>所有的东西都被当作文件看待</li><li>很强的移植能力</li><li>进程创建非常迅速，拥有独特的 <code>fork()</code> 系统调用</li><li>拥有简单且稳定的进程间通信原语</li></ol><p>Linux 是类 Unix 系统，它的实现和 Unix 也有一些大相径庭的方面，但是它依然继承了 Unix 的设计目标，保证了 API 的一致性（有品位的程序员都应该要学习这一思想）。</p><p>Linux 词汇一般用来指代内核。它的基础包括：</p><ol><li>内核</li><li>C 库</li><li>工具集</li><li>系统的基本工具，如 Shell</li></ol><p>什么是操作系统？宽泛的操作系统是指整个系统中负责完成最基本功能和系统管理的部分，包括<strong>内核、设备驱动、启动引导程序、命令行 Shell 或用户界面、文件管理工具和系统工具</strong>。内核则是那个最亮的仔，它通常由如下几个重要部分组成：</p><ol><li>中断服务</li><li>任务调度程序</li><li>内存管理程序</li><li>网络</li><li>进程间通信等系统服务</li></ol><p>Linux 的中断服务是不在进程上下文执行的，而是在一个与所有进程无关、专门的中断上下文执行。这样可以保证第一时间能够响应和处理中断请求，然后快速退出。</p><p>处理器在任意时间点活动可概括为以下三种之一：</p><ol><li>运行在用户空间，执行用户进程</li><li>运行在内核空间，处于进程上下文，代表某个特定的进程执行（如某个系统调用）</li><li>运行在内核空间，处于中断上下文，与进程无关，处理特定的中断</li></ol><h2 id="微内核和宏内核"><a href="#微内核和宏内核" class="headerlink" title="微内核和宏内核"></a>微内核和宏内核</h2><p>这个是比较有趣的历史了，操作系统设计有两大主要阵营：微内核和宏内核。</p><p>微内核的功能划分成多个独立的过程，每个过程都是一个服务（C/S 模型，服务与内核交互）。系统采用 IPC 禁止互通消息，互换「服务」。服务的独立性可以避免一个服务失败殃及其它服务。模块化设计也非常适合热插拔。但是缺点就是 IPC 的开销多于函数调用（类比微服务的网络开销和在本地调用函数的开销）。</p><p>宏内核则是实用主义者喜欢的设计，它是比较简单的设计，整体上就是一个单独的过程，运行在一个单独的地址空间。内核之间的通信微不足道，性能高。</p><p>Linux 自然是宏内核设计，Linux 内核运行在单独的内核地址空间上。同时它也采纳了微内核的精华，使它成为模块化的、多线程的以及内核本身可调度的操作系统。</p><h2 id="与传统-Unix-区别"><a href="#与传统-Unix-区别" class="headerlink" title="与传统 Unix 区别"></a>与传统 Unix 区别</h2><ol><li>支持动态加载内核模块（这个不是微内核宣称的好处吗？咱也有）</li><li>支持对称多处理机制（SMP）</li><li>内核可以抢占（preemptive）：任务可以有优先级</li><li>对多线程的支持很特别：内核不区分线程和一般的进程，对于内核而言，所有的进程都一样，只是其中的一些共享资源而已</li><li>具有设备类的面向对象的设备模型、热插拔事件，用户空间的设备文件系统（sysfs）</li><li>忽略了一些拙劣特性</li><li>自由：任何改变都必须要能通过简洁的设计及正确可靠的实现来解决现实中确实存在的问题</li></ol><h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p><code>&lt;主版本&gt;.&lt;从版本&gt;.&lt;修订&gt;[.&lt;稳定版本号&gt;]</code>，其中<strong>从版本号</strong>为偶数，则为稳定版本，否则为开发版本。</p><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以使用的配置方式如下：</p><ol><li><code>make config</code></li><li><code>make menuconfig1</code></li><li><code>make gconfig</code></li><li>默认配置：<code>make defconfig</code></li></ol><p>验证和更新配置：<code>make oldconfig</code></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol><li>直接编译：<code>make</code></li><li>导出不关心的 info：<code>make &gt;/dev/null</code></li><li>指定并行编译数量：<code>make -j4 &gt;/dev/null</code></li></ol><h2 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h2><ol><li>不能使用标准 C 库</li><li><p>必须使用 GNU C（需要用到它的一些扩展特性）</p><ol><li><code>inline</code>：通常将对时间要求比较高，函数本身比较短的定义成内联函数。在内核中，为了类型安全和易读性，优先使用 inline 函数，而非复杂的宏</li><li>内联编译：支持使用 <code>asm()</code> 嵌入汇编代码</li><li>分支声明：可以使用 <code>likely()</code> 和 <code>unlikely()</code> 声明分支是否经常出现或很少出现，指导编译器进行优化（要搞清楚，否则优化反而变成了拖累）</li></ol></li><li><p>缺乏像用户空间中的内存保护机制</p><ol><li>内核中发生内存错误会导致 oops，内核可能会死掉</li><li>内核中的内存是<strong>不分页</strong>的，每用掉一个字节，物理内存就减少一个字节</li></ol></li><li><p>难以执行浮点数计算</p><ol><li>不能像用户空间执行浮点数计算那样，可以通过 trap 的方式将整数模式转换到浮点数模式计算</li><li>内核不能完美支持浮点数计算，本身也无法陷入。非要执行的话，就需要手动保存和恢复浮点寄存器，非常麻烦</li></ol></li><li><p>内核给每个进程<strong>只有一个很小的定长堆栈</strong></p><ol><li>用户空间的栈可以动态增长，可支持非常大的数据结构</li><li>内核栈的大小和体系结构有关（如 x86 可以是 4KB/8KB）</li><li>历史上来说，内核栈大小是两页，32 位是 8KB，64 位是 16KB；每个处理器都有自己的栈</li></ol></li><li><p>由于要支持异步中断、抢占和 SMP，时刻需要注意并发安全和同步</p></li><li>考虑可移植性<ol><li>保持字节序</li><li>64 位对齐</li><li>不假定字长和页面长度</li></ol></li></ol><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><ol><li>内核把进程的列表存放在 task list 双向链表中，每个 entry 的类型是 <code>task_struct</code>，被称为 <code>process descriptor</code></li><li>通过 slab（更新的应该是 SLUB） 分配器分配 task_struct 结构体（对象复用和缓存着色），每个任务的 <code>thread_info</code> 位于内核栈的尾端，其中包含指向 <code>task_struct</code> 的指针及其它信息</li><li>进程通过 PID 进行区分，其值存放在 <code>process descriptor</code> 中。由于进程处理代码需要频繁访问 <code>task_struct</code> 信息，所以在 PowerPC 等机器上，有专门的寄存器存储了相应的指针；而在 x86 体系下，则是利用内核栈尾创建的 <code>thread_info</code>，并借助偏移计算间接查找 <code>task_struct</code> 结构体</li><li><p>进程状态：</p><ol><li>TASK_RUNNING</li><li>TASK_INTERRUPTABLE</li><li>TASK_UNINTERRUPTABLE</li><li>__TASK_TRACED: 被其它进程跟踪的进程（如 ptrace 对调试程序进行跟踪）</li><li><p>__TASK_STOPPED: 进程停止执行，没有投入运行也无法投入运行</p><p><img src="https://pic2.zhimg.com/80/v2-ad2075f3f165ab1ab983605446be9b28_r.png" alt=""></p></li></ol></li><li><p>所有的进程都是 PID 为 1 的 init 进程的后代，init 进程的描述符是作为 init_task 静态分配的（比较特殊）</p></li><li><p>Unix 系统进程创建：</p><ol><li>通过 <code>fork()</code> 拷贝当前进程创建一个子进程（区别父进程：有新的 PID，有某些资源和统计量）</li><li><code>exec()</code> 函数负责读取可执行文件并将其载入地址空间开始运行</li></ol></li><li><p>写时拷贝：内核并非开始就复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝，只有在需要写入的时候，数据才会被复制，从而拥有各自的拷贝。<code>fork()</code> 实际开销：复制父进程的页表，给子进程创建唯一的进程描述符</p></li><li>Linux 中的 <code>fork()</code> 和 <code>vfork()</code> 都是通过 <code>clone()</code> 系统调用实现的。<code>vfork()</code> 的特点是：不拷贝父进程的页表，且子进程作为父进程的单独线程在它的地址空间执行，父进程阻塞直到子进程退出或执行 <code>exec()</code></li><li><p>Linux 中的线程实现：</p><ol><li>从内核角度看，没有线程的概念，所有的线程都当作进程看待，只是与其它进程共享某些资源。每个线程都拥有属于自己的 task_struct</li><li>其它系统中，线程被抽象成一种耗费资源较少的资源，运行迅速的执行单元</li><li>通过 <code>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</code> 创建线程</li><li>对比 <code>fork()</code> 实现：<code>clone(SIGCHLD, 0)</code></li><li>对比 <code>vfork()</code> 实现：<code>clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)</code></li></ol></li><li><p>内核线程：</p><ol><li>内核通常需要在后台执行一些操作，这些任务可通过 kernel thread 完成。这种是运行在内核空间的标准进程</li><li>内核线程没有独立的地址空间，可被调度，可被抢占</li></ol></li><li><p>进程终结：</p><ol><li>通常通过 <code>do_exit()</code> 完成退出，期间会释放相关的资源，最终将进程状态设置为 <code>EXIT_ZOMBIE</code>，但是此时的内核栈、thread_info 和 task_struct 结构体还是存在的，从而给父进程提供信息</li><li>父进程获得已终结的子进程信息后（父进程可通过 <code>wait()</code> 系统调用收集信息），或者通知内核它不关注这些信息，才会释放剩余的内存空间</li></ol></li><li><p>孤儿进程：</p><ol><li>退出时永远处于僵死状态，白白浪费内存</li><li>解决办法就是在当前线程组寻找某个线程作为父亲，实在不行，就让 init 接盘</li></ol></li></ol><h2 id="调度进程"><a href="#调度进程" class="headerlink" title="调度进程"></a>调度进程</h2><ol><li><p>多任务系统分为两类：</p><ol><li>非抢占式多任务（cooperative multitasking）</li><li>抢占式多任务（preemptive multitasking）</li></ol></li><li><p>进程调度策略会关心进程的优先级、时间片</p></li><li>Linux 中的进程分为普通进程和实时进程，其中前者的优先级在 (-20, +19），而后者则是 (0, 99)。此外，实时进程的优先级总是高于普通进程优先级的，所以普通进程的优先级映射过来就是 (100, 139)</li><li>Linux 中可以通过 <code>nice</code> 调整进程的优先级，越小的值拥有越高的权重；反之，则权重越低（体现在时间片上）</li></ol><h3 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h3><ol><li>Linux 2.6 内核引入了 CFS 调度器（位于 <code>sched/fair.c</code>）作为普通进程的调度器，它是一个近乎完美的公平调度器（权衡周转时间和响应时间）。并非采用时间片进行分配，而是给进程分配了处理器使用的比重，从而确保进程调度中能够有恒定的公平性，从而将切换频率置于不断变动中</li><li>CFS 基于一个简单的理念：进程调度的效果应该等同于系统拥有一个完美的多任务处理器，每个进程都能获得 1/n_running 处理器时间</li><li>CFS 允许每个进程运行一段时间，循环轮转，总是选择 vruntime 最小的进程作为下一个执行。也就是说，是通过所有可运行经常总数为基础来计算出进程应该运行多久，而非依靠 nice 值来计算时间片（传统的做法就是这种）</li><li>调度器实现概要：<ol><li><code>sched_entity</code> 结构体跟踪运行记账（其中包含 vruntime）</li><li>所有可运行的进程都位于一棵黑红树中（O(logN) 时间复杂度查找），并且每次都会从树的最左叶子节点上（leftmost）找到 vruntime 最小的那个进程运行（实时上，这个值是提前缓存好的）</li><li>调度器入口处会找到最高优先级的调度类，然后获取到谁是下一个该运行的进程</li><li>睡眠：进程会把自己标记成休眠状态，从可执行红黑树中溢出，并放入等待队列，调用 <code>schedule()</code> 执行一个其他进程</li><li>唤醒：进程被设置为可执行状态，从等待队列移除，添加到可执行红黑树</li></ol></li><li>CFS 实现了如下几种调度策略：<ol><li>SCHED_NORMAL（以前叫做 SCHED_OTHER）：用于普通任务调度</li><li>SCHED_BATCH：并非像普通任务那样被频繁抢占，会尽可能允许任务运行足够长时间，从而利用上 CPU 亲和性以及更好地复用缓存</li><li>SCHED_IDLE：这种任务优先级比 nice 19 还要低</li></ol></li></ol><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ol><li>用户抢占（检查 need_resched 标识符）：从系统调用返回用户空间时；从中断处理返回用户空间时</li><li>内核抢占（thread_info 中存在 preemt_count 计数器，表示有没有锁被持有）：就是调度程序能够在内核任务执行期间被执行<ol><li>只要重新调度是安全的（没有持有锁），内核就可以在任何时间抢占正在执行的任务</li><li>内核抢占时机：<ol><li>中断处理程序正在执行，且返回内核空间之前</li><li>内核代码再次具有可抢占性时</li><li>内核任务显式调用 <code>schedule()</code></li><li>内核中的任务阻塞（此时会导致调用 <code>schedule()</code>）</li></ol></li></ol></li></ol><h3 id="实时调度器"><a href="#实时调度器" class="headerlink" title="实时调度器"></a>实时调度器</h3><ol><li>实时调度器是在 <code>sched/rt.c</code> 中实现的，它使用了 100 个运行队列（对应 1~99 任务优先级），实现了 SCHED_FIFO 和 SCHED_RR 策略。</li><li><p>SCHED_FIFO:</p><ol><li>简单的先入先出调度算法，不依赖时间片</li><li>该级别任务比 SCHED_NORMAL 级别的进程先得到调度</li><li>一旦任务处于执行期间，就会一直执行下去；只有更高优先级的 SCHED_FIFO/SCHED_RR 任务才可以抢占</li></ol></li><li><p>SCHED_RR:</p><ol><li>类似 FIFO，但是每个任务会有分配的时间片，时间片耗尽后就要换其它任务执行</li><li>对于 FIFO 进程，高优先级始终抢占低优先级进程；低优先级进程不能抢占 SCHED_RR 进程，即便其耗尽了时间片</li></ol></li><li><p>Linux 提供的是软实时工作方式，尽力使得进程能够在限定的时间到来前执行，但内核不保证总能满足这些进程的要求</p></li></ol><h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>调度器类需要实现一些 hooks，这样可以在需要的时候做合适的操作。部分 hooks 如下：</p><ul><li><code>enqueue_task</code></li><li><code>dequeue_task</code></li><li><code>yield_task</code></li><li><code>check_preempt_cur</code></li><li><code>pick_next_task</code></li><li><code>set_curr_task</code></li><li><code>task_tick</code></li></ul><h3 id="调度相关的-syscall"><a href="#调度相关的-syscall" class="headerlink" title="调度相关的 syscall"></a>调度相关的 syscall</h3><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>nice()</td><td>设置进程的 nice 值</td></tr><tr><td>sched_setscheduler()</td><td>设置调度策略</td></tr><tr><td>sched_getscheduler()</td><td>获取调度策略</td></tr><tr><td>sched_setparam()</td><td>设置实时优先级</td></tr><tr><td>sched_getparam()</td><td></td></tr><tr><td>sched_rr_get_interval()</td><td>时间片值</td></tr><tr><td>sched_setaffinity()</td><td>设置处理器亲和力</td></tr><tr><td>sched_getaffinity()</td><td>获取进程处理器亲和力</td></tr><tr><td>shced_yield()</td><td>暂时让出处理器</td></tr></tbody></table><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>众所周知，进程是在操作系统提供的用户空间运行的，而如果需要打开文件等操作，需要通过系统调用，陷入到内核态，由操作系统代替完成和硬件的交互，从而为进程提供服务。所以说，系统调用时在用户空间和进程和硬件设备之间的一个中间层。这个中间层的主要作用如下：</p><ol><li>为用户空间提供硬件接口抽象</li><li>系统调用保证系统的安全和稳定</li><li>操作系统可以掌控进程的硬件访问意图，并且代劳</li></ol><p>那么系统调用又是如何实现的呢？一句话总结为：<strong>当系统调用执行时，会陷入到内核，传递系统调用号和参数，执行正确的系统调用函数，并且把返回值带回用户空间。</strong>可见，系统调用非常特殊，完全不同于常规的函数调用，看起来非常 Hack。</p><p>接下来，通过几个问题，加深对上述描述的理解：</p><ol><li><strong>如何陷入到内核？</strong>通过软中断的方式实现，通过引发一个异常触发系统切换到内核态执行异常处理程序。</li><li><strong>什么是系统调用号？</strong>在 Linux 中，每个系统调用都被赋予了一个编号，进程其实是通过系统调用号而不是名称来告知内核自己中意哪个系统调用的。</li><li><strong>如何传递系统调用号？</strong>通过寄存器传递，在 x86 中，就是将系统调用号放在 eax 寄存器传递给内核的。</li><li><strong>参数是如何传递的？</strong>    <ol><li>第一种方式就是将参数放在寄存器中，一般来说系统调用参数不会很多。在 x86 中，可以用 ebx, ecx, edx, esi 和 edi 按顺序存放五个参数。</li><li>第二种方式就是将参数存放在用户空间内存中，并将参数指针存放在寄存器中。这种是为了应付参数超过 6 个情况。</li></ol></li><li><strong>返回值如何带给用户空间？</strong>当然也是通过寄存器来传递的，在 x86 中，可以使用 eax 寄存器。</li></ol><h1 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h1><p><img src="https://pic1.zhimg.com/80/v2-2bbaf34ff51ed6c19c0390d1fd118b40_hd.png" alt="内核数据结构"></p><p>Linux 内核链表实现独树一帜。它是将链表塞入到数据结构，而非常规的那种在数据结构中塞入链表。</p><p>可以看下对比就知道为何特别了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规定义方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux 内核链表定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 所有的 node 形成链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通用的链表操作就可以基于 <code>struct list_head</code> 来实现了。那如何和根据链表指针获得对应的 <code>node</code> 呢？答案是通过 <code>container_of()</code> 宏，实际上 C 语言中，一个给定结构体中的变量偏移在编译时就已经确定了，所以可以借此获得父结构中的任意变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(ptr, type, member) (&#123; \</span><br><span class="line">    const typeof( ((type *)0)-&gt;member) *__mptr = (ptr); \</span><br><span class="line">    (type *)( (char *)__mptr - offsetof(type, member) );&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h1><p><img src="https://pic4.zhimg.com/80/v2-78cb6999358bdd22b1a00c221f1d606e_r.png" alt=""></p><p>中断是各种硬件设备与处理器协同高效工作的方式之一。处理器执行指令的速度非常快，而一些外部设备则会慢很多；为了能够保证 CPU 不浪费时间轮询设备状态，而降低利用率，所以需要中断机制来通知 CPU。当处理器接收到中断后，会去执行已注册的相关中断处理程序。</p><p>需要注意的是，中断和前面提到的异常（Fault）是不同的：</p><ol><li>中断通常是异步发生的，不考虑时钟同步；</li><li>异常则必须与处理器时钟同步，所以也被称为同步中断（如除 0 错误、缺页）。</li></ol><p>Linux 中对于中断的响应和处理分成<strong>上半部</strong>和<strong>下半部</strong>。其中上半部会在接收到中断信号后快速完成必要工作的（有严格的时限），而更加繁重的任务则会在下半部执行。在上半部需要快速执行，且无法睡眠；但下半部则没有这样的限制。</p><h2 id="无须重入"><a href="#无须重入" class="headerlink" title="无须重入"></a>无须重入</h2><p>Linux 中的中断处理不用考虑重入，因为当给定中断处理程序在执行时，对应中断线在所有处理器上被屏蔽，避免同一中断线接收另外的中断。这样做简化了中断处理程序的编写。</p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>所谓的中断上下文（interrupt context），就是在执行中断处理程序时，内核所处的上下文。中断上下文和进程上下文没有半毛钱关系，我们可以把它和进程上下文进行一番对比：</p><table><thead><tr><th>中断上下文</th><th>进程上下文</th></tr></thead><tbody><tr><td>执行中断处理程序时，内核所处的上下文</td><td>内核代表进程执行（系统调用、运行内核线程）时，所处的操作模式</td></tr><tr><td>与进程无瓜，与 current 宏无瓜</td><td>可通过 current 宏关联当前进程</td></tr><tr><td>没有后备进程，无法睡眠，也不能调用会导致睡眠的函数</td><td>可睡眠，可调用调度程序</td></tr><tr><td>有严格的执行时限</td><td>没有非常严格的要求</td></tr></tbody></table><h2 id="下半部及推后执行的工作"><a href="#下半部及推后执行的工作" class="headerlink" title="下半部及推后执行的工作"></a>下半部及推后执行的工作</h2><p>下半部就是执行和中断处理相关，但是中断处理程序中不会执行的工作。引入下半部的目的就是让中断处理程序尽可能地简短、快速，避免屏蔽中断太久，导致系统的响应能力和性能受到影响；而比较繁重的工作可以在下半部执行。</p><p>下半部主要实现方式：</p><ol><li><strong>软中断</strong><ol><li>对于时间要求严格，且能自己高效完成加锁的工作，可使用软中断（如网络、SCSI）</li><li>软中断执行期间，允许响应中断，但它自身<strong>不能睡眠</strong></li></ol></li><li><strong>tasklet</strong><ol><li>基于软中断实现，同一个处理程序的多个实例不能再多个处理器同时运行</li><li>用途广泛，接口简单，性能不错</li><li>不能睡眠</li></ol></li><li><strong>工作队列</strong>中的工作可以交给内核线程推后执行（会在进程上下文执行），可以利用进程上下文的优势，且可以重新调度和睡眠</li></ol><h1 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h1><p>在进行内核编程时，时刻需要注意并发带来的问题，需要能够正确识别临界区，正确加锁、解锁，保证关键数据结构不被错误修改。那么有哪些情况能造成并发问题呢？</p><ol><li><strong>中断</strong>：异步发生，会中断当前正在执行的代码</li><li><strong>软中断和 tasklet</strong>：内核会在任意时刻唤醒软中断和 tasklet，打断当前正在执行的代码</li><li><strong>内核抢占</strong>：内核中的任务可能被其它任务抢占</li><li><strong>睡眠及与用户空间同步</strong>：在内核中执行的进程可能会睡眠，从而导致调度程序被唤醒，并运行新的用户进程</li><li><strong>SMP</strong>：多个处理器会并行执行</li></ol><p><img src="https://pic3.zhimg.com/80/v2-de0df74c2c0f79723ab558d3b2727e71.png" alt=""></p><h1 id="定时器和时间管理"><a href="#定时器和时间管理" class="headerlink" title="定时器和时间管理"></a>定时器和时间管理</h1><p>内核需要在硬件（RTC 和 Timer）的帮助下才能计算和管理时间，内核通过<strong>已知的</strong>（这个时钟周期是可编程的，可确定的）时钟中断间隔来计算 wall time 和 jiffies（系统启动以来的节拍总数）。那么，在时钟中断发生时究竟会做哪些工作呢？以下给出一些会周期执行的工作：</p><ol><li>更新系统运行时间和实际时间</li><li>对于 SMP 系统，需要均衡各处理器上的任务队列，如果运行队列负载不均衡，需要尽量让它们均衡</li><li>检查当前进程是否用尽了自己的时间片，如果时，则重新进行调度</li><li>运行超时的动态定时器</li><li>更新资源消耗和处理器时间统计值</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>内核是把物理内存分页管理的，也就是说页（page）是最基本的管理单元。MMU 也是以页大小为单位转换虚拟地址到硬件地址的。不同的体系结构，页大小不同，一般 32 位系统是 4KB，64 位系统是 8KB。</p><h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>因为硬件存在限制，内核无法对所有的页一视同仁。因此需要把页划分成不同的区（zone），内核需要处理如下因为硬件缺陷而引起的内存寻址问题：</p><ol><li>一些硬件只能用特定的内存地址执行 DMA 操作</li><li>一些体系结构的内存物理寻址范围比虚拟地址范围大</li></ol><p>内核的分区有四种：</p><ol><li><strong>ZONE_DMA</strong>：可执行 DMA 操作的页集合</li><li>ZONE_DMA32：同上，但仅限于 32 位设备</li><li><strong>ZONE_NORMAL</strong>：能够正常映射的页</li><li>ZONE_HIGHMEM：高端内存区域，其中的页不能永久映射到内核地址空间（这里限于 32 位地址空间，64 位就不会有问题了）</li></ol><h2 id="页申请和释放"><a href="#页申请和释放" class="headerlink" title="页申请和释放"></a>页申请和释放</h2><ol><li><code>alloc_page(gfp_mask)</code>：只分配一页，返回指向页结构的指针</li><li><code>alloc_pages(gfp_mask, order)</code>：分配 2^order 个连续页</li><li><code>__get_free_page(gfp_mask)</code>：只分配一页，返回指向其逻辑地址的指针</li><li><code>__get_free_pages(gfp_mask, order)</code>：分配 2^order 个连续物理页，返回逻辑地址指针</li><li><code>get_zeroed_page(gfp_mask)</code>：只分配一页，且填充 0 ，返回逻辑地址指针</li><li><code>__free_pages(struct page *page, unsinged int order)</code></li><li><code>free_pages(unsigned long addr, unsinged int order)</code></li><li><code>free_page(unsigned long addr)</code></li></ol><h2 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h2><p><code>void *kmalloc(size_t size, gfp_t flags)</code>，<code>kmalloc()</code> 类似于 <code>malloc()</code>，可以获得指定字节大小的内核内存，它分配得到的页的物理地址是连续的，所以虚拟地址也是连续的。<br><code>void kfree(const void *ptr)</code> 释放分配的内存空间</p><p>关于标记位，常用的是 GFP_KERNEL，允许睡眠，用于进程上下文空间；另外的 GFP_ATOMIC，则不可以睡眠，可用于进程上下文、中断处理程序、软中断、tasklet。</p><h2 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h2><p><code>vmalloc()</code> 类似 <code>kmalloc()</code>，不同的是，它分配的内存虚拟地址虽然是连续的，但是实际的物理地址无需连续。它通过分配非连续的物理内存，再「修正」页表，从而把内存映射到逻辑地址空间连续的区域。它需要专门的页表来完成连续虚拟地址到实际非连续物理地址的映射，开销较大，且容易引起 TLB 抖动，通常在内核中更倾向于使用 <code>kmalloc()</code>。</p><h2 id="slab-层"><a href="#slab-层" class="headerlink" title="slab 层"></a>slab 层</h2><p>slab 层充当通用数据结构的缓存层的角色，它会为不同的对象划分成不同的高速缓存组，每组存放不同类型的对象。比如，存放 task_struct 和 inode 就分属于不同的组。kmalloc() 也是基于 slab 层之上，使用了一组通用高速缓存。</p><p>slab 分配器引入的目的：</p><ol><li>避免频繁使用的对象需要频繁分配和释放，降低开销</li><li>频繁分配回收容易导致内存碎片，减少碎片问题</li><li>提高性能</li><li>部分缓存专属于某个处理器时，可以实现无锁分配和释放（tcmalloc）</li></ol><p><img src="https://pic1.zhimg.com/80/v2-1540217805cb1d2ee083d293209bbbaf_r.png" alt=""></p><h1 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h1><p>VFS 是 Linux 提供的一个文件系统抽象层，涵盖了任何文件系统的常用功能集和行为，从而支持各种实际的文件系统（如 NTFS, FAT, EXT4）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户空间 write() -&gt; VFS sys_write() -&gt; 文件系统的写方法 -&gt; 存储设备</span><br></pre></td></tr></table></figure></p><p>Unix 文件系统传统抽象概念：File, DirectoryEntry, Index Node 和 Mount Point。Unix 文件的特点是面向字节流抽象设计的，具有简单、灵活的特性。在 Unix 中，目录也是普通文件，其列出了包含在目录中所有文件。</p><p>VFS 中的主要对象：</p><ol><li>超级块对象，代表具体已安装的文件系统</li><li>索引节点对象，代表一个具体的文件</li><li>目录项对象，代表一个目录项，是路径的组成部分</li><li>文件对象，代表由进程打开的文件（其实它会指向目录项对象，而目录项对象才是真正表示已打开的实际文件，因为其中包含了指向 inode 的指针）</li></ol><h1 id="块-I-O"><a href="#块-I-O" class="headerlink" title="块 I/O"></a>块 I/O</h1><p>Linux 中，设备分为三类：</p><ol><li><strong>块设备</strong>：支持随机访问固定大小的数据块，如硬盘、闪存</li><li><strong>字符设备</strong>：以字符流的形式被访问，如键盘</li><li><strong>网络设备</strong></li></ol><p>需要注意的是，针对块设备的请求会被操作系统挂起在 I/O 请求队列上，并且由 I/O 调度程序来管理请求队列。它会决定请求队列中的请求<strong>如何排序</strong>，以及<strong>何时</strong>发送到具体的块设备。之所以这么做，就是期望借助 I/O 调度程序，对请求进行<strong>合并</strong>和<strong>排序</strong>，从而有效提高系统的整体性能（也可能造成某些请求得不到公平对待，甚至出现饥饿的情况）。以下记录的是 Linux 中已经实现的几种 I/O 调度算法：</p><ol><li><p><strong>Linus 电梯</strong></p><ol><li>支持向前和向后合并（通常都是这种居多）</li><li>有较好的全局吞吐量</li><li>会发生请求饥饿问题</li></ol></li><li><p><strong>最终期限（deadline） I/O 调度</strong></p><ol><li>降低了系统的全局吞吐量</li><li>读请求超时 500ms，写请求超时 5s，超时必然得到服务，避免长时间饥饿的问题</li></ol></li><li><p><strong>预测（anticipatory） I/O 调度</strong></p><ol><li>目标是保持较好的读响应同时，提供良好的全局吞吐量。视图减少在进行 I/O 操作期间，处理新到的读请求带来的寻址数量</li><li>请求提交后不会直接返回处理其它请求，而会空闲片刻（几毫秒），等待应用提交其它读请求</li></ol></li><li><p><strong>完全公平排队 I/O 调度（CFQ）</strong></p><ol><li>为特殊工作负载的场景设计，每个进程都有自己的请求队列</li><li>以时间片轮转调度队列，处理队列中的请求</li></ol></li></ol><h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>现代操作系统通过采用虚拟内存技术，为每个进程提供了独立的地址空间，从而给每个进程营造了独享内存的假象，这是内存虚拟化的重要机制。需要注意的是，现代采用虚拟内存的系统通常都使用平坦地址空间，而非分段式的内存模式。</p><p>值得注意的是，内存地址空间会根据需要划分成不同的区域。内核可以给进程地址空间动态添加或减少内存区域。每个进程只能访问有效内存区域内的内存地址，每个内存区域会包含权限等属性。<strong>进程中任意有效地址只能位于唯一的区域，且这些区域不能相互覆盖</strong>。</p><p>内存区域可以包含各种内存对象：</p><ol><li>可执行文件代码的内存映射，text section</li><li>可执行文件已初始化全局变量的内存映射，data section</li><li>包含未初始化的全局变量，BSS 段的零页的内存映射</li><li>进程用户空间栈的零页内存映射</li><li>每个一个诸如 C 库或动态连接程序等共享的  text section, data section 和 bss 也被载入到进程地址空间</li><li>内存映射文件</li><li>共享内存段</li><li>匿名映射，如 malloc() 分配的内存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mm_struct -&gt; vm_area_struct</span><br></pre></td></tr></table></figure><h2 id="64-位系统进程地址空间布局"><a href="#64-位系统进程地址空间布局" class="headerlink" title="64 位系统进程地址空间布局"></a>64 位系统进程地址空间布局</h2><p><img src="https://pic4.zhimg.com/80/v2-5f2b9c321b7100a11e2dae9e48bce81f_r.png" alt=""><br>每一个进程都有 64bit 的地址空间，其中用户空间可以使用一半的地址空间（128 TiB），而另一半则是内核空间使用。内核通常驻留在内存中，并且会被映射到每个进程的虚拟内存当中。而在内核中，所有的内核线程都共享一个地址空间。详细的内存布局可以参考后面的学习资料~</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>Linux 中使用三级页表完成地址转换，使用多级页表可以节约地址转换需要占用的空间。但由于完成虚拟页地址到物理页地址转换都需要在三级页表中查找到映射，开销比较高。所以很多体系结构提供了 TLB 作为地址映射的硬件缓存。<br><img src="https://pic4.zhimg.com/80/v2-e7ae1f0fcc4b3a1d0af4e65a1ca04101_r.png" alt=""><br><img src="https://pic4.zhimg.com/80/v2-ff24fef84f1c136922f8bf1f5679ea99_hd.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体上来说，这本书还是比较适合对操作系统基本概念有一定了解，且对于 Linux 内核也有一点了解的前提下阅读，否则在看到一些概念的时候会比较吃力。比如对于进程、线程的抽象定义，虚拟内存中讲到的分页、分段概念以及多级页表的概念。另外，对于常用数据结构需要有清晰的认识；并发相关的同步问题也有了解。<br>虽然整本书是基于 Linux 2.6.3x 内核为基础的，如今的 Linux 内核已经发展到 5.x 时代了，这期间变化肯定有很多。但这本书的价值还是存在的，其中讲得很多思想、方法依然实用，可以变通地去看待和理解。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol><li>POSIX: Portable Operating System Interface</li><li>TLB: Translation Lookup Buffer</li><li>CFS: Complete Fair Scheduler</li><li>CFQ: Complete Fair Queueing，这个是 IO 调度器之一</li><li>VFS: Virtual File System</li><li>VMA: Virtual Memory Area</li><li>MMU: Memory Map Unit</li><li>jiffies: Linux 中用来记录系统启动以来的节拍数的全局变量，还有一个 jiffies_64</li><li>ISR: Interrupt Service Routine</li></ol><h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><ul><li>《Linux 内核设计与实现 Linux Kernel Development，第 3 版》</li><li><a href="https://unix.stackexchange.com/questions/364660/are-threads-implemented-as-processes-on-linux" target="_blank" rel="noopener">Are Threads Implemented As Processes on Linux</a></li><li><a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">POSIX 线程</a></li><li><a href="https://juejin.im/post/5d23326d6fb9a07efe2de11e" target="_blank" rel="noopener">Linux 线程实现</a></li><li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">Linux Sched Doc CFS</a></li><li><a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a></li><li><a href="https://www.win.tue.nl/~aeb/linux/lk/lk-9.html" target="_blank" rel="noopener">Linux Memory</a></li><li><a href="https://www.it.iitb.ac.in/frg/wiki/images/f/fc/113050076_Rajesh_Prodduturi_week5_presentation_3_2012-08-04.pdf" target="_blank" rel="noopener">Linux memory management</a></li><li><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="noopener">x86_64 内存映射</a></li><li><a href="https://simonis.github.io/Memory/" target="_blank" rel="noopener">The Memory Layout of a 64-bit Linux Process</a></li><li><a href="https://stackoverflow.com/questions/55443733/linux-kernel-memory-layout" target="_blank" rel="noopener">Linux kernel memory layout</a></li><li><a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html" target="_blank" rel="noopener">Chapter 3 Page Table Management</a></li><li><a href="https://ifaceless.space/2019/11/18/linux-kernel-scheduler-papers/">Linux 调度器资料整理</a></li><li><a href="https://makelinux.github.io/kernel_map/" target="_blank" rel="noopener">Linux Kernel Map</a></li><li><a href="https://hackernoon.com/entering-god-mode-the-kernel-space-mirroring-attack-8a86b749545f" target="_blank" rel="noopener">Entering God Mode — The Kernel Space Mirroring Attack</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近抽时间把 &lt;a href=&quot;http://pages.cs.wisc.edu/~remzi/OSTEP/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Operating Systems: Three Easy Pieces&lt;/em&gt;&lt;/a&gt; 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（&lt;em&gt;Linux Kernel Development&lt;/em&gt;）后找到想要的答案。当然，在学习中也针对很多部分搜集了不少学习资料，整理在文后，方便加深理解。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="调度器" scheme="http://ifaceless.space/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="操作系统" scheme="http://ifaceless.space/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="内存管理" scheme="http://ifaceless.space/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="文件系统" scheme="http://ifaceless.space/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>限流算法学习：漏桶 &amp; 令牌桶算法</title>
    <link href="http://ifaceless.space/2019/10/11/rate-limit-policies/"/>
    <id>http://ifaceless.space/2019/10/11/rate-limit-policies/</id>
    <published>2019-10-11T13:20:11.000Z</published>
    <updated>2019-11-28T09:41:31.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本节主要学习下两种常用的单机限流思想，分别是<strong>漏桶算法</strong>和<strong>令牌桶算法</strong>。此外，还将给出使用 Python 及 Go 语言实现，便于加深理解。当然，现实中肯定不能直接用下面的代码。实际应用时，我们不大可能在单机执行限流，下面的实现也并非线程或 goroutine 安全的。<br><a id="more"></a><br>实际限流可以考虑在 Nginx 层对请求限流，或者如果真的要自己在业务方实现一套限流策略的话，可以考虑基于 Redis 实现分布式限流策略。并且在实际应用中，可能还会基于不同的维度进行限流，如用户 id，请求 IP 等，实际应用需要考虑的东西更多。</p><h1 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h1><p>可以把请求当作水流，水流全部进入有限大小的水缸，同时水缸会按照固定的速率漏水。当水流湍急，水缸漏水太慢的话，会得知水缸积水，直到溢出（此时拒绝服务）。</p><p><img src="https://pic2.zhimg.com/80/v2-bdf9f813d2f9d8622174e9e58be308b6_hd.png" alt=""></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>实现起来很简单，并且能够以比较恒定的速率服务请求</li><li>缺点是无法应对突发流量，很容易导致溢出</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeakyBucketRateLimiter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity=<span class="number">10</span>, leak_rate=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化漏桶</span></span><br><span class="line"><span class="string">        :param capacity: 桶容量</span></span><br><span class="line"><span class="string">        :param leak_rate: 恒定的消费速度（Reqs/秒）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._capacity = float(capacity)</span><br><span class="line">        self._leak_rate = float(leak_rate)</span><br><span class="line">        self._water_level = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 上次漏水的时间</span></span><br><span class="line">        self._last_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, level=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 执行漏水</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        delta = self._water_level - self._leak_rate * (now - self._last_time)</span><br><span class="line">        self._water_level = min(<span class="number">0.0</span>, delta)</span><br><span class="line">        self._last_time = now</span><br><span class="line">        <span class="comment"># 尝试加水，并看水桶是否满了</span></span><br><span class="line">        <span class="keyword">if</span> level + self._water_level &gt; self._capacity:</span><br><span class="line">            <span class="keyword">raise</span> RateLimitExceeded()</span><br><span class="line">        self._water_level += level</span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeakyBucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    currentLevel <span class="keyword">int</span></span><br><span class="line">    leakRate <span class="keyword">int</span> <span class="comment">// consume how many requests per sec</span></span><br><span class="line">    lastLeakedAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeakyBucketRateLimitter</span><span class="params">(capacity, leakRate <span class="keyword">int</span>)</span> *<span class="title">LeakyBucketRateLimiter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LeakyBucketRateLimiter&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        currentLevel: <span class="number">0</span>,</span><br><span class="line">        leakRate: leakRate,</span><br><span class="line">        lastLeakedAt: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *LeakyBucketRateLimiter)</span> <span class="title">Acquire</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    <span class="comment">// leak water</span></span><br><span class="line">    currentLevel := r.currentLevel - r.leakRate*<span class="keyword">int</span>(now.Sub(r.lastLeakedAt).Seconds())</span><br><span class="line">    r.currentLevel = max(currentLevel, <span class="number">0</span>)</span><br><span class="line">    r.lastLeakedAt = now</span><br><span class="line">    <span class="comment">// try to add water, test bucket is full or not.</span></span><br><span class="line">    currentLevel = n + r.currentLevel</span><br><span class="line">    <span class="keyword">if</span> currentLevel &gt; r.capacity &#123;</span><br><span class="line">        <span class="keyword">return</span> errRateLimitExceeds</span><br><span class="line">    &#125;</span><br><span class="line">    r.currentLevel = currentLevel</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h1><p>同样想象我们有一个桶，专门存放令牌，会以恒定的速率生成令牌，并将其放入桶中。每当有请求过来时，需要先从桶中取到一个或多个令牌，如果获取成功，则为请求提供服务，否则拒绝服务。</p><p><img src="https://pic3.zhimg.com/80/v2-f2b510a893be6ff316bbde684b70c2e2_hd.png" alt=""></p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>实现同样是很简单</li><li>可以应对突发流量，面对瞬间大流量，可以在短时间内获得大量令牌，且生产令牌毫不费力</li><li>可以做流量整形</li></ol><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenBucketRateLimiter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity=<span class="number">1</span>, fill_rate=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化令牌桶限流器</span></span><br><span class="line"><span class="string">        :param capacity: 令牌桶容量</span></span><br><span class="line"><span class="string">        :param fill_rate: 放入令牌的速度（Reqs/秒）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._capacity = float(capacity)</span><br><span class="line">        self._rate = float(fill_rate)</span><br><span class="line">        self._bucket_tokens = float(capacity)</span><br><span class="line">        <span class="comment"># 上次添加令牌的时间</span></span><br><span class="line">        self._last_time = int(time.time())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, tokens=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 发放令牌</span></span><br><span class="line">        <span class="keyword">if</span> self._bucket_tokens &lt; self._capacity:</span><br><span class="line">            now = time.time()</span><br><span class="line">            delta = (now - self._last_time) * self._rate</span><br><span class="line">            self._last_time = now</span><br><span class="line">            self._bucket_tokens = min(self._capacity, self._bucket_tokens + delta)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tokens &gt; self._bucket_tokens:</span><br><span class="line">            <span class="comment"># 无法获取令牌了，数量不够</span></span><br><span class="line">            <span class="keyword">raise</span> RateLimitExceeded()</span><br><span class="line">        self._bucket_tokens -= tokens</span><br></pre></td></tr></table></figure><h3 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TokenBucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    tokens <span class="keyword">int</span></span><br><span class="line">    putRate <span class="keyword">int</span> <span class="comment">// put how many tokens per sec</span></span><br><span class="line">    lastPutAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTokenBucketRateLimiter</span><span class="params">(capacity, fillRate <span class="keyword">int</span>)</span> *<span class="title">TokenBucketRateLimiter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;TokenBucketRateLimiter&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        tokens: <span class="number">0</span>,</span><br><span class="line">        putRate: fillRate,</span><br><span class="line">        lastPutAt: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TokenBucketRateLimiter)</span> <span class="title">Acquire</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.tokens &lt; r.capacity &#123;</span><br><span class="line">        <span class="comment">// put tokens in the bucket</span></span><br><span class="line">        now := time.Now()</span><br><span class="line">        howMany := r.putRate * <span class="keyword">int</span>(now.Sub(r.lastPutAt).Seconds())</span><br><span class="line">        r.tokens = min(r.capacity, howMany+r.tokens)</span><br><span class="line">        r.lastPutAt = now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if we have enough tokens</span></span><br><span class="line">    <span class="keyword">if</span> r.tokens &lt; n &#123;</span><br><span class="line">        <span class="keyword">return</span> errRateLimitExceeds</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release tokens</span></span><br><span class="line">    r.tokens -= n</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/a/1190000015967922" target="_blank" rel="noopener">接口限流算法介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;本节主要学习下两种常用的单机限流思想，分别是&lt;strong&gt;漏桶算法&lt;/strong&gt;和&lt;strong&gt;令牌桶算法&lt;/strong&gt;。此外，还将给出使用 Python 及 Go 语言实现，便于加深理解。当然，现实中肯定不能直接用下面的代码。实际应用时，我们不大可能在单机执行限流，下面的实现也并非线程或 goroutine 安全的。&lt;br&gt;
    
    </summary>
    
      <category term="Web 开发" scheme="http://ifaceless.space/categories/Web-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web 开发" scheme="http://ifaceless.space/tags/Web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="限流" scheme="http://ifaceless.space/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 Go 语言实现一个简单的 LRU Cache</title>
    <link href="http://ifaceless.space/2019/09/22/implement-lru-cache-in-go/"/>
    <id>http://ifaceless.space/2019/09/22/implement-lru-cache-in-go/</id>
    <published>2019-09-22T13:28:32.000Z</published>
    <updated>2019-11-28T09:41:31.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>LRU (Least-Recently-Used) Cache 是经常使用的一种内存缓存，可以将一些热点数据存放在其中，进而提高接口的响应速度。在实际应用中，cache miss 后，实际可能会回源到 Redis 集群获取缓存数据，如果 Redis 集群也没有，才会回源数据库。也就是引入 LRU Cache 后相当于给应用层添加了一级高速缓存。当然，更为实际一点的是，我们需要使用的是带有过期时间的 LRU Cache，否则后台更新了课程数据，由于内存缓存的原因而得不到及时更新。<br><a id="more"></a><br>本节主要是学习下 LRU Cache 实现原理，只探讨最核心的实现思想，不考虑复杂的情况（如 goroutine 安全，缓存带过期时间等）。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>LRU Cache 提供的功能有两个：</p><ol><li>顾名思义，缓存能力</li><li>当缓存空间满了后，会将最少访问的节点删除掉，从而为新的 key/value 提供缓存空间</li></ol><p>具体实现的思路如下：</p><ol><li>需要使用一个 map 维护 key -&gt; entry node 的映射关系，从而能够基于此快速找到相关的节点；</li><li>需要使用一个双向链表来维护 entry node；</li><li><code>cache.set</code> 时，需要首先检查缓存是否超出界限了，如果是的话，需要将链表尾巴（即最少访问的节点）移除；然后将新的节点插入在链表的头部，并在 map 中刷新 key 对应的 entry node 指针；</li><li><code>cache.get</code> 时，如果 hit 到缓存了，则将对应的 entry node 调整在链表头部，保证最频繁的节点始终往前靠。</li></ol><h1 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package lrucache implements a cache with limited capacity, which evicts</span></span><br><span class="line"><span class="comment">// least-used-entry when it overflows.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Caution: not production ready, not goroutine safe.</span></span><br><span class="line"><span class="keyword">package</span> lrucache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"path/to/bit/zerzura/log"</span></span><br><span class="line">    <span class="string">"path/to/bit/zerzura/datastructures/list"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    defaultCapacity = <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Node</span><br><span class="line">    list *list.List</span><br><span class="line">    stats *Stats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(cache *LRUCache)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Capacity</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cache *LRUCache)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">cap</span> = defaultCapacity</span><br><span class="line">        &#125;</span><br><span class="line">        cache.capacity = <span class="built_in">cap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span> *<span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    cache := &amp;LRUCache&#123;</span><br><span class="line">        capacity: defaultCapacity,</span><br><span class="line">        cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Node, defaultCapacity),</span><br><span class="line">        list: list.New(),</span><br><span class="line">        stats: &amp;Stats&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(cache)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"LRUCache(cap=%d, len=%d, hits=%d, misses=%d)"</span>, lru.capacity, lru.Len(), lru.stats.hits, lru.stats.misses)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lru.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(lru.cache)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    log.Debugf(<span class="string">"lru.set (%s, %v)"</span>, key, value)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt;= lru.capacity &#123;</span><br><span class="line">        node := lru.list.Tail()</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            entry := node.Value.(*entry)</span><br><span class="line">            log.Infof(<span class="string">"[lru.set] evict entry %v"</span>, entry)</span><br><span class="line">            <span class="built_in">delete</span>(lru.cache, entry.key)</span><br><span class="line">            lru.list.RemoveNode(node)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"unexpected state, node is nil, that's impossible"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; node != <span class="literal">nil</span> &#123;</span><br><span class="line">        lru.list.RemoveNode(node)</span><br><span class="line">    &#125;</span><br><span class="line">    lru.cache[key] = lru.list.Insert(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;entry&#123;key: key, value: value&#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        log.Infof(<span class="string">"[lru.get] cache misses for key %s"</span>, key)</span><br><span class="line">        lru.stats.miss()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    entry := node.Value.(*entry)</span><br><span class="line">    entry.hits++</span><br><span class="line">    lru.list.RemoveNode(node)</span><br><span class="line">    lru.cache[key] = lru.list.Insert(<span class="number">0</span>, entry)</span><br><span class="line">    lru.stats.hit()</span><br><span class="line">    log.Debugf(<span class="string">"[lru.get] cache hits, got entry %v."</span>, entry)</span><br><span class="line">    <span class="keyword">return</span> entry.value, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">    hits <span class="keyword">int</span></span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">hit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.hits++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">miss</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.misses++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="keyword">string</span></span><br><span class="line">    hits <span class="keyword">int</span></span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;LRU (Least-Recently-Used) Cache 是经常使用的一种内存缓存，可以将一些热点数据存放在其中，进而提高接口的响应速度。在实际应用中，cache miss 后，实际可能会回源到 Redis 集群获取缓存数据，如果 Redis 集群也没有，才会回源数据库。也就是引入 LRU Cache 后相当于给应用层添加了一级高速缓存。当然，更为实际一点的是，我们需要使用的是带有过期时间的 LRU Cache，否则后台更新了课程数据，由于内存缓存的原因而得不到及时更新。&lt;br&gt;
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="缓存" scheme="http://ifaceless.space/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="LRU" scheme="http://ifaceless.space/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Python 标准库源码之 threading 模块</title>
    <link href="http://ifaceless.space/2019/09/14/python-stdlib-threading/"/>
    <id>http://ifaceless.space/2019/09/14/python-stdlib-threading/</id>
    <published>2019-09-14T13:03:33.000Z</published>
    <updated>2019-11-28T09:41:31.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>虽然说 Python 受限于 CPython 的实现，存在的 GIL 会导致我们在使用多线程的时候，没法利用多核跑多线程。但是有的时候还是会用到线程的，尤其是针对一些 I/O 密集型的任务，也可以使用它们。</p><p>在使用多线程编程时，我们随时需要注意<strong>竞态条件（race condition）</strong>和<strong>数据竞争（data race）</strong>的问题，前者会导致我们在不同的时间点运行程序得到的输出可能不同；而后者则更为可怕，容易导致共享的数据结构被错误修改，甚至导致程序崩溃或者出现莫名其妙的 Bug。这个时候自然就要用到 Python threading 模块为我们提供的若干同步原语了。<br><a id="more"></a><br>那么，我们常用的 Lock、RLock、条件变量（Condition Variables）、信号量（Semaphore）等是如何实现的呢？接下来的源码学习是基于 <a href="https://github.com/python/cpython/blob/master/Lib/threading.py" target="_blank" rel="noopener">CPython master 分支的线程模块</a>。希望在学习完它们的实现后，能够加深理解，合理运用。</p><h1 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h1><p>CPython 的 threading 模块实际上是基于 Java 的线程模型实现的，所以熟悉 Java 的话，自然也不会对该模块的实现感到陌生。该模块是基于更底层的 <code>_thread</code> 模块，抽象出更加方便使用的线程模型，核心包括 <code>threading.Thread</code> 线程类封装，便于用户继承或组合；此外还有一些同步原语的实现。<code>Python/thread_nt.h</code> 文件中是 C 语言实现的底层和线程有关的函数（如锁的创建和维护、线程的创建和管理）。</p><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>该模块中，<code>Lock</code> 其实是使用了底层 <code>_thread.allocate_lock</code> 函数来创建锁的。代码也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock = _allocate_lock</span><br></pre></td></tr></table></figure><p>Lock 为我们提供了 <code>acquire()</code> 和 <code>release()</code> 这两个主要的方法。当一个线程持有锁时，其它线程调用 <code>acquire()</code> 方法时会被阻塞（此时线程一般就是睡眠等待了），直到主动 <code>release()</code> 后，等待锁的线程会被唤醒。</p><p>关于 Lock 有两点值得注意：</p><ol><li>该锁是不可重入的，也就是如果在一个函数中递归 <code>acquire()</code> 会导致死锁的问题。为了避免这种问题，一般会使用 <code>RLock</code> 来代替</li><li>Lock 并非 Mutex（互斥锁），且它底层是通过信号量那样实现的，本身不会记录谁持有了该锁，也就是说 Lock 可以在不同的线程中被引用，可以在主线程获取，而在子线程释放它。具体可以在 <code>CPython/Python/thread_nt.h:PyThread_allocate_lock</code> 可以看到它的实现如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock support. It has to be implemented as semaphores.</span></span><br><span class="line"><span class="comment"> * I [Dag] tried to implement it with mutex but I could find a way to</span></span><br><span class="line"><span class="comment"> * tell whether a thread already own the lock or not.</span></span><br><span class="line"><span class="comment"> * Lock 支持：它必须以信号量的方式来实现。我尝试使用互斥锁实现过，但是我</span></span><br><span class="line"><span class="comment"> * 发现了另外一种方式可以得知一个线程是否持有了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PyThread_type_lock</span><br><span class="line">PyThread_allocate_lock(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PNRMUTEX aLock;</span><br><span class="line">    dprintf((<span class="string">"PyThread_allocate_lock called\n"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">        PyThread_init_thread();</span><br><span class="line">    aLock = AllocNonRecursiveMutex() ;</span><br><span class="line">    dprintf((<span class="string">"%lu: PyThread_allocate_lock() -&gt; %p\n"</span>, PyThread_get_thread_ident(), aLock));</span><br><span class="line">    <span class="keyword">return</span> (PyThread_type_lock) aLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 PNRMUTEX 定义如下，它并不会告诉我们当前是哪个线程</span></span><br><span class="line"><span class="comment">// 持有了锁</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NRMUTEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PyMUTEX_T cs;</span><br><span class="line">    PyCOND_T cv;</span><br><span class="line">    <span class="keyword">int</span> locked;</span><br><span class="line">&#125; NRMUTEX;</span><br><span class="line"><span class="keyword">typedef</span> NRMUTEX *PNRMUTEX;</span><br></pre></td></tr></table></figure></li></ol><p>比较有趣的是，其实 <code>PyCOND</code> 即条件变量是通过信号量来实现的；而接下来我们会看到，在 Python 的 threading 模块中，我们使用了 Condition 实现了信号量。</p><p><img src="https://pic2.zhimg.com/80/v2-ee4c29657d4deb6d0953bc8531241697_hd.png" alt=""></p><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>RLock 就是可重入锁（Reentrant Lock），它可以被持有锁的线程多次执行 <code>acquire()</code>，而不会发生阻塞和死锁的问题。它的实现思路很简单：</p><ol><li>规定如果一个线程成功持有了该锁，则将该锁的所有权交给该线程，并且只有该线程可以释放锁，其它线程无法释放；</li><li>当在持有锁的线程中递归获取锁的时候，实际并不会执行底层的 <code>_lock.acquire()</code> 方法，而是只给计数器递增；且释放锁的时候也是先给计数器递减，直到为 0 后才会释放锁。</li></ol><p>所以在使用 RLock 的时候一定要记得 <code>acquire()</code> 和 <code>release()</code> 的调用次数得匹配才能真正释放锁。接下来简单看下源码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RLock</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _CRLock <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># 接下来重点看 Python 版本的 RLock 实现</span></span><br><span class="line">        <span class="keyword">return</span> _PyRLock(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> _CRLock(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RLock</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里是真正的锁</span></span><br><span class="line">        self._block = _allocate_lock()</span><br><span class="line">        <span class="comment"># 记录谁对该锁有所有权</span></span><br><span class="line">        self._owner = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 记录该锁被获取的次数，类似引用计数</span></span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, blocking=True, timeout=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        me = get_ident()</span><br><span class="line">        <span class="keyword">if</span> self._owner == me:</span><br><span class="line">            <span class="comment"># 如果当前持有锁的线程就是当前需要获得锁的线程，计数器递增即可</span></span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        rc = self._block.acquire(blocking, timeout)</span><br><span class="line">        <span class="keyword">if</span> rc:</span><br><span class="line">            <span class="comment"># 如果成功获取到锁后，会把持有锁的线程记录下来，标记该线程是所有权拥有者</span></span><br><span class="line">            self._owner = me</span><br><span class="line">            self._count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rc</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._owner != get_ident():</span><br><span class="line">            <span class="comment"># 显而易见，非拥有者不能释放锁，想都不用想！</span></span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot release un-acquired lock"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里只是递减计数器，只有_count 减没了才会真正释放</span></span><br><span class="line">        self._count = count = self._count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> count:</span><br><span class="line">            self._owner = <span class="keyword">None</span></span><br><span class="line">            self._block.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面的方法是用于条件变量实现时使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_acquire_restore</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="comment"># 恢复锁的获取，并且恢复嵌套层次</span></span><br><span class="line">        self._block.acquire()</span><br><span class="line">        self._count, self._owner = state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_release_save</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 需要保证不管有多少层嵌套，都能真正释放锁，但同时返回当前的嵌套状态等信息便于恢复</span></span><br><span class="line">        <span class="keyword">if</span> self._count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot release un-acquired lock"</span>)</span><br><span class="line">        count = self._count</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        owner = self._owner</span><br><span class="line">        self._owner = <span class="keyword">None</span></span><br><span class="line">        self._block.release()</span><br><span class="line">        <span class="keyword">return</span> (count, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_owned</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._owner == get_ident()</span><br></pre></td></tr></table></figure></p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>条件变量是后面几个同步原语实现的基础，值得重点学习下。条件变量的实现原理比较简单：所有等待的线程会被加入到等待队列中，只有在需要的时候会被唤醒（可以想想如何实现 waiter 线程的等待和唤醒呢？）。</p><p><img src="https://pic2.zhimg.com/80/v2-b4516542d0e21eab291382ac3f8ed364_hd.png" alt=""></p><p>在分析源码前，我们可以看看 <code>Condition</code> 类提供了哪些主要接口：</p><ul><li><code>wait(timeout=None)</code>，线程可以调用该接口等待被唤醒</li><li><code>notify()</code>，线程可以调用该接口通知队列中一个或多个等待线程被唤醒</li></ul><p>接下来看看源码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lock=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> lock <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            lock = RLock()</span><br><span class="line">        self._lock = lock</span><br><span class="line">        <span class="comment"># Export the lock's acquire() and release() methods</span></span><br><span class="line">        self.acquire = lock.acquire</span><br><span class="line">        self.release = lock.release</span><br><span class="line">        <span class="comment"># If the lock defines _release_save() and/or _acquire_restore(),</span></span><br><span class="line">        <span class="comment"># these override the default implementations (which just call</span></span><br><span class="line">        <span class="comment"># release() and acquire() on the lock). Ditto for _is_owned().</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._release_save = lock._release_save</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._acquire_restore = lock._acquire_restore</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._is_owned = lock._is_owned</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        self._waiters = _deque()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_release_save</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._lock.release() <span class="comment"># No state to save</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_acquire_restore</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self._lock.acquire() <span class="comment"># Ignore saved state</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_owned</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Return True if lock is owned by current_thread.</span></span><br><span class="line">        <span class="comment"># This method is called only if _lock doesn't have _is_owned().</span></span><br><span class="line">        <span class="keyword">if</span> self._lock.acquire(<span class="keyword">False</span>):</span><br><span class="line">            self._lock.release()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot wait on un-acquired lock"</span>)</span><br><span class="line">        waiter = _allocate_lock()</span><br><span class="line">        waiter.acquire()</span><br><span class="line">        self._waiters.append(waiter)</span><br><span class="line">        saved_state = self._release_save()</span><br><span class="line">        gotit = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">try</span>: <span class="comment"># restore state no matter what (e.g., KeyboardInterrupt)</span></span><br><span class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                waiter.acquire()</span><br><span class="line">                gotit = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">                    gotit = waiter.acquire(<span class="keyword">True</span>, timeout)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    gotit = waiter.acquire(<span class="keyword">False</span>)</span><br><span class="line">            <span class="keyword">return</span> gotit</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._acquire_restore(saved_state)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> gotit:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self._waiters.remove(waiter)</span><br><span class="line">                <span class="keyword">except</span> ValueError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_for</span><span class="params">(self, predicate, timeout=None)</span>:</span></span><br><span class="line">        endtime = <span class="keyword">None</span></span><br><span class="line">        waittime = timeout</span><br><span class="line">        result = predicate()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="keyword">if</span> waittime <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> endtime <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    endtime = _time() + waittime</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    waittime = endtime - _time()</span><br><span class="line">                    <span class="keyword">if</span> waittime &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            self.wait(waittime)</span><br><span class="line">            result = predicate()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot notify on un-acquired lock"</span>)</span><br><span class="line">        all_waiters = self._waiters</span><br><span class="line">        waiters_to_notify = _deque(_islice(all_waiters, n))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> waiters_to_notify:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> waiter <span class="keyword">in</span> waiters_to_notify:</span><br><span class="line">            waiter.release()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                all_waiters.remove(waiter)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>:</span></span><br><span class="line">    <span class="string">"""This class implements semaphore objects.</span></span><br><span class="line"><span class="string">    Semaphores manage a counter representing the number of release() calls minus</span></span><br><span class="line"><span class="string">    the number of acquire() calls, plus an initial value. The acquire() method</span></span><br><span class="line"><span class="string">    blocks if necessary until it can return without making the counter</span></span><br><span class="line"><span class="string">    negative. If not given, value defaults to 1.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># After Tim Peters' semaphore class, but not quite the same (no maximum)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"semaphore initial value must be &gt;= 0"</span>)</span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, blocking=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Acquire a semaphore, decrementing the internal counter by one.</span></span><br><span class="line"><span class="string">        When invoked without arguments: if the internal counter is larger than</span></span><br><span class="line"><span class="string">        zero on entry, decrement it by one and return immediately. If it is zero</span></span><br><span class="line"><span class="string">        on entry, block, waiting until some other thread has called release() to</span></span><br><span class="line"><span class="string">        make it larger than zero. This is done with proper interlocking so that</span></span><br><span class="line"><span class="string">        if multiple acquire() calls are blocked, release() will wake exactly one</span></span><br><span class="line"><span class="string">        of them up. The implementation may pick one at random, so the order in</span></span><br><span class="line"><span class="string">        which blocked threads are awakened should not be relied on. There is no</span></span><br><span class="line"><span class="string">        return value in this case.</span></span><br><span class="line"><span class="string">        When invoked with blocking set to true, do the same thing as when called</span></span><br><span class="line"><span class="string">        without arguments, and return true.</span></span><br><span class="line"><span class="string">        When invoked with blocking set to false, do not block. If a call without</span></span><br><span class="line"><span class="string">        an argument would block, return false immediately; otherwise, do the</span></span><br><span class="line"><span class="string">        same thing as when called without arguments, and return true.</span></span><br><span class="line"><span class="string">        When invoked with a timeout other than None, it will block for at</span></span><br><span class="line"><span class="string">        most timeout seconds. If acquire does not complete successfully in</span></span><br><span class="line"><span class="string">        that interval, return false. Return true otherwise.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> blocking <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"can't specify timeout for non-blocking acquire"</span>)</span><br><span class="line">        rc = <span class="keyword">False</span></span><br><span class="line">        endtime = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            <span class="keyword">while</span> self._value == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> blocking:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> endtime <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                        endtime = _time() + timeout</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        timeout = endtime - _time()</span><br><span class="line">                        <span class="keyword">if</span> timeout &lt;= <span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                self._cond.wait(timeout)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._value -= <span class="number">1</span></span><br><span class="line">                rc = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> rc</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Release a semaphore, incrementing the internal counter by one or more.</span></span><br><span class="line"><span class="string">        When the counter is zero on entry and another thread is waiting for it</span></span><br><span class="line"><span class="string">        to become larger than zero again, wake up that thread.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'n must be one or more'</span>)</span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._value += n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                self._cond.notify()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span><span class="params">(Semaphore)</span>:</span></span><br><span class="line">    <span class="string">"""Implements a bounded semaphore.</span></span><br><span class="line"><span class="string">    A bounded semaphore checks to make sure its current value doesn't exceed its</span></span><br><span class="line"><span class="string">    initial value. If it does, ValueError is raised. In most situations</span></span><br><span class="line"><span class="string">    semaphores are used to guard resources with limited capacity.</span></span><br><span class="line"><span class="string">    If the semaphore is released too many times it's a sign of a bug. If not</span></span><br><span class="line"><span class="string">    given, value defaults to 1.</span></span><br><span class="line"><span class="string">    Like regular semaphores, bounded semaphores manage a counter representing</span></span><br><span class="line"><span class="string">    the number of release() calls minus the number of acquire() calls, plus an</span></span><br><span class="line"><span class="string">    initial value. The acquire() method blocks if necessary until it can return</span></span><br><span class="line"><span class="string">    without making the counter negative. If not given, value defaults to 1.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></span><br><span class="line">        Semaphore.__init__(self, value)</span><br><span class="line">        self._initial_value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Release a semaphore, incrementing the internal counter by one or more.</span></span><br><span class="line"><span class="string">        When the counter is zero on entry and another thread is waiting for it</span></span><br><span class="line"><span class="string">        to become larger than zero again, wake up that thread.</span></span><br><span class="line"><span class="string">        If the number of releases exceeds the number of acquires,</span></span><br><span class="line"><span class="string">        raise a ValueError.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'n must be one or more'</span>)</span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            <span class="keyword">if</span> self._value + n &gt; self._initial_value:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">"Semaphore released too many times"</span>)</span><br><span class="line">            self._value += n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                self._cond.notify()</span><br></pre></td></tr></table></figure><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></span><br><span class="line">    <span class="string">"""Class implementing event objects.</span></span><br><span class="line"><span class="string">    Events manage a flag that can be set to true with the set() method and reset</span></span><br><span class="line"><span class="string">    to false with the clear() method. The wait() method blocks until the flag is</span></span><br><span class="line"><span class="string">    true. The flag is initially false.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># After Tim Peters' event class (without is_posted())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._flag = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reset_internal_locks</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># private! called by Thread._reset_internal_locks by _after_fork()</span></span><br><span class="line">        self._cond.__init__(Lock())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_set</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return true if and only if the internal flag is true."""</span></span><br><span class="line">        <span class="keyword">return</span> self._flag</span><br><span class="line"></span><br><span class="line">    isSet = is_set</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Set the internal flag to true.</span></span><br><span class="line"><span class="string">        All threads waiting for it to become true are awakened. Threads</span></span><br><span class="line"><span class="string">        that call wait() once the flag is true will not block at all.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._flag = <span class="keyword">True</span></span><br><span class="line">            self._cond.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Reset the internal flag to false.</span></span><br><span class="line"><span class="string">        Subsequently, threads calling wait() will block until set() is called to</span></span><br><span class="line"><span class="string">        set the internal flag to true again.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._flag = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Block until the internal flag is true.</span></span><br><span class="line"><span class="string">        If the internal flag is true on entry, return immediately. Otherwise,</span></span><br><span class="line"><span class="string">        block until another thread calls set() to set the flag to true, or until</span></span><br><span class="line"><span class="string">        the optional timeout occurs.</span></span><br><span class="line"><span class="string">        When the timeout argument is present and not None, it should be a</span></span><br><span class="line"><span class="string">        floating point number specifying a timeout for the operation in seconds</span></span><br><span class="line"><span class="string">        (or fractions thereof).</span></span><br><span class="line"><span class="string">        This method returns the internal flag on exit, so it will always return</span></span><br><span class="line"><span class="string">        True except if a timeout is given and the operation times out.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            signaled = self._flag</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> signaled:</span><br><span class="line">                signaled = self._cond.wait(timeout)</span><br><span class="line">            <span class="keyword">return</span> signaled</span><br></pre></td></tr></table></figure><h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>通常可以使用 Barrier 实现并发初始化，然后一切就绪后才会进入下一个阶段。应用示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> get_ident <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Barrier, Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_prepared</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"All are ready"</span>)</span><br><span class="line"></span><br><span class="line">barrier = Barrier(parties=<span class="number">4</span>, action=signal_prepared)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Thread(target=load_disk_files).start()</span><br><span class="line">    Thread(target=make_cache).start()</span><br><span class="line">    Thread(target=init_db_pool).start()</span><br><span class="line">    print(<span class="string">"I'm ready, wait for other workers"</span>)</span><br><span class="line">    barrier.wait()</span><br><span class="line">    print(<span class="string">"Time to start our server"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_disk_files</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">u"[&#123;&#125;] load_disk_files"</span>.format(get_ident()))</span><br><span class="line">    barrier.wait()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cache</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">u"[&#123;&#125;] make cache"</span>.format(get_ident()))</span><br><span class="line">    barrier.wait()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_db_pool</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">u"[&#123;&#125;] init db pool"</span>.format(get_ident()))</span><br><span class="line">    barrier.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="https://pic3.zhimg.com/80/v2-976ddfaeddc70d04ee29843cfd125713_hd.png" alt=""></p><p>接下来看看 Barrier 是如何实现的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Barrier 是基于部分的 `pthread_barrier_*` API 和 Java 中的 `CyclicBarrier`</span></span><br><span class="line"><span class="comment"># 参考：</span></span><br><span class="line"><span class="comment"># 1. http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and</span></span><br><span class="line"><span class="comment"># 2. http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/CyclicBarrier.html</span></span><br><span class="line"><span class="comment"># 在内部维护了两种主要的状态：`filling` 和 `draining`，从而让屏障变成可循环使用的。</span></span><br><span class="line"><span class="comment"># 只有上一个周期完全排水（`drained`）完毕才可以允许新的线程进入（对比下漏桶限流算法）</span></span><br><span class="line"><span class="comment"># 此外，这里还提供了 `resetting` 状态，它类似于 `draining`，但是会让线程离开的时候抛出 `BrokeBarrierError`</span></span><br><span class="line"><span class="comment"># `broken` 状态表示所有的线程都产生了异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barrier</span>:</span></span><br><span class="line">    <span class="string">"""I</span></span><br><span class="line"><span class="string">    我们通常可以使用屏障让多个线程在相同的同步点同步开始（可以想象下有个水缸，水不断地流进来</span></span><br><span class="line"><span class="string">    但是会在某个点一起放开，形成洪流...）。所有调用了 `wait()` 的线程会在条件满足时几乎同时被唤醒，</span></span><br><span class="line"><span class="string">    然后大家就可以一起快乐地干活了。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parties, action=None, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Create a barrier, initialised to 'parties' threads.</span></span><br><span class="line"><span class="string">        'action' is a callable which, when supplied, will be called by one of</span></span><br><span class="line"><span class="string">        the threads after they have all entered the barrier and just prior to</span></span><br><span class="line"><span class="string">        releasing them all. If a 'timeout' is provided, it is used as the</span></span><br><span class="line"><span class="string">        default for all subsequent 'wait()' calls.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._action = action</span><br><span class="line">        self._timeout = timeout</span><br><span class="line">        self._parties = parties</span><br><span class="line">        self._state = <span class="number">0</span> <span class="comment">#0 filling, 1, draining, -1 resetting, -2 broken</span></span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Wait for the barrier.</span></span><br><span class="line"><span class="string">        When the specified number of threads have started waiting, they are all</span></span><br><span class="line"><span class="string">        simultaneously awoken. If an 'action' was provided for the barrier, one</span></span><br><span class="line"><span class="string">        of the threads will have executed that callback prior to returning.</span></span><br><span class="line"><span class="string">        Returns an individual index number from 0 to 'parties-1'.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            timeout = self._timeout</span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._enter() <span class="comment"># Block while the barrier drains.</span></span><br><span class="line">            index = self._count</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> index + <span class="number">1</span> == self._parties:</span><br><span class="line">                    <span class="comment"># We release the barrier</span></span><br><span class="line">                    self._release()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># We wait until someone releases us</span></span><br><span class="line">                    self._wait(timeout)</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self._count -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># Wake up any threads waiting for barrier to drain.</span></span><br><span class="line">                self._exit()</span><br><span class="line">    <span class="comment"># Block until the barrier is ready for us, or raise an exception</span></span><br><span class="line">    <span class="comment"># if it is broken.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_enter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self._state <span class="keyword">in</span> (<span class="number">-1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># It is draining or resetting, wait until done</span></span><br><span class="line">            self._cond.wait()</span><br><span class="line">        <span class="comment">#see if the barrier is in a broken state</span></span><br><span class="line">        <span class="keyword">if</span> self._state &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> BrokenBarrierError</span><br><span class="line">        <span class="keyword">assert</span> self._state == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optionally run the 'action' and release the threads waiting</span></span><br><span class="line">    <span class="comment"># in the barrier.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_release</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self._action:</span><br><span class="line">                self._action()</span><br><span class="line">            <span class="comment"># enter draining state</span></span><br><span class="line">            self._state = <span class="number">1</span></span><br><span class="line">            self._cond.notify_all()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#an exception during the _action handler. Break and reraise</span></span><br><span class="line">            self._break()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait in the barrier until we are released. Raise an exception</span></span><br><span class="line">    <span class="comment"># if the barrier is reset or broken.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wait</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._cond.wait_for(<span class="keyword">lambda</span> : self._state != <span class="number">0</span>, timeout):</span><br><span class="line">            <span class="comment">#timed out. Break the barrier</span></span><br><span class="line">            self._break()</span><br><span class="line">            <span class="keyword">raise</span> BrokenBarrierError</span><br><span class="line">        <span class="keyword">if</span> self._state &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> BrokenBarrierError</span><br><span class="line">        <span class="keyword">assert</span> self._state == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If we are the last thread to exit the barrier, signal any threads</span></span><br><span class="line">    <span class="comment"># waiting for the barrier to drain.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_exit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self._state <span class="keyword">in</span> (<span class="number">-1</span>, <span class="number">1</span>):</span><br><span class="line">                <span class="comment">#resetting or draining</span></span><br><span class="line">                self._state = <span class="number">0</span></span><br><span class="line">                self._cond.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Reset the barrier to the initial state.</span></span><br><span class="line"><span class="string">        Any threads currently waiting will get the BrokenBarrier exception</span></span><br><span class="line"><span class="string">        raised.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            <span class="keyword">if</span> self._count &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self._state == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">#reset the barrier, waking up threads</span></span><br><span class="line">                    self._state = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> self._state == <span class="number">-2</span>:</span><br><span class="line">                    <span class="comment">#was broken, set it to reset state</span></span><br><span class="line">                    <span class="comment">#which clears when the last thread exits</span></span><br><span class="line">                    self._state = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._state = <span class="number">0</span></span><br><span class="line">            self._cond.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Place the barrier into a 'broken' state.</span></span><br><span class="line"><span class="string">        Useful in case of error. Any currently waiting threads and threads</span></span><br><span class="line"><span class="string">        attempting to 'wait()' will have BrokenBarrierError raised.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._break()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_break</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># An internal error was detected. The barrier is set to</span></span><br><span class="line">        <span class="comment"># a broken state all parties awakened.</span></span><br><span class="line">        self._state = <span class="number">-2</span></span><br><span class="line">        self._cond.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parties</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of threads required to trip the barrier."""</span></span><br><span class="line">        <span class="keyword">return</span> self._parties</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n_waiting</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of threads currently waiting at the barrier."""</span></span><br><span class="line">        <span class="comment"># We don't need synchronization here since this is an ephemeral result</span></span><br><span class="line">        <span class="comment"># anyway. It returns the correct value in the steady state.</span></span><br><span class="line">        <span class="keyword">if</span> self._state == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self._count</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">broken</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return True if the barrier is in a broken state."""</span></span><br><span class="line">        <span class="keyword">return</span> self._state == <span class="number">-2</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Python 源码的注释太丰富了，以至于我都不想翻译成中文。所以结合注释看代码即可~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;虽然说 Python 受限于 CPython 的实现，存在的 GIL 会导致我们在使用多线程的时候，没法利用多核跑多线程。但是有的时候还是会用到线程的，尤其是针对一些 I/O 密集型的任务，也可以使用它们。&lt;/p&gt;
&lt;p&gt;在使用多线程编程时，我们随时需要注意&lt;strong&gt;竞态条件（race condition）&lt;/strong&gt;和&lt;strong&gt;数据竞争（data race）&lt;/strong&gt;的问题，前者会导致我们在不同的时间点运行程序得到的输出可能不同；而后者则更为可怕，容易导致共享的数据结构被错误修改，甚至导致程序崩溃或者出现莫名其妙的 Bug。这个时候自然就要用到 Python threading 模块为我们提供的若干同步原语了。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ifaceless.space/categories/Python/"/>
    
    
      <category term="Python" scheme="http://ifaceless.space/tags/Python/"/>
    
      <category term="源码学习" scheme="http://ifaceless.space/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="多线程" scheme="http://ifaceless.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go 编写姿势</title>
    <link href="http://ifaceless.space/2019/09/03/golang-traps/"/>
    <id>http://ifaceless.space/2019/09/03/golang-traps/</id>
    <published>2019-09-03T13:44:19.000Z</published>
    <updated>2019-11-28T09:41:31.554Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一般情况下，interface 可以直接进行值传递，除非你需要修改 interface 指向的数据。interface 本身很轻量，其包括指向数据类型的指针和存储数据的指针。</li><li>Value Receiver 方法可以通过值或者指针调用；Pointer Receiver 则只接受指针调用。换句话说，指针调用方法更加轻松，限制更少。</li><li>Mutex 和 RWMutex 可以直接使用其零值，零值表示 Unlock 状态。已经被使用的 Mutex 不能被拷贝。</li><li><p>对于 Map &amp; Slice，需要注意其作为参数和返回值的时候，可能会受到外界操作的影响。 安全的做法是在内部做一次拷贝，内部可安全使用。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line"><span class="built_in">copy</span>(d.trips, trips)</span><br></pre></td></tr></table></figure></li><li><p>Channel 的 size 要么是 1，要么是无缓冲的（这个还是要看情况吧）</p></li><li>常规情况下，枚举从 1 开始计数；除非 0 是有一定意义的。如：<code>LogToStdout = 0</code></li><li><p>直接导出自定义错误要小心，最好<strong>只公开错误匹配器</strong>，方便进行错误检查：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">_, ok := err.(errNotFound)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合理使用 Error Wrapping，不用添加过多冗余信息，如：<code>failed to : error message</code>。</p></li><li>在生产环境中，运行的程序避免 panic，panic/recover 不是错误处理策略，而是当不可恢复的事情发生时，程序才必须 panic。</li><li>使用 <a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> 替代标准库 <code>sync/atomic</code>，避免忘记使用原子操作。</li><li><code>import _</code> 应该只用于 <code>main</code> 文件中，尽可能靠近程序启动位置。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>优先使用 <code>strconv</code> 而非 <code>fmt</code> 转换类型，性能更好。</li><li>不要反复（如循环中）从固定字符串创建字节 slice，反之亦然。</li><li>map 创建时尽量提供容量 hint，这样可以避免在添加元素期间过多次地分配。map 虽然不能保证分配 hint 个容量，添加元素时依然可以进行分配，但它可以在运行时有更少的分配。</li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ol><li>保证一致性，便于代码的维护、减少学习成本</li><li>相似的声明放在一个分组（import/var/const/type）。仅将相关的声明放到一起！</li><li>包命名规则：<ol><li>全部小写。无大写或下划线</li><li>多数使用命名导入的情况下，无需重命名包</li><li>简短 &amp; 简洁</li><li>不要使用复数</li></ol></li><li>函数分组与顺序：<ol><li>函数粗略按照调用顺序排序</li><li>同一个文件中，函数应该按照接收者分组</li><li>导出的函数应该先出现在文件中，放在 <code>var</code>, <code>struct</code>, <code>const</code> 定义的后面</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>对于未导出的顶层常量和变量，使用 <code>_</code> 作为前缀</strong>。未导出的错误值，使用 <code>err</code> 开头。原因：顶层变量和常量具有包范围作用域，使用通用名称可能会导致在其他文件中意外使用错误值。</li><li>结构体嵌入，多一行空行隔开</li><li><p><code>nil</code> 是一个有效的 slice；<strong>零值切片（使用 <code>var</code> 声明的切片）可立即使用，无需调用 <code>make()</code> 创建。</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果要声明格式字符串，设置为 <code>const</code> 类型，有助于 <code>go vet</code> 执行字符串静态检查：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul><li><a href="https://github.com/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener">Uber Go Guide</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">The Go common mistakes guide</a></li><li><a href="https://www.kancloud.cn/kancloud/effective/72199" target="_blank" rel="noopener">Effective 中文版</a></li><li><a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">Pointers v.s. Values</a></li><li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just checked errors, handle them gracefully</a></li><li><a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Package Names</a></li><li><a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Go 包样式指南</a></li><li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></li><li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;一般情况下，interface 可以直接进行值传递，除非你需要修改 interface 指向的数据。interface 本身很轻量，其包括指向数据类型的指针和存储数据的指针。&lt;/li&gt;
&lt;li&gt;Value Receiver 方法可以通过值或者指针调用；Point
      
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="最佳实践" scheme="http://ifaceless.space/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
