<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑白之院</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ifaceless.space/"/>
  <updated>2019-11-28T09:41:31.558Z</updated>
  <id>http://ifaceless.space/</id>
  
  <author>
    <name>iFaceless</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 语言中如何以优雅的姿势实现对象序列化？</title>
    <link href="http://ifaceless.space/2019/11/28/portal/"/>
    <id>http://ifaceless.space/2019/11/28/portal/</id>
    <published>2019-11-28T13:50:45.000Z</published>
    <updated>2019-11-28T09:41:31.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在我们的 Web 后端项目中，通常将数据源获取相关的结构体定义放在 models.go 中，不管其关联的数据是来自于数据库、Redis 还是 RPC，总之都是收敛在这一层以提供更好的复用性。</p><p>而针对不同的场景，如 C 端 HTTP API 要求返回的数据，则定义对应的 Schema struct，从而聚合需要的数据下发出去。当然，对于 Admin API 和 RPC API 也会根据需要定义不同的 Schema struct。但是，它们都会复用相同的 models。想必这些应该都是比较常规的操作了吧。<br><a id="more"></a><br>但在实际使用中，也遇到了诸多问题：</p><ol><li>API Schema 的字段类型和 Model 中定义的不同（比如我们使用发号器获得的 ID 在 Model struct 中定义的是 int64，但是为了避免 json.Marshal 时溢出（浏览器截断），统一返回了 string 类型的 ID），就需要手动进行类型转换；</li><li>API Schema 的字段名称和 Model 中定义的可能不同；</li><li>支持灵活的 Schema 字段过滤比较麻烦，不同的项目实现可能不同；</li><li>在某些情况下，如课程 API Schema 关联的一些数据来自于其它服务（需要通过 RPC 调用），这时如果能够并发加载就有提高接口响应速度的可能，但是需要每次在应用层重新实现（当然可以再抽一层出来，不过还是很麻烦，会有心智负担）。</li><li>……</li></ol><p>那么，有没有更加优雅的解决办法呢？</p><h1 id="怎么解决？-🤔"><a href="#怎么解决？-🤔" class="headerlink" title="怎么解决？ 🤔"></a>怎么解决？ 🤔</h1><p>我们之前在使用 Python 项目开发时，使用到了 <a href="https://github.com/marshmallow-code/marshmallow" target="_blank" rel="noopener">marshmallow</a> 这个轻量级的对象序列化框架。当然，它不仅仅提供序列化的能力，还有反序列化以及字段校验的能力。如果能够恰当的使用它，是可以提升开发效率的。如果在 Go 语言社区中存在这样一个框架的话，它是可以解决上面提到的一些问题的。</p><p>在经过一番思想斗争后，斗胆实现了一个类似的框架 <a href="https://github.com/iFaceless/portal" target="_blank" rel="noopener">portal</a> 用于解决上面提到的一些问题。<a href="https://github.com/iFaceless/portal" target="_blank" rel="noopener">portal</a> 聚焦于以优雅且一致的方式处理对象序列化的问题；而对于 Struct Fields 的校验问题，我们可以直接使用已有的第三方库如 <a href="https://github.com/go-playground/validator" target="_blank" rel="noopener">go-playground/validator</a> 或 <a href="https://github.com/asaskevich/govalidator" target="_blank" rel="noopener">asaskevich/govalidator</a>。</p><p>目前来说，核心功能均已按照最初的设计实现了，主要功能如下：</p><ol><li>提供简洁易用的 API 接口</li><li>支持非常灵活的字段过滤能力（任意深度的嵌套字段过滤）</li><li>自动尝试类型转换，远离手动编写太多没什么灵魂的类型转换代码（早点下班不好吗？）</li><li>支持并发填充字段值：<ol><li>可手动指定哪些字段异步加载</li><li>可设置全局的 goroutine 池大小</li></ol></li></ol><h1 id="使用-PORTAL"><a href="#使用-PORTAL" class="headerlink" title="使用 PORTAL"></a>使用 PORTAL</h1><p>可以通过下面的方式安装该包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get get -u github.com/ifaceless/portal</span><br></pre></td></tr></table></figure><p><strong>第一步：定义 Model 结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotificationModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="keyword">int</span></span><br><span class="line">    Title   <span class="keyword">string</span></span><br><span class="line">    Content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserModel)</span> <span class="title">Fullname</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="comment">// 名称甚至可以来自 RPC 调用等，只是一个示例</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"user:%d"</span>, u.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notifications 返回用户关联的一些通知信息列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserModel)</span> <span class="title">Notifications</span><span class="params">()</span> <span class="params">(result []*NotificationModel)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;NotificationModel&#123;</span><br><span class="line">            ID:      i,</span><br><span class="line">            Title:   fmt.Sprintf(<span class="string">"title_%d"</span>, i),</span><br><span class="line">            Content: fmt.Sprintf(<span class="string">"content_%d"</span>, i),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span></span><br><span class="line">    UserID <span class="keyword">int</span></span><br><span class="line">    Title  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 返回 Task 关联的用户是谁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TaskModel)</span> <span class="title">User</span><span class="params">()</span> *<span class="title">UserModel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserModel&#123;t.UserID&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：定义 API Schema 结构体</strong></p><p>以下 Schema 在定义时，都添加了 json tag，并且标记为 omitempty。这样做的目的是，<strong>当我们选择过滤某些字段的时候，portal 就不会填充对应的 Schema Fields</strong>。因此，标记了 omitempty 的字段在 json.Marshal 后就不会出现，从而达到字段过滤的目的。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotiSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="keyword">string</span> <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    Title   <span class="keyword">string</span> <span class="string">`json:"title,omitempty"`</span></span><br><span class="line">    Content <span class="keyword">string</span> <span class="string">`json:"content,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID                   <span class="keyword">string</span>        <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    <span class="comment">// 名称是从 User.Fullname() 方法中获取，我们把它称为 User 的一个属性，使用 `attr` 标记</span></span><br><span class="line">    Name                 <span class="keyword">string</span>        <span class="string">`json:"name,omitempty" portal:"attr:Fullname"`</span></span><br><span class="line">        <span class="comment">// nested 表明该字段的值是一个复合类型，portal 会自动将 notifications 数据填充到对应的 schema 列表</span></span><br><span class="line">    Notifications        []*NotiSchema <span class="string">`json:"notifications,omitempty" portal:"nested"`</span></span><br><span class="line">    AnotherNotifications []*NotiSchema <span class="string">`json:"another_notifications,omitempty" portal:"nested;attr:Notifications"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskSchema <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID          <span class="keyword">string</span>      <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">    Title       <span class="keyword">string</span>      <span class="string">`json:"title,omitempty"`</span></span><br><span class="line">    Description <span class="keyword">string</span>      <span class="string">`json:"description,omitempty" portal:"meth:GetDescription"`</span></span><br><span class="line">    <span class="comment">// UserSchema is a nested schema</span></span><br><span class="line">    User        *UserSchema <span class="string">`json:"user,omitempty" portal:"nested"`</span></span><br><span class="line">    <span class="comment">// We just want `Name` field for `SimpleUser`.</span></span><br><span class="line">    <span class="comment">// Besides, the data source is the same with `UserSchema`</span></span><br><span class="line">    SimpleUser  *UserSchema <span class="string">`json:"simple_user,omitempty" portal:"nested;only:Name;attr:User"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDescription 我们可以通过自定义方法来提供想要的数据</span></span><br><span class="line"><span class="comment">// 一个常见的场景是，我们可以在自定义方法中根据用户状态返回不同的文案</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *TaskSchema)</span> <span class="title">GetDescription</span><span class="params">(model *model.TaskModel)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Custom description"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步：按需序列化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"github.com/ifaceless/portal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// log debug info</span></span><br><span class="line">    portal.SetDebug(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// set max worker pool size</span></span><br><span class="line">    portal.SetMaxPoolSize(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment">// make sure to clean up.</span></span><br><span class="line">    <span class="keyword">defer</span> portal.CleanUp()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write to a specified task schema</span></span><br><span class="line">    <span class="keyword">var</span> taskSchema schema.TaskSchema</span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel)</span><br><span class="line">    <span class="comment">// data: &#123;"id":"1","title":"Finish your jobs.","description":"Custom description","user":&#123;"id":"1","name":"user:1","notifications":[&#123;"id":"0","title":"title_0","content":"content_0"&#125;],"another_notifications":[&#123;"id":"0","title":"title_0","content":"content_0"&#125;]&#125;,"simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select specified fields</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Only(<span class="string">"Title"</span>, <span class="string">"SimpleUser"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"title":"Finish your jobs.","simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// select fields with alias defined in the json tag.</span></span><br><span class="line">    <span class="comment">// actually, the default alias tag is `json`, `portal.FieldAliasMapTagName("json")` is optional.</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Only(<span class="string">"title"</span>, <span class="string">"SimpleUser"</span>), portal.FieldAliasMapTagName(<span class="string">"json"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"title":"Finish your jobs.","simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you can keep any fields for any nested schemas</span></span><br><span class="line">    <span class="comment">// multiple fields are separated with ','</span></span><br><span class="line">    <span class="comment">// nested fields are wrapped with '[' and ']'</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Only(<span class="string">"ID"</span>, <span class="string">"User[ID,Notifications[ID],AnotherNotifications[Title]]"</span>, <span class="string">"SimpleUser"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"id":"1","user":&#123;"id":"1","notifications":[&#123;"id":"0"&#125;],"another_notifications":[&#123;"title":"title_0"&#125;]&#125;,"simple_user":&#123;"name":"user:1"&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore specified fields</span></span><br><span class="line">    portal.Dump(&amp;taskSchema, &amp;taskModel, portal.Exclude(<span class="string">"Description"</span>, <span class="string">"ID"</span>, <span class="string">"User[Name,Notifications[ID,Content],AnotherNotifications], SimpleUser"</span>))</span><br><span class="line">    <span class="comment">// data: &#123;"title":"Finish your jobs.","user":&#123;"id":"1","notifications":[&#123;"title":"title_0"&#125;]&#125;&#125;</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dump multiple tasks</span></span><br><span class="line">    <span class="keyword">var</span> taskSchemas []schema.TaskSchema</span><br><span class="line">    portal.Dump(&amp;taskSchemas, &amp;taskModels, portal.Only(<span class="string">"ID"</span>, <span class="string">"Title"</span>, <span class="string">"User[Name]"</span>))</span><br><span class="line">    <span class="comment">// data: [&#123;"id":"0","title":"Task #1","user":&#123;"name":"user:100"&#125;&#125;,&#123;"id":"1","title":"Task #2","user":&#123;"name":"user:101"&#125;&#125;]</span></span><br><span class="line">    data, _ := json.Marshal(taskSchema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上仅仅是 PORTAL 的一些简单场景的应用，详细可以查看<a href="https://github.com/iFaceless/portal/blob/master/examples/todo" target="_blank" rel="noopener">完整示例</a>，在<a href="https://github.com/iFaceless/portal/blob/master/USERGUIDE.md" target="_blank" rel="noopener">使用指南</a>中提供了一些详细的使用说明。</p><h1 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span> <span class="params">(*Chell, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Dump</span><span class="params">(dst, src <span class="keyword">interface</span>&#123;&#125;, opts ...Option)</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">DumpWithContext</span><span class="params">(ctx context.Context, dst, src <span class="keyword">interface</span>&#123;&#125;, opts ...Option)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SetDebug</span><span class="params">(v <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SetMaxPoolSize</span><span class="params">(size <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">CleanUp</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h1 id="关于并发加载的策略"><a href="#关于并发加载的策略" class="headerlink" title="关于并发加载的策略"></a>关于并发加载的策略</h1><ul><li>当某个 Schema 结构体字段标记了 <code>portal:&quot;async&quot;</code> 标签时会异步填充字段值；</li><li>当序列化 Schema 列表时，会分析 Schema 中有无标记了 <code>async</code> 的字段，如果存在的话，则使用并发填充策略；否则只在当前 goroutine 中完成序列化；</li><li>可以在 Dump 时添加 <code>portal.DisableConcurrency()</code> 禁用并发序列化的功能。</li></ul><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><p><strong>Q: 为什么需要全局 worker pool 存在？</strong><br><strong>A:</strong> 考虑到在 Web 服务中，每个请求过来都会启动一个新的 goroutine 处理。而在处理请求中，如果不限制 PORTAL 并发加载字段值时的 goroutine 数量，可能会导致非常严重的资源消耗问题。所以这里使用了 ants 框架。</p><p><strong>Q: 性能 v.s 开发效率？</strong><br><strong>A:</strong>其实引入这种框架，势必会对接口处理时的内存占用，处理性能产生影响。因为内部实现中也不可避免地大量使用了反射。所以，如果你追求的是高性能的话，那还是不推荐使用了。就我们的应用场景来说，很多接口的 QPS 并不高（尤其是一些后台接口），不管是 CPU 还是内存资源都是充足的。这个时候使用 PORTAL 是可以有效提高开发效率的（个人愚见），毕竟可以少写一些代码，让机器干些蠢活脏活。</p><p><strong>Q: 实际项目中是如何使用 portal 的？有什么体会？带来了什么收益？</strong><br><strong>A:</strong>历经将近一个月的实际项目实践，portal 目前已经趋于稳定，并且修复了大量问题，发布了 22 个版本。目前该工具包应应用在多个线上服务中（包括 HTTP RESTful API 和 RPC 中 Model 到 thrift 定义类型的映射），整体感受就是开发体验成倍提高，而且带来了性能影响并没有最开始认为的那么大。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人认为，框架的引入正是为了提高开发效率，提升项目质量的。框架层的抽象和封装可以让我们不用每次都在业务代码层编写重复机械式的代码，同时能够保证编写方式的一致性，提升项目的可维护性。<strong>所谓的性能问题，也许根本不是问题；所谓的提前优化，也许只是过度优化。</strong>我们应该用 20% 时间解决 80% 的常规问题，并且是高效率高质量的那种。而剩下 20% 的难题，完全可以用别的方法解决。切勿本末倒置！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在我们的 Web 后端项目中，通常将数据源获取相关的结构体定义放在 models.go 中，不管其关联的数据是来自于数据库、Redis 还是 RPC，总之都是收敛在这一层以提供更好的复用性。&lt;/p&gt;
&lt;p&gt;而针对不同的场景，如 C 端 HTTP API 要求返回的数据，则定义对应的 Schema struct，从而聚合需要的数据下发出去。当然，对于 Admin API 和 RPC API 也会根据需要定义不同的 Schema struct。但是，它们都会复用相同的 models。想必这些应该都是比较常规的操作了吧。&lt;br&gt;
    
    </summary>
    
      <category term="Web 开发" scheme="http://ifaceless.space/categories/Web-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="对象序列化" scheme="http://ifaceless.space/tags/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Web API" scheme="http://ifaceless.space/tags/Web-API/"/>
    
      <category term="portal" scheme="http://ifaceless.space/tags/portal/"/>
    
  </entry>
  
  <entry>
    <title>论文学习之 Linux 调度器</title>
    <link href="http://ifaceless.space/2019/11/17/guide-to-linux-scheduler/"/>
    <id>http://ifaceless.space/2019/11/17/guide-to-linux-scheduler/</id>
    <published>2019-11-17T15:20:14.000Z</published>
    <updated>2019-11-28T09:54:52.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><em>Linux Kernel Development</em> 一书中，关于 Linux 的进程调度器并没有讲解的很深入，只是提到了 CFS 调度器的基本思想和一些实现细节；并没有 Linux 早期的调度器介绍，以及最近这些年新增的在内核源码树外维护的调度器思想。所以在经过一番搜寻后，看到了这篇论文 <a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a>，对 Linux 的调度器历史进行了回顾，并且相对细致地讲解了 CFS 调度器。整体来说，虽然比较啰嗦，但是对于想要知道更多细节的我来说非常适合，所以就有了翻译它的冲动。当然，在学习过程也参考了其它论文。下面开启学习之旅吧~</p><a id="more"></a><p><em>需要注意的是，在 Linux 中，线程和进程都是由同一个结构体（task_struct，即任务描述符）表示的，所以文中会交叉使用进程、线程和任务等术语，可以将它们视作同义词。当然，也可以将线程（任务）称为最小执行单元。但 Linux 的调度算法（如 CFS）可以应用更加通用的调度单元（如线程、cgroup、用户等）。总之，不要过度纠结这里的术语，重要的是了解每种调度算法的思想！</em></p><h1 id="为什么需要调度"><a href="#为什么需要调度" class="headerlink" title="为什么需要调度"></a>为什么需要调度</h1><p>Linux 是一个多任务的操作系统，这就意味着它可以「同时」执行多个任务。在单核处理器上，任意时刻只能有一个进程可以执行（并发）；而在多核处理器中，则允许任务并行执行。然而，不管是何种硬件类型的机器上，可能同时还有很多在内存中无法得到执行的进程，它们正在等待运行，或者正在睡眠。负责将 CPU 时间分配给进程的内核组件就是「进程调度器」。</p><p>调度器负责维护进程调度顺序，选择下一个待执行的任务。如同多数其它的现代操作系统，Linux 实现了<strong>抢占式</strong>多任务机制。也就是说，调度器可以随时决定任意进程停止运行，而让其它进程获得 CPU 资源。这种违背正在运行的进程意愿，停止其运行的行为就是所谓的「抢占」。抢占通常可以在定时器中断时发生，当中断发生时，调度器会检查是否需要切换任务，如果是，则会完成进程上下文切换。每个进程所获得的运行时间叫做<strong>进程的时间片（timeslice）</strong>。</p><p>任务通常可以区分为<strong>交互式（I/O 密集型）</strong>和<strong>非交互式（CPU 密集型）</strong>任务。交互式任务通常会重度依赖 I/O 操作（如 GUI 应用），并且通常用不完分配给它的时间片。而非交互式任务（如数学运算）则需要使用更多的 CPU 资源。它们通常会用完自己的时间片之后被抢占，并不会被 I/O 请求频繁阻塞。</p><p>当然，现实中的应用程序可能同时包含上述两种分类任务。例如，文本编辑器，多数情况下，它会等待用户输入，但是在执行拼写检查时也会需要占用大量 CPU 资源。</p><p><strong>操作系统的调度策略就需要均衡这两种类型的任务，并且保证每个任务都能得到足够的执行资源，而不会对其它任务产生明显的性能影响。</strong> Linux 为了保证 CPU 利用率最大化，同时又能保证更快的响应时间，倾向于为非交互式任务分配更大的时间片，但是以较低的频率运行它们；而针对 I/O 密集型任务，则会在较短周期内频繁地执行。</p><h1 id="调度有关的进程描述符"><a href="#调度有关的进程描述符" class="headerlink" title="调度有关的进程描述符"></a>调度有关的进程描述符</h1><p>进程描述符（task_struct）中的很多字段会被调度机制直接使用。以下仅列出一些核心的部分，并在后文详细讨论。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line">    <span class="keyword">cpumask_t</span> cpus_allowed;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关于这些字段的说明如下：</p><ul><li><code>prio</code> 表示进程的优先级。进程运行时间，抢占频率都依赖于这些值。<code>rt_priority</code> 则用于实时（real-time）任务；</li><li><code>sched_class</code> 表示进程位于哪个调度类；</li><li><code>sched_entity</code> 的意义比较特殊。通常把一个线程（Linux 中的进程、任务同义词）叫作最小调度单元。但是 Linux 调度器不仅仅只能够调度单个任务，<strong>而且还可以将一组进程，甚至属于某个用户的所有进程作为整体进行调度</strong>。这就允许我们实现组调度，从而将 CPU 时间先分配到进程组，再在组内分配到单个线程。当引入这项功能后，可以大幅度提升桌面系统的交互性。比如，可以将编译任务聚集成一个组，然后进行调度，从而不会对交互性产生明显的影响。这里再次强调下，**Linux 调度器不仅仅能直接调度进程，也能对调度单元（schedulable entities）进行调度。这样的调度单元正是用 <code>struct sched_entity</code> 来表示的。需要说明的是，它并非一个指针，而是直接嵌套在进程描述符中的。当然，后面的谈论将聚焦在单进程调度这种简单场景。由于调度器是面向调度单元设计的，所以它会将单个进程也视为调度单元，因此会使用 <code>sched_entity</code> 结构体操作它们。<code>sched_rt_entity</code> 则是实时调度时使用的。</li><li><code>policy</code> 表明任务的调度策略：通常意味着针对某些特定的进程组（如需要更长时间片，更高优先级等）应用特殊的调度决策。Linux 内核目前支持的调度策略如下：<ul><li><code>SCHED_NORMAL</code>：普通任务使用的调度策略；</li><li><code>SCHED_BATCH</code>：不像普通任务那样被频繁抢占，可允许任务运行尽可能长的时间，从而更好地利用缓存，但是代价自然是损失交互性能。这种非常适合批量任务调度（批量的 CPU 密集型任务）;</li><li><code>SCHED_IDLE</code>：它要比 nice 19 的任务优先级还要低，但它并非真的空闲任务;</li><li><code>SCHED_FIFO</code> 和 <code>SCHED_RR</code> 是软实时进程调度策略。它们是由 POSIX 标准定义的，由 <code>&lt;kernel/sched/rt.c&gt;</code> 里面定义的实时调度器负责调度。RR 实现的是带有固定时间片的轮转调度方式；SCHED_FIFO 则使用的是先进先出的队列机制。</li></ul></li><li><code>cpus_allowed</code>：用来表示任务的 CPU 亲和性。用户空间可以通过 <code>sched_setaffinity</code> 系统调用来设置。</li></ul><h1 id="优先级-Priority"><a href="#优先级-Priority" class="headerlink" title="优先级 Priority"></a>优先级 Priority</h1><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><h3 id="普通任务优先级"><a href="#普通任务优先级" class="headerlink" title="普通任务优先级"></a>普通任务优先级</h3><p>所有的类 Unix 操作系统都实现了优先级调度机制。它的核心思想就是给任务设定一个值，然后通过该值决定任务的重要程度。如果任务的优先级一致，则一次重复运行它们。在 Linux 中，每一个普通任务都被赋予了一个 nice 值，它的范围是 -20 到 +19，任务默认 nice 值是 0。<br><img src="https://pic1.zhimg.com/v2-665ed41d133e9e332c4fdc6034240cb5.jpg" alt=""></p><p>nice 值越高，任务优先级越低（it’s nice to others）。Linux 中可以使用 <code>nice(int increment)</code> 系统调用来修改当前进程的优先级。该系统调用的实现位于 <code>&lt;kernel/shced/core.c&gt;</code> 中。默认情况下，用户只能为该用户启动的进程增加 nice 值（即降低优先级）。如果需要增加优先级（减少 nice 值），或者修改其它用户进程优先级，则必须以 root 身份操作。</p><h3 id="实时任务优先级"><a href="#实时任务优先级" class="headerlink" title="实时任务优先级"></a>实时任务优先级</h3><p>在 Linux 中，除了普通任务外，还有一类任务属于实时任务。实时任务是确保它们能够在一定时间范围内执行的任务，有两类实时任务，列举如下：</p><ul><li><strong>硬实时任务</strong>：会有严格的时间限制，任务必须在时限内完成。比如直升机的飞控系统，就需要及时响应驾驶员的操控，并做出预期的动作。然而，Linux 本身并不支持硬实时任务，但是有一些基于它修改的版本，如 RTLinux（它们通常被称为 RTOS）则是支持硬实时调度的。</li><li><strong>软实时任务</strong>：软实时任务其实也会有时间限制，但不是那么严格。也就是说，任务晚一点运行任务，并不会造成不可挽回的灾难性事故。实践中，软实时任务会提供一定的时间限制保障，但是不要过度依赖这种特性。例如，VOIP 软件会使用软实时保障的协议传来送音视频信号，但是即便因为操作系统负载过高，而产生一点延迟，也不会造成很大影响。<strong>无论如何，软实时任务总会比普通任务的优先级更高</strong>。</li></ul><p>Linux 中实时任务的优先级范围是 0~99，但是有趣的是，它和 nice 值的作用刚好相反，这里的优先级值越大，就意味着优先级越高。<br><img src="https://pic4.zhimg.com/v2-d5299a6846bcb492ec3340f1a725b323.jpg" alt=""></p><p>类似其它的 Unix 系统，Linux 也是基于 POSIX 1b 标准定义的 「Real-time Extensions」实现实时优先级。可以通过如下的命令查看系统中的实时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -eo pid, rtprio, cmd</span><br></pre></td></tr></table></figure><p>也可通过 <code>chrt -p pid</code> 查看单个进程的详情。Linux 中可以通过 <code>chrt -p prio pid</code> 更改实时任务优先级。这里需要注意的是，如果操作的是一个系统进程（通常并不会将普通用户的进程设置为实时的），则必须有 root 权限才可以修改实时优先级。</p><h2 id="内核视角下的进程优先级"><a href="#内核视角下的进程优先级" class="headerlink" title="内核视角下的进程优先级"></a>内核视角下的进程优先级</h2><p>实时上，内核看到的任务优先级和用户看到的并不相同，在计算和管理优先级时也需要考虑很多方面。Linux 内核中使用 0~139 表示任务的优先级，并且，<strong>值越小，优先级越高</strong>（注意和用户空间的区别）。其中 0~99 保留给实时进程，100~139（映射成 nice 值就是 -20~19）保留给普通进程。<br><img src="https://pic2.zhimg.com/v2-4d4d4645d2dc1a52bbea516e8d82171b.jpg" alt=""></p><p>我们可以在 <code>&lt;include/linux/sched/prio.h&gt;</code> 头文件中看到内核表示进程优先级的单位（scale）和宏定义（macros），它们用来将用户空间优先级映射到到内核空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NICE 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_NICE -20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NICE_WIDTH (MAX_NICE - MIN_NICE + 1)</span></span><br><span class="line">…</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USER_RT_PRIO 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RT_PRIO MAX_USER_RT_PRIO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Convert user-nice values [ -20 ... 0 ... 19 ]</span></span><br><span class="line"><span class="comment">* to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],</span></span><br><span class="line"><span class="comment">* and back.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 'User priority' is the nice value converted to something we</span></span><br><span class="line"><span class="comment">* can work with better when scaling various scheduler parameters,</span></span><br><span class="line"><span class="comment">* it's a [ 0 ... 39 ] range.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_PRIO(p) ((p)-MAX_RT_PRIO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_USER_PRIO(p) USER_PRIO((p)-&gt;static_prio)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USER_PRIO (USER_PRIO(MAX_PRIO))</span></span><br></pre></td></tr></table></figure></p><h2 id="优先级计算"><a href="#优先级计算" class="headerlink" title="优先级计算"></a>优先级计算</h2><p>在 <code>task_struct</code> 中有几个字段用来表示进程优先级：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br></pre></td></tr></table></figure></p><p><code>static_prio</code> 是由用户或系统设定的「静态」优先级映射成内核表示的优先级：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;static_prio = NICE_TO_PRIO(nice_value);</span><br></pre></td></tr></table></figure></p><p><code>normal_prio</code> 存放的是基于 <code>static_prio</code> 和进程调度策略（实时或普通）决定的优先级，相同的静态优先级，在不同的调度策略下，得到的正常优先级是不同的。子进程在 fork 时，会继承父进程的 <code>normal_prio</code>。</p><p><code>prio</code> 则是「动态优先级」，在某些场景下优先级会发生变动。一种场景就是，系统可以通过给某个任务优先级提升一段时间，从而抢占其它高优先级任务，一旦 <code>static_prio</code> 确定，<code>prio</code> 字段就可以通过下面的方式计算：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prio = effective_prio(p);</span><br><span class="line"><span class="comment">// kernel/sched/core.c 中定义了计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">effective_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If we are RT tasks or we were boosted to RT priority,</span></span><br><span class="line"><span class="comment">    * keep the priority unchanged. Otherwise, update priority</span></span><br><span class="line"><span class="comment">    * to the normal priority:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">        <span class="keyword">return</span> p-&gt;normal_prio;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">normal_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prio;</span><br><span class="line">    <span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">        prio = MAX_DL_PRIO<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">        prio = MAX_RT_PRIO<span class="number">-1</span> - p-&gt;rt_priority;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        prio = __normal_prio(p);</span><br><span class="line">    <span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __normal_prio(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;static_prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="负载权重（Load-Weights）"><a href="#负载权重（Load-Weights）" class="headerlink" title="负载权重（Load Weights）"></a>负载权重（Load Weights）</h2><p>优先级会让一些任务比别的任务更重要，因此也会获得更多的 CPU 使用时间。nice 值和时间片的比例关系是通过负载权重（Load Weights）进行维护的，我们可以在 <code>task_struct-&gt;se.load</code> 中看到进程的权重，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span> <span class="comment">/* for load-balancing */</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> weight;</span><br><span class="line">    u32 inv_weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了让 nice 值的变化反映到 CPU 时间变化片上更加合理，Linux 内核中定义了一个数组，用于映射 nice 值到权重：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line">    <span class="comment">/* -20 */</span> <span class="number">88761</span>, <span class="number">71755</span>, <span class="number">56483</span>, <span class="number">46273</span>, <span class="number">36291</span>,</span><br><span class="line">    <span class="comment">/* -15 */</span> <span class="number">29154</span>, <span class="number">23254</span>, <span class="number">18705</span>, <span class="number">14949</span>, <span class="number">11916</span>,</span><br><span class="line">    <span class="comment">/* -10 */</span> <span class="number">9548</span>, <span class="number">7620</span>, <span class="number">6100</span>, <span class="number">4904</span>, <span class="number">3906</span>,</span><br><span class="line">    <span class="comment">/* -5 */</span> <span class="number">3121</span>, <span class="number">2501</span>, <span class="number">1991</span>, <span class="number">1586</span>, <span class="number">1277</span>,</span><br><span class="line">    <span class="comment">/* 0 */</span> <span class="number">1024</span>, <span class="number">820</span>, <span class="number">655</span>, <span class="number">526</span>, <span class="number">423</span>,</span><br><span class="line">    <span class="comment">/* 5 */</span> <span class="number">335</span>, <span class="number">272</span>, <span class="number">215</span>, <span class="number">172</span>, <span class="number">137</span>,</span><br><span class="line">    <span class="comment">/* 10 */</span> <span class="number">110</span>, <span class="number">87</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">45</span>,</span><br><span class="line">    <span class="comment">/* 15 */</span> <span class="number">36</span>, <span class="number">29</span>, <span class="number">23</span>, <span class="number">18</span>, <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>来看看如何使用上面的映射表，假设有两个优先级都是 0 的任务，每个都能获得 50% 的 CPU 时间（1024 / (1024 + 1024) = 0.5）。如果突然给其中的一个任务优先级提升了 1 （nice 值 -1）。此时，一个任务应该会获得额外 10% 左右的 CPU 时间，而另一个则会减少 10% CPU 时间。来看看计算结果：1277 / (1024 + 1277) ≈ 0.55，1024 / (1024 + 1277) ≈ 0.45，二者差距刚好在 10% 左右，符合预期。完整的计算函数定义在 <code>&lt;kernel/sched/core.c&gt;</code> 中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_load_weight</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prio = p-&gt;static_prio - MAX_RT_PRIO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> *<span class="title">load</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>.<span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * SCHED_IDLE tasks get minimal weight:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;policy == SCHED_IDLE) &#123;</span><br><span class="line">        load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);</span><br><span class="line">        load-&gt;inv_weight = WMULT_IDLEPRIO;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    load-&gt;weight = scale_load(prio_to_weight[prio]);</span><br><span class="line">    load-&gt;inv_weight = prio_to_wmult[prio];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="调度类-Scheduling-Classes"><a href="#调度类-Scheduling-Classes" class="headerlink" title="调度类 Scheduling Classes"></a>调度类 Scheduling Classes</h1><p>虽说 Linux 内核使用的 C 语言并非所谓的 OOP 语言（没有类似 C++/Java 中的 class 概念），但是我们可以在内核代码中看到一些使用 C 语言结构体 + 函数指针（Hooks）的方式来模拟面向对象的方式，抽象行为和数据。调度类也是这样实现的（此外，还有 <code>inode_operations</code>, <code>super_block_operations</code> 等），它的定义如下（位于 <code>&lt;kernel/shced/sched.h&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简单起见，隐藏了部分代码（如 SMP 相关的）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 多个 sched_class 是链接在一起的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 该 hook 会在任务进入可运行状态时调用。它会将调度单元（如一个任务）放到</span></span><br><span class="line">    <span class="comment">// 队列中，同时递增 `nr_running` 变量（该变量表示运行队列中可运行的任务数）</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">// 该 hook 会在任务不可运行时调用。它会将任务移出队列，同时递减 `nr_running`</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">// 该 hook 可以在任务需要主动放弃 CPU 时调用，但是需要注意的是，它不会改变</span></span><br><span class="line">    <span class="comment">// 任务的可运行状态，也就是说依然会在队列中等待下次调度。类似于先 dequeue_task，</span></span><br><span class="line">    <span class="comment">// 再 enqueue_task</span></span><br><span class="line">    <span class="keyword">void</span> (*yield_task) (struct rq *rq);</span><br><span class="line">    <span class="comment">// 该 hook 会在任务进入可运行状态时调用并检查是否需要抢占当前任务</span></span><br><span class="line">    <span class="keyword">void</span> (*check_preempt_curr) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">// 该 hook 用来选择最适合运行的下一个任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>) (<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>);</span></span><br><span class="line">    <span class="comment">// 该 hook 会在任务修改自身的调度类或者任务组时调用</span></span><br><span class="line">    <span class="keyword">void</span> (*set_curr_task) (struct rq *rq);</span><br><span class="line">    <span class="comment">// 通常是在时钟中断时调用，可能会导致任务切换</span></span><br><span class="line">    <span class="keyword">void</span> (*task_tick) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> queued);</span><br><span class="line">    <span class="comment">// 当任务被 fork 时通知调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*task_fork) (struct task_struct *p);</span><br><span class="line">    <span class="comment">// 当任务挂掉时通知调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*task_dead) (struct task_struct *p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关于调度策略的具体细节的实现有如下几个模块：</p><ul><li><code>core.c</code> 包含调度器的核心部分；</li><li><code>fair.c</code> 实现了 CFS（Comple Faire Scheduler，完全公平任务调度器） 调度器，应用于普通任务；</li><li><code>rt.c</code> 实现了实时调度，应用于实时任务；</li><li><code>idle_task.c</code> 当没有其它可运行的任务时，会运行空闲任务。<br>内核是基于任务的调度策略（SCHED_*）来决定使用何种调度类实现，并会调用相应的方法。<code>SCHED_NORMAL</code>, <code>SCHED_BATCH</code> 和 <code>SCHED_IDLE</code> 进程会映射到 <code>fair_sched_class</code> （由 CFS 实现）；<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code> 则映射的 <code>rt_sched_class</code> （实时调度器）。</li></ul><h1 id="运行队列-Run-Queue"><a href="#运行队列-Run-Queue" class="headerlink" title="运行队列 Run Queue"></a>运行队列 Run Queue</h1><p>所有可运行的任务是放在运行队列中的，并且等待 CPU 运行。每个 CPU 核心都有自己的运行队列，每个任务任意时刻只能处于其中一个队列中。在多处理器机器中，会有负载均衡策略，任务就会转移到其它 CPU 上运行的可能。</p><p>运行队列数据结构定义如下（位于 <code>&lt;kernel/sched/sched.h&gt;</code>）:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简单起见，隐藏了部分代码（SMP 相关）</span></span><br><span class="line"><span class="comment">// 这个是每个 CPU 都会有的一个任务运行队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 表示当前队列中总共有多少个可运行的任务（包含所有的 sched class）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_running;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line">    <span class="comment">// 运行队列负载记录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">// 嵌套的 CFS 调度器运行队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span></span><br><span class="line">    <span class="comment">// 嵌套的实时任务调度器运行队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span></span><br><span class="line">    <span class="comment">// curr 指向当前正在运行的进程描述符</span></span><br><span class="line">    <span class="comment">// idle 则指向空闲进程描述符（当没有其它可运行任务时，该任务才会启动）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>, *<span class="title">idle</span>;</span></span><br><span class="line">    u64 clock;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="何时运行调度器？"><a href="#何时运行调度器？" class="headerlink" title="何时运行调度器？"></a>何时运行调度器？</h1><p>实时上，调度函数 <code>schedule()</code> 会在很多场景下被调用。有的是直接调用，有的则是隐式调用（通过设置 <code>TIF_NEED_RESCHED</code> 来提示操作系统尽快运行调度函数）。以下三个调度时机值得关注下：</p><ul><li><p><strong>时钟中断发生时，会调用 <code>scheduler_tick()</code> 函数</strong>，该函数会更新一些和调度有关的数据统计，并触发调度类的周期调度方法，从而间接地进行调度。以 2.6.39 源码为例，可能的调用链路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick</span><br><span class="line">└── task_tick</span><br><span class="line">    └── entity_tick</span><br><span class="line">        └── check_preempt_tick</span><br><span class="line">            └── resched_task</span><br><span class="line">                └── set_tsk_need_resched</span><br></pre></td></tr></table></figure></li><li><p><strong>当前正在运行的任务进入睡眠状态</strong>。在这种情况下，任务会主动释放 CPU。通常情况下，该任务会因为等待指定的事件而睡眠，它可以将自己添加到等待队列，并启动循环检查期望的条件是否满足。在进入睡眠前，任务可以将自己的状态设置为 <code>TASK_INTERRUPTABLE</code>（除了任务要等待的事件可唤醒外，也可以被信号唤醒）或者 <code>TASK_UNINTERRUPTABLE</code>（自然是不会理会信号咯），然后调用 <code>schedule()</code> 选择下一个任务运行。</p></li><li><p><strong>睡眠的任务被唤醒</strong>。任务等待的事件可以在关联的等待队列上调用 <code>wake_up()</code> 函数唤醒任务：相关任务会将自己设置为可运行状态，并加入运行队列。如果当前唤醒的任务优先级比运行队列中的任何任务都高，则会设置 <code>TIF_NEED_RESCHED</code> 标志，从而让操作系统尽快调用 <code>schedule()</code> 函数。</p></li></ul><h1 id="Linux-调度器"><a href="#Linux-调度器" class="headerlink" title="Linux 调度器"></a>Linux 调度器</h1><h2 id="早期版本"><a href="#早期版本" class="headerlink" title="早期版本"></a>早期版本</h2><p>Linux 0.0.1 版本就已经有了一个简单的调度器，当然并非适合拥有特别多处理器的系统。该调度器只维护了一个全局的进程队列，每次都需要遍历该队列来寻找新的进程执行，而且对任务数量还有严格限制（<code>NR_TASKS</code> 在最初的版本中只有 32）。下面来看看这个调度器是如何实现的吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'schedule()' is the scheduler function. </span></span><br><span class="line"><span class="comment">// This is GOOD CODE! There probably won't be any reason to change </span></span><br><span class="line"><span class="comment">// this, as it should work well in all circumstances (ie gives </span></span><br><span class="line"><span class="comment">// IO-bound processes good response etc)...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, next, c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 遍历所有任务，如果有信号，则需要唤醒 `TASK_INTERRUPTABLE` 的任务</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">                (*p)-&gt;signal |= (<span class="number">1</span> &lt;&lt; (SIGALRM - <span class="number">1</span>));</span><br><span class="line">                (*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;signal &amp;&amp; (*p)-&gt;state == TASK_INTERRUPTIBLE)</span><br><span class="line">                (*p)-&gt;state = TASK_RUNNING;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        <span class="comment">// 遍历所有任务，找到时间片最长的那个</span></span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 遍历任务，重新设值时间片</span></span><br><span class="line">        <span class="keyword">for</span> (p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切换到下一个需要执行的任务</span></span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>2.4 版本的 Linux 内核使用的调度算法非常简单和直接，由于每次在寻找下一个任务时需要遍历系统中所有的任务（链表），因此被称为 O(n) 调度器（时间复杂度）。</p><p>当然，该调度器要比 0.01 版本内核中的调度算法稍微复杂点，它引入了 epoch 概念。也就是将时间分成纪元（epochs），也就是每个进程的生命周期。理论上来说，每个纪元结束，每个进程都应该运行过一次了，而且通常用光了它当前的时间片。但实际上，有些任务并没有完全用完时间片，那么它剩余时间片的一半将会和新的时间片相加，从而在下一个纪元运行更长的时间。</p><p>我们来看下 <code>schedule()</code> 算法的核心源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule() 算法会遍历所有的任务（O(N)），并且计算出每个任务的</span></span><br><span class="line"><span class="comment">// goodness 值，且挑选出「最好」的任务来运行。</span></span><br><span class="line"><span class="comment">// 以下是部分核心源码，主要是了解下它的思路。</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 任务（进程）描述符：</span></span><br><span class="line">    <span class="comment">// 1. prev: 当前正在运行的任务</span></span><br><span class="line">    <span class="comment">// 2. next: 下一个将运行的任务</span></span><br><span class="line">    <span class="comment">// 3. p: 当前正在遍历的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> this_cpu, c; <span class="comment">// c 表示权重值</span></span><br><span class="line">repeat_schedule:</span><br><span class="line">    <span class="comment">// 默认选中的任务</span></span><br><span class="line">    next = idle_task(this_cpu);</span><br><span class="line">    c = <span class="number">-1000</span>;</span><br><span class="line">    list_for_each(tmp, &amp;runqueue_head) &#123;</span><br><span class="line">        p = list_entry(tmp, struct task_struct, run_list);</span><br><span class="line">        <span class="keyword">if</span> (can_schedule(p, this_cpu)) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = goodness(p, this_cpu, prev-&gt;active_mm);</span><br><span class="line">            <span class="keyword">if</span> (weight &gt; c)</span><br><span class="line">                c = weight, next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>源码中的 <code>goodness()</code> 函数会计算出一个权重值，它的算法基本思想就是基于进程所剩余的时钟节拍数（时间片），再加上基于进程优先级的权重值。返回值如下：</p><ul><li>-1000 表示不要选择该进程运行</li><li>0 表示时间片用完了，需要重新计算 counters（可能会被选中运行）</li><li>正整数：表示 goodness 值（越大越好）</li><li>+1000 表示实时进程，接下来就要选择它运行</li></ul><p>最后，针对 O(n) 调度器做下总结：</p><ol><li>算法实现非常简单，但是不高效（任务越多，遍历耗费时间越久）</li><li>没有很好的扩展性，多核处理器怎么办？</li><li>对于实时任务调度支持较弱（无论如何作为优先级高的实时任务都需要在遍历完列表后才可以知道）</li></ol><h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><p><a href="https://en.wikipedia.org/wiki/Ingo_Moln%C3%A1r" target="_blank" rel="noopener">Ingo Molnár</a> 大佬在 2.6 版本的内核中加入了全新的调度算法，它能够在常数时间内调度任务，因此被称为 O(1) 调度器。我们来看看它引入的一些新特性：</p><ul><li>全局优先级单位，范围是 0~139，数值越低，优先级越高</li><li><strong>将任务拆分成实时（0~99）和正常（100~139）两部分</strong>。更高优先级任务获得更多时间片</li><li><strong>即刻抢占（early preemption）</strong>。当任务状态变成 <code>TASK_RUNNING</code> 时，内核会检查其优先级是否比当前运行的任务优先级更高，如果是的话，则抢占当前正在运行的任务，切换到该任务</li><li><strong>实时任务使用静态优先级</strong></li><li><strong>普通任务使用使用动态优先级</strong>。任务优先级会在其使用完自己的时间片后重新计算，内核会考虑它过去的行为，决定它的交互性等级。交互型任务更容易得到调度</li></ul><p>O(n) 的调度器会在每个纪元结束后（所有任务的时间片都使用过），才会重新计算任务优先级。而 O(1) 则是在每个任务时间片配额用完后就重新计算优先级。O(1) 调度器为<strong>每个 CPU 维护了两个队列，即 active 和 expired</strong>。active 队列存放的是时间片尚未用完的任务，而 expired 则是时间片已经耗尽的任务。当一个任务的时间片用完后，就会被转到 expired 队列，而且会重新计算它的优先级。<strong>当 active 队列任务全部转移到 expired 队列后，会交换二者（让 active 指向 expired 队列，expired 指向 active 队列）</strong>。可以看到，优先级的计算，队列切换都和任务数量多寡无关，能够在 O(1) 时间复杂度下完成。</p><p>在先前介绍的调度算法中，如果想要取一个优先级最高的任务，还需要遍历整个任务链表才可以。而 O(1) 调度器则很特别，它为每种优先级提供了一个任务链表。所有的可运行任务会被分散在不同优先级队应的链表中。</p><p>接下来看看全新的 <code>runqueue</code> 是怎么定义的吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">runqueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running; <span class="comment">/* 可运行的任务总数（某个 CPU） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> *<span class="title">active</span>;</span> <span class="comment">/* 指向 active 的队列的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> *<span class="title">expired</span>;</span> <span class="comment">/* 指向 expired 的队列的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> <span class="title">arrays</span>[2];</span> <span class="comment">/* 实际存放不同优先级对应的任务链表 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过下面的图可以直观感受下任务队列：<br><img src="https://pic4.zhimg.com/v2-a4e9ffb8e01f5adbb240bd0f3e19991f.jpg" alt=""></p><p>接下来看看 <code>prio_array</code> 是怎么定义的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_active; <span class="comment">/* 列表中的任务总数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bitmap[BITMAP_SIZE]; <span class="comment">/* 位图表示对应优先级链表是否有任务存在 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_PRIO</span>];</span> <span class="comment">/* 任务队列（每种优先级对应一个双向链表） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到，在 <code>prio_array</code> 中存在一个位图，它是用来标记每个 priority 对应的任务链表是否存在任务的。接下来看看为何 O(1) 调度器可以在常数时间找到需要运行的任务：</p><ol><li><strong>常数时间确定优先级</strong>：首先会在位图中查找到第一个设置为 1 的位（总共有 140 bits，从第一个 bit 开始搜索，这样可以保证高优先级的任务先得到机会运行），如果找到了就可以确定哪个优先级有任务，假设找到后的值为 <code>priority</code>；</li><li><strong>常数时间获得下一个任务</strong>：在 <code>queue[priority]</code> 对应的任务链表中提取第一个任务来执行（多个任务会轮转执行）。<br><img src="https://pic1.zhimg.com/v2-5dbbda39ff60d26fd2605ef6970dc468.jpg" alt=""></li></ol><p>好了，是时候总结下 O(1) 调度器的优缺点了：</p><ol><li>设计上要比 O(n) 调度器更加复杂精妙；</li><li>相对来说扩展性更好，性能更优，在任务切换上的开销更小；</li><li>用来标记任务是否为交互类型的算法还是过于复杂，且容易出错。</li></ol><h2 id="Staircase"><a href="#Staircase" class="headerlink" title="Staircase"></a>Staircase</h2><p><em>Staircase Scheduler</em> 是 Con Kolivas 为了改善桌面系统交互应用的响应时间而实现的调度器，但它并非内核官方支持的调度器。它的整体设计思想类似于 <em>Operating Systems: The Three Easy Pieces</em> 中提到的 MLFQ（Multilevel Feedback Queue，多级反馈队列）。</p><p>我们来看下它的设计思想：</p><ol><li>首先，它也是将任务按照优先级放在不同的任务链表中（类似上面的 active 队列）</li><li>调度器每次会从最高优先级的任务链表中获取一个要切换执行的任务，当任务时间片使用完毕后，会将其优先级调低一个等级，直到其优先级降到最低。</li><li>当处于最低优先级的任务用光了时间片后，它会被重新放到更高优先级的任务链表中（这个新的优先级是它之前最高优先级减 1 后的值），同时会获得两倍于之前的时间片</li><li>对于长时间睡眠的任务，会被放到最高优先级任务链表。所以交互式任务可以保持在最高优先级位置，从而保持良好的响应性能；而批处理任务则处于低优先级，但是会获得更多的执行时间。</li></ol><h2 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h2><h3 id="单核调度"><a href="#单核调度" class="headerlink" title="单核调度"></a>单核调度</h3><p>CFS 的全称是 Complete Fair Scheduler，也就是完全公平调度器。它实现了一个基于权重的公平队列算法，从而将 CPU 时间分配给多个任务（每个任务的权重和它的 nice 值有关，nice 值越低，权重值越高）。每个任务都有一个关联的虚拟运行时间 vruntime，它表示一个任务所使用的 CPU 时间除以其优先级得到的值。相同优先级和相同 vruntime 的两个任务实际运行的时间也是相同的，这就意味着 CPU 资源是由它们均分了。为了保证所有任务能够公平推进，每当需要抢占当前任务时，CFS 总会挑选出 <code>vruntime</code> 最小的那个任务运行。</p><p>内核版本在 2.6.38 之前，每个线程（任务）会被当成独立的调度单元，并且和系统中其它线程共享资源，这就意味着一个多线程的应用会比单线程的应用获得更多的资源。之后，CFS 不断改进，目前已经支持将一个应用中的线程打包到 cgroup 结构中，cgroup 的 vruntime 是其中所有线程的 vuntime 之和。然后 CFS 就可以将它的算法应用于cgroup 之间，从而保证公平性。当某个 cgroup 被选中后，其中拥有最小 vruntime 的线程会被执行，从而保证 cgroup 中的线程之间的公平性。cgroup 还可以嵌套，例如 systemd 会自动配置 cgroup 来保证不同用户之间的公平性，然后在用户运行的多个应用之间维持公平性。</p><p>CFS 通过在一定时间内运行调度所有的线程来避免饥饿问题。当运行的 线程数在 8 个及以下时，默认的时间周期是 48ms；而当多于 8 个线程时，时间周期就会随着线程数量而增加（6ms * 线程数，之所以选择 6ms，是为了避免频繁抢占，导致上下文切换频繁切换的开销）。由于 CFS 总是会挑选 vruntime 最小的线程执行，它就需要避免某个线程的 vruntime 太小，以至于其它线程需要等待很久才能得到调度（会有饥饿问题）。所以在实践中，CFS 会保证所有线程之间的 vruntime 之差低于抢占时间（6ms），它是通过如下两点来保证的：</p><ol><li>当线程创建时，它的 vruntime 值等于运行队列中等待执行线程的最大 vruntime；</li><li>当线程从睡眠中唤醒时，它的 vruntime 值会被更新为大于或等于所有待调度线程中最小的 vruntime。使用最小 vruntime 还可以保证频繁睡眠的线程优先被调度，这对于桌面系统非常适合，它会减少交互应用的响应延迟。</li></ol><p>CFS 还引入了启发式调度思想来改善高速缓存利用率。例如，当线程被唤醒时，它会检查该线程的 vruntime 和正在运行的线程 vruntime 之差是否非常显著（临界值是 1ms），如果不是的话，则不会抢占当前正在运行的任务。但是这种做法还是以牺牲调度延迟为代价的，算是一种权衡吧。</p><h3 id="多核负载均衡"><a href="#多核负载均衡" class="headerlink" title="多核负载均衡"></a>多核负载均衡</h3><p>在多核环境中，Linux CFS 会将<em>工作（work）</em>分摊到多个处理器核心中执行。但是这不等同于将线程均分到多个处理器。比如，一个 CPU 密集型的线程和 10 个频繁睡眠的线程可能分别在两个核上执行，其中一个专门执行 CPU 密集型线程；而另一个则处理那 10 个频繁睡眠的线程。</p><p>为了多个处理器上的工作量均衡，CFS 使用了 <code>load</code> 指标来衡量线程和处理器的负载情况。线程的负载和线程的 CPU 平均使用率相关：经常睡眠的线程负载要低于不睡眠的线程负载。类似 vruntime，线程的负载也是线程的优先级加权得到的。而处理器的负载是在该处理器上可运行线程的负载之和。CFS 会尝试均衡处理器的负载。</p><p>CFS 会在线程创建和唤醒时关注处理器的负载情况，调度器首先要决定将任务放在哪个处理器的运行队列中。这里也会涉及到启发式思想，比如，如果 CFS 检查到生产者-消费者模型，那么它会将消费者线程尽可能地分散到机器的多个处理器上，因为多数核心都适合处理唤醒的线程。</p><p>负载均衡还会周期性发生，每隔 4ms，每个处理器都会尝试从其它处理器偷取一些工作。当然，这种 work-stealing 均衡方法还会考虑机器的拓扑结构：处理器会尝试从距离它们「更近」的其它处理器上尝试窃取工作，而非距离「更远」的处理器（如远程 NUMA 节点）。当处理器决定要从其它处理器窃取任务时，它会尝试在二者之间均衡负载，并且会窃取多达 32 个线程。此外，当处理器进入空闲状态时，它也会立刻调用负载均衡器。</p><p>在大型的 NUMA 机器上，CFS 并不会粗暴地比较所有 CPU 的负载，而是以分层的方式进行负载均衡。以一台有两个 NUMA 节点的机器为例，CFS 会先在 NUMA 节点内部的处理器之间进行负载均衡，然后比较 NUMA 节点之间的负载（通过节点内部处理器负载计算得到），再决定要不要在两个节点之间进行负载均衡。如果 NUMA 节点之间的负载差距在 25% 以内，则不会进行负载均衡。总结来说，如果两个处理器（或处理器组）之间的距离越远，那么只有在不平衡性差距越大的情况下才会考虑负载均衡。</p><h3 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h3><p>CFS 引入了<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">红黑树</a>（本质上是一棵半平衡二叉树，对于插入和查找都有 O(log(N)) 的时间复杂度）来维护运行队列，树的节点值是调度单元的 vruntime，拥有最小 vruntime 的节点位于树的最左下边。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/2560px-Red-black_tree_example.svg.png" alt=""></p><p>接下来看看 <code>cfs_rq</code> 数据结构的定义（位于 <code>&lt;kernel/sched/sched.h&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 所有任务的累计权重值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="comment">// 表示该队列中有多少个可运行的任务</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_running;</span><br><span class="line">    <span class="comment">// 运行队列中最小的 vruntime</span></span><br><span class="line">    u64 min_vruntime;</span><br><span class="line">    <span class="comment">// 红黑树的根节点，指向运行任务队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">tasks_timeline</span>;</span></span><br><span class="line">    <span class="comment">// 下一个即将被调度的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span></span><br><span class="line">    <span class="comment">// 指向当前正在运行的调度单元</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CFS 算法实际应用于调度单元（这是一个更通用的抽象，可以是线程、cgroups 等），调度单元数据结构定义如下（位于 <code>&lt;include/linux/sched.h&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 表示调度单元的负载权重（比如该调度单元是一个组，则该值就是该组下所有线程的负载权重的组合）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span> <span class="comment">/* for load-balancing */</span></span><br><span class="line">    <span class="comment">// 表示红黑树的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="comment">// 表示当前调度单元是否位于运行队列</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> on_rq;</span><br><span class="line">    <span class="comment">// 开始执行时间</span></span><br><span class="line">    u64 exec_start;</span><br><span class="line">    <span class="comment">// 总共运行的时间，该值是通过 `update_curr()` 更新的。</span></span><br><span class="line">    u64 sum_exec_runtime;</span><br><span class="line">    <span class="comment">// 基于虚拟时钟计算出该调度单元已运行的时间</span></span><br><span class="line">    u64 vruntime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录之前运行的时间之和</span></span><br><span class="line">    u64 prev_sum_exec_runtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="虚拟时钟"><a href="#虚拟时钟" class="headerlink" title="虚拟时钟"></a>虚拟时钟</h3><p>前面提到的 vruntime 究竟是什么呢？为什么叫作虚拟运行时间呢？接下来就要揭开它的神秘面纱。为了更好地实现公平性，CFS 使用了虚拟时钟来测量一个等待的调度单元在一个<strong>完全公平的处理器</strong>上允许执行的时间。然而，虚拟时钟并没有真实的实现，它只是一个抽象概念。</p><p>我们可以基于真实时间和任务的负载权重来计算出虚拟运行时间，该算法是在 <code>update_cur()</code> 函数中实现的，它会更新调度单元的时间记账信息，以及 CFS 运行队列的 <code>min_vruntime</code>（完整定义位于 <code>&lt;kernel/sched/fair.c&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_curr</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">    u64 now = rq_clock_task(rq_of(cfs_rq));</span><br><span class="line">    u64 delta_exec;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!curr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算出调度单元开始执行时间和当前之间的差值，即真实运行时间</span></span><br><span class="line">    delta_exec = now - curr-&gt;exec_start;</span><br><span class="line">    curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);</span><br><span class="line">    update_min_vruntime(cfs_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u64 <span class="title">calc_delta_fair</span><span class="params">(u64 delta, struct sched_entity *se)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务的优先级是默认的优先级（内部 nice 值是 120），那么虚拟运行时间</span></span><br><span class="line">    <span class="comment">// 就是真实运行时间。否则，会基于 `__calc_delta` 计算出虚拟运行时间。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">        <span class="comment">// 该计算过程基本等同于：</span></span><br><span class="line">        <span class="comment">// delta = delta_exec * NICE_0_LOAD / cur-&gt;load.weight;</span></span><br><span class="line">        delta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);</span><br><span class="line">    <span class="keyword">return</span> delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_min_vruntime</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;curr)</span><br><span class="line">        <span class="comment">// 如果此时有任务在运行，就更新最小运行时间为当前任务的 vruntime</span></span><br><span class="line">        vruntime = cfs_rq-&gt;curr-&gt;vruntime;</span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;rb_leftmost)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获得下一个要运行的调度单元</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = <span class="title">rb_entry</span>(<span class="title">cfs_rq</span>-&gt;<span class="title">rb_leftmost</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">struct</span> <span class="title">sched_entity</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">run_node</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (!cfs_rq-&gt;curr)</span><br><span class="line">            vruntime = se-&gt;vruntime;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保证 min_vruntime 是二者之间较小的那个值</span></span><br><span class="line">            vruntime = min_vruntime(vruntime, se-&gt;vruntime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里之所以去二者之间的最大值，是为了保证 min_vruntime 能够单调增长</span></span><br><span class="line">    <span class="comment">// 可以想想为什么需要这样做？</span></span><br><span class="line">    cfs_rq-&gt;min_vruntime = max_vruntime(cfs_rq-&gt;min_vruntime, vruntime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，来总结下使用虚拟时钟的意义：</p><ul><li>当任务运行时，它的虚拟时间总是会增加，从而保证它会被移动到红黑树的右侧；</li><li>对于高优先级的任务，虚拟时钟的节拍更慢，从而让它移动到红黑树右侧的速度就越慢，因此它们被再次调度的机会就更大些。<br><img src="https://pic3.zhimg.com/v2-bcc1970ab1806342e946bf4e9b6ff1d7.jpg" alt=""></li></ul><h3 id="选择下一个任务"><a href="#选择下一个任务" class="headerlink" title="选择下一个任务"></a>选择下一个任务</h3><p>CFS 可以在红黑树中一直找到最左（leftmost）边的节点作为下一个运行的任务。但是真正实现 <code>__pick_first_entity()</code> 的函数其实并没有真正地执行查找（虽然可以在 O(log(N)) 时间内找到），我们可以看下它的定义（完整定义位于 <code>&lt;kernel/sched/fair.c&gt;</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *__<span class="title">pick_first_entity</span>(<span class="title">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 其实这里取的是缓存的 leftmost 节点</span></span><br><span class="line">    <span class="comment">// 所以执行就会更快了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">rb_leftmost</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> rb_entry(left, struct sched_entity, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实时调度器"><a href="#实时调度器" class="headerlink" title="实时调度器"></a>实时调度器</h2><p>Linux 实时任务调度器实现位于 <code>&lt;kernel/sched/rt.c</code>，对于系统而言，实时任务属于贵客，一旦存在实时任务需要调度，那就应当尽可能及时地为它们服务。对于实时任务而言，有两种调度策略存在：</p><ul><li><p><code>SCHED_FIFO</code>: 这个其实就是一个先到先服务的调度算法。这类任务没有时间片限制，它们会一直运行直到阻塞或者主动放弃 CPU，亦或者被更高优先级的实时任务抢占。该类任务总会抢占 <code>SCHED_NORMAL</code> 任务。如果多个任务具有相同的优先级，那它们会以轮询的方式调度（也就是当一个任务完成后，会被放到队列尾部等待下次执行）；</p></li><li><p><code>SCHED_RR</code>: 这种策略类似于 <code>SCHED_FIFO</code>，只是多了时间片限制。相同优先级的任务会以轮询的方式被调度，每个运行的任务都会一直运行，直到其用光自己的时间片，或者被更高优先级的任务抢占。当任务的时间片用光后，它会重新补充能量，并被加入到队列尾部。默认的时间片是 100ms，可以在 <code>&lt;include/linux/sched/rt.h&gt;</code> 找到其定义。</p></li></ul><p>实时任务的优先级是静态的，不会像之前提到的算法，会重新计算任务优先级。用户可以通过 <code>chrt</code> 命令更改任务优先级。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>实时任务有自己的调度单元数据结构（位于 <code>&lt;include/linux/sched.h&gt;</code>），其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> watchdog_stamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> *<span class="title">back</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> *<span class="title">rt_rq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>SCHED_FIFO</code> 的时间片是 0，可以在 <code>&lt;kernel/sched/rt.c&gt;</code> 中看到具体定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sched_rr_timeslice = RR_TIMESLICE;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_rr_interval_rt</span><span class="params">(struct rq *rq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;policy == SCHED_RR)</span><br><span class="line">        <span class="keyword">return</span> sched_rr_timeslice;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">而关于运行队列的定义如下：</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* Real-Time classes' related field in a runqueue: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 所有相同优先级的实时任务都保存在 `active.queue[prio]` 链表中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_nr_running;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span> <span class="comment">/* main runqueue */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is the priority-queue data structure of the RT scheduling class:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* include 1 bit for delimiter */</span></span><br><span class="line">    <span class="comment">// 类似 O(1) 调度器，使用位图来标记对应优先级的链表是否为空</span></span><br><span class="line">    DECLARE_BITMAP(bitmap, MAX_RT_PRIO + <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_RT_PRIO</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>类似于 CFS 中的 <code>update_curr()</code> 函数，<code>update_curr_rt()</code> 函数用来跟踪实时任务的 CPU 占用情况，收集一些统计信息，更新时间片等，但这里使用的是真实时间，而没有虚拟时间的概念。完整定义可以参考 <a href="https://github.com/torvalds/linux/blob/a6ed68d6468bd5a3da78a103344ded1435fed57a/kernel/sched/rt.c#L955" target="_blank" rel="noopener">kernel/sched/rt.c#L955</a>。</p><h2 id="BFS-amp-MuqSS"><a href="#BFS-amp-MuqSS" class="headerlink" title="BFS &amp; MuqSS"></a>BFS &amp; MuqSS</h2><p>关于 BFS 和 MuqSS 的精彩介绍可以参考 <a href="https://mp.weixin.qq.com/s/kI3pFJ3qUgQJ2P_--G3ehQ" target="_blank" rel="noopener">这篇文章</a>，这里不再赘述。<br>总体来说，BFS 是一个适用于桌面或移动设备的调度器，设计地比较简洁，用于改善桌面应用的交互性，减小响应时间，提升用户体验。它采用了全局单任务队列设计，不再让每个 CPU 都有独立的运行队列。虽然使用单个全局队列，需要引入队列锁来保证并发安全性，但是对于桌面系统而言，处理器通常都比较少，锁的开销基本可以忽略。BFS 每次会在任务链表中选择具有最小 virtual deadline 的任务运行。</p><p>MuqSS 是作者后来基于 BFS 改进的一款调度器，同样是用于桌面环境任务调度。它主要解决了 BFS 的两个问题：</p><ol><li>每次需要在对应优先级链表中遍历查找需要执行任务，这个时间复杂度为 O(n)。所以新的调度器引入了跳表来解决该问题，从而将时间复杂度降低到 O(1)。</li><li>全局锁争夺的开销优化，采用 <code>try_lock</code> 替代 <code>lock</code>。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytXicPsWIWNWxe47NbURjISJ8rdLqdPkHHW9vngCa5CojQPoI8s7f3f2V6I1OMBJXB1rbOhlmb6wrg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></li></ol><h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><ul><li>《Linux 设计与实现 第三版》进程调度章节</li><li><a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a></li><li><a href="https://oska874.gitbooks.io/process-scheduling-in-linux/chapter1.html" target="_blank" rel="noopener">Process Scheduling in Linux</a></li><li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">内核文档：CFS Scheduler 设计</a></li><li>Linux 进程与线程：《Linux 系统编程手册 第 28 章及后续》<ul><li>可以关注下和进程线程有关的系统调用</li><li>Pthread 线程是怎么在 Linux 中实现的</li></ul></li><li><a href="https://opensource.com/article/19/2/fair-scheduling-linux" target="_blank" rel="noopener">Linux 公平调度</a><ul><li>对比了传统调度器和 CFS 的区别</li><li>简单介绍了 CFS 的实现</li></ul></li><li><a href="https://www.usenix.org/system/files/conference/atc18/atc18-bouron.pdf" target="_blank" rel="noopener">The Battle of Schedulers: FreeBSD ULE vs Linux CFS</a><ul><li>重点可以看下关于 CFS 的简述 &amp; 负载均衡部分</li><li>可以简单看看 ULE 是的实现原理（interactive, batch queue），为什么可能会有饿死的情况</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/33621500" target="_blank" rel="noopener">NUMA 架构深究</a><ul><li>早期的 x86 是 Universal Memory Arch, UMA 架构</li><li>NUMA 架构出来后，访问不同内存地址，速度是有差别了，和硬件架构有很大关系</li></ul></li><li><a href="https://jin-yang.github.io/post/linux-kernel-scheduler.html" target="_blank" rel="noopener">Kernel 调度系统</a><ul><li>重点关注作者关于 CFS 列出的几个灵魂拷问</li><li>vruntime 在什么时候发生改变？</li><li>vruntime 初始值是怎么设定的？</li></ul></li><li><a href="https://mp.weixin.qq.com/s/kI3pFJ3qUgQJ2P_--G3ehQ" target="_blank" rel="noopener">两个非常有意思的适合桌面使用的 Linux task 调度器: BFS 和 MuqSS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Linux Kernel Development&lt;/em&gt; 一书中，关于 Linux 的进程调度器并没有讲解的很深入，只是提到了 CFS 调度器的基本思想和一些实现细节；并没有 Linux 早期的调度器介绍，以及最近这些年新增的在内核源码树外维护的调度器思想。所以在经过一番搜寻后，看到了这篇论文 &lt;a href=&quot;https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A complete guide to Linux process scheduling&lt;/a&gt;，对 Linux 的调度器历史进行了回顾，并且相对细致地讲解了 CFS 调度器。整体来说，虽然比较啰嗦，但是对于想要知道更多细节的我来说非常适合，所以就有了翻译它的冲动。当然，在学习过程也参考了其它论文。下面开启学习之旅吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="调度器" scheme="http://ifaceless.space/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="CFS" scheme="http://ifaceless.space/tags/CFS/"/>
    
  </entry>
  
  <entry>
    <title>Linux 调度器学习资料整理</title>
    <link href="http://ifaceless.space/2019/11/05/linux-kernel-scheduler-papers/"/>
    <id>http://ifaceless.space/2019/11/05/linux-kernel-scheduler-papers/</id>
    <published>2019-11-05T13:18:35.000Z</published>
    <updated>2019-11-28T09:41:31.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://pic1.zhimg.com/80/v2-43f561d7d0646c34ed8c7bbf6fb52f23_hd.png" alt=""></p><p>系统中的 CPU 数量有限，而用户希望「同时」得到服务的进程（任务）常常会多于可用的 CPU 核数，这时就需要聪明的任务调度器来为我们实现 CPU 虚拟化，让每个进程都能得到服务。调度器需要照顾到任务的响应时间（否则用户会在敲击键盘后等很久，体验很渣），还要保证一定的周转时间（CPU 密集型的任务期望获得更多的连续运行时间，从而利用 CPU 缓存亲和性，频繁的任务切换会导致一些性能损失，尤其是现代系统 TLB miss, Page Fault 惩罚非常严重），同时还不能让某些低优先级的任务饿死。可见调度器是实现多任务的核心，现代操作系统必备。<br><a id="more"></a><br>一直以来，各路 Linux Hackers 都希望能为 Linux 提供这样一个调度器，它能够在桌面系统上有较好的交互性，而在高负载的服务器上有较好的吞吐量。</p><p>以下列举一些学习资料，可以进一步了解！</p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul><li>论文：<a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a>，这篇论文讲得比较好，准备翻译出来以供欣赏</li><li>GitBook: <a href="https://oska874.gitbooks.io/process-scheduling-in-linux/chapter1.html" target="_blank" rel="noopener">Process Scheduling in Linux</a></li><li>内核文档：<a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">Linux scheduler doc, CFS</a></li><li><p>Linux 进程与线程：《Linux 系统编程手册 第 28 章及后续》</p><ul><li>可以关注下和进程线程有关的系统调用</li><li>Pthread 线程是怎么在 Linux 中实现的</li></ul></li><li><p><a href="https://opensource.com/article/19/2/fair-scheduling-linux" target="_blank" rel="noopener">Linux 公平调度</a></p></li><li><p><a href="https://www.usenix.org/system/files/conference/atc18/atc18-bouron.pdf" target="_blank" rel="noopener">The Battle of Schedulers: FreeBSD ULE vs Linux CFS</a></p><ul><li>重点可以看下关于 CFS 的简述 &amp; 负载均衡部分</li><li>可以简单看看 ULE 是的实现原理（interactive, batch queue），为什么可能会有饿死的情况</li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/33621500" target="_blank" rel="noopener">NUMA 架构深究</a></p><ul><li>早期的 x86 是 Universal Memory Arch, UMA 架构</li><li>NUMA 架构出来后，访问不同内存地址，速度是有差别了，和硬件架构有很大关系</li></ul></li><li><p><a href="https://jin-yang.github.io/post/linux-kernel-scheduler.html" target="_blank" rel="noopener">Kernel 调度系统</a></p><ul><li>重点关注作者关于 CFS 列出的几个灵魂拷问</li><li>vruntime 在什么时候发生改变？</li><li>vruntime 初始值是怎么设定的？</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-43f561d7d0646c34ed8c7bbf6fb52f23_hd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;系统中的 CPU 数量有限，而用户希望「同时」得到服务的进程（任务）常常会多于可用的 CPU 核数，这时就需要聪明的任务调度器来为我们实现 CPU 虚拟化，让每个进程都能得到服务。调度器需要照顾到任务的响应时间（否则用户会在敲击键盘后等很久，体验很渣），还要保证一定的周转时间（CPU 密集型的任务期望获得更多的连续运行时间，从而利用 CPU 缓存亲和性，频繁的任务切换会导致一些性能损失，尤其是现代系统 TLB miss, Page Fault 惩罚非常严重），同时还不能让某些低优先级的任务饿死。可见调度器是实现多任务的核心，现代操作系统必备。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="调度器" scheme="http://ifaceless.space/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="CFS" scheme="http://ifaceless.space/tags/CFS/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel Development 学习与总结</title>
    <link href="http://ifaceless.space/2019/10/30/linux-kernel-dev-notes/"/>
    <id>http://ifaceless.space/2019/10/30/linux-kernel-dev-notes/</id>
    <published>2019-10-30T09:47:22.000Z</published>
    <updated>2019-11-28T09:41:31.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近抽时间把 <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener"><em>Operating Systems: Three Easy Pieces</em></a> 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（<em>Linux Kernel Development</em>）后找到想要的答案。当然，在学习中也针对很多部分搜集了不少学习资料，整理在文后，方便加深理解。<br><a id="more"></a><br>在学习之前，思考了一些问题，可以在学习中探索这些问题的答案：</p><ol><li>Linux 中进程、线程是如何实现的？各种调度策略是什么样的？又是怎么实现的呢？</li><li>并发问题肯定需要注意，Linux 中如何应对竞态条件 &amp; 数据竞争呢？各种常见的同步原语又是如何实现的？</li><li>Linux 的内存虚拟化是如何实现的？内存布局？虚拟地址空间？</li><li>文件系统有很多，操作系统是怎么进行抽象，并对用户提供一致优雅的系统调用接口的呢？</li><li>Linux 内核中有哪些非常经典的算法和数据结构的应用？它们使用场景是什么？怎么实现的呢？</li></ol><h1 id="Linux-内核简介"><a href="#Linux-内核简介" class="headerlink" title="Linux 内核简介"></a>Linux 内核简介</h1><p><img src="https://pic4.zhimg.com/80/v2-e0c1aced72034fd29160b2a0dbc73fa5_r.png" alt=""></p><p>说到 Linux，就不得不提到它的祖先 Unix 系统。Unix 在 1970 年左右被 Ken Thompson 首先在一台 PDP-7 机型上实现，而后移植到 PDP-11 机器上，1973 年它被使用 C 语言重写，提供了更加强大的可移植性。</p><p>经过多年发展，Unix 系统成为了一个强大、健壮且稳定的操作系统。其强大的根本原因如下：</p><ol><li>简洁，仅提供数百个设计目标明确的系统调用；</li><li>所有的东西都被当作文件看待</li><li>很强的移植能力</li><li>进程创建非常迅速，拥有独特的 <code>fork()</code> 系统调用</li><li>拥有简单且稳定的进程间通信原语</li></ol><p>Linux 是类 Unix 系统，它的实现和 Unix 也有一些大相径庭的方面，但是它依然继承了 Unix 的设计目标，保证了 API 的一致性（有品位的程序员都应该要学习这一思想）。</p><p>Linux 词汇一般用来指代内核。它的基础包括：</p><ol><li>内核</li><li>C 库</li><li>工具集</li><li>系统的基本工具，如 Shell</li></ol><p>什么是操作系统？宽泛的操作系统是指整个系统中负责完成最基本功能和系统管理的部分，包括<strong>内核、设备驱动、启动引导程序、命令行 Shell 或用户界面、文件管理工具和系统工具</strong>。内核则是那个最亮的仔，它通常由如下几个重要部分组成：</p><ol><li>中断服务</li><li>任务调度程序</li><li>内存管理程序</li><li>网络</li><li>进程间通信等系统服务</li></ol><p>Linux 的中断服务是不在进程上下文执行的，而是在一个与所有进程无关、专门的中断上下文执行。这样可以保证第一时间能够响应和处理中断请求，然后快速退出。</p><p>处理器在任意时间点活动可概括为以下三种之一：</p><ol><li>运行在用户空间，执行用户进程</li><li>运行在内核空间，处于进程上下文，代表某个特定的进程执行（如某个系统调用）</li><li>运行在内核空间，处于中断上下文，与进程无关，处理特定的中断</li></ol><h2 id="微内核和宏内核"><a href="#微内核和宏内核" class="headerlink" title="微内核和宏内核"></a>微内核和宏内核</h2><p>这个是比较有趣的历史了，操作系统设计有两大主要阵营：微内核和宏内核。</p><p>微内核的功能划分成多个独立的过程，每个过程都是一个服务（C/S 模型，服务与内核交互）。系统采用 IPC 禁止互通消息，互换「服务」。服务的独立性可以避免一个服务失败殃及其它服务。模块化设计也非常适合热插拔。但是缺点就是 IPC 的开销多于函数调用（类比微服务的网络开销和在本地调用函数的开销）。</p><p>宏内核则是实用主义者喜欢的设计，它是比较简单的设计，整体上就是一个单独的过程，运行在一个单独的地址空间。内核之间的通信微不足道，性能高。</p><p>Linux 自然是宏内核设计，Linux 内核运行在单独的内核地址空间上。同时它也采纳了微内核的精华，使它成为模块化的、多线程的以及内核本身可调度的操作系统。</p><h2 id="与传统-Unix-区别"><a href="#与传统-Unix-区别" class="headerlink" title="与传统 Unix 区别"></a>与传统 Unix 区别</h2><ol><li>支持动态加载内核模块（这个不是微内核宣称的好处吗？咱也有）</li><li>支持对称多处理机制（SMP）</li><li>内核可以抢占（preemptive）：任务可以有优先级</li><li>对多线程的支持很特别：内核不区分线程和一般的进程，对于内核而言，所有的进程都一样，只是其中的一些共享资源而已</li><li>具有设备类的面向对象的设备模型、热插拔事件，用户空间的设备文件系统（sysfs）</li><li>忽略了一些拙劣特性</li><li>自由：任何改变都必须要能通过简洁的设计及正确可靠的实现来解决现实中确实存在的问题</li></ol><h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p><code>&lt;主版本&gt;.&lt;从版本&gt;.&lt;修订&gt;[.&lt;稳定版本号&gt;]</code>，其中<strong>从版本号</strong>为偶数，则为稳定版本，否则为开发版本。</p><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以使用的配置方式如下：</p><ol><li><code>make config</code></li><li><code>make menuconfig1</code></li><li><code>make gconfig</code></li><li>默认配置：<code>make defconfig</code></li></ol><p>验证和更新配置：<code>make oldconfig</code></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol><li>直接编译：<code>make</code></li><li>导出不关心的 info：<code>make &gt;/dev/null</code></li><li>指定并行编译数量：<code>make -j4 &gt;/dev/null</code></li></ol><h2 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h2><ol><li>不能使用标准 C 库</li><li><p>必须使用 GNU C（需要用到它的一些扩展特性）</p><ol><li><code>inline</code>：通常将对时间要求比较高，函数本身比较短的定义成内联函数。在内核中，为了类型安全和易读性，优先使用 inline 函数，而非复杂的宏</li><li>内联编译：支持使用 <code>asm()</code> 嵌入汇编代码</li><li>分支声明：可以使用 <code>likely()</code> 和 <code>unlikely()</code> 声明分支是否经常出现或很少出现，指导编译器进行优化（要搞清楚，否则优化反而变成了拖累）</li></ol></li><li><p>缺乏像用户空间中的内存保护机制</p><ol><li>内核中发生内存错误会导致 oops，内核可能会死掉</li><li>内核中的内存是<strong>不分页</strong>的，每用掉一个字节，物理内存就减少一个字节</li></ol></li><li><p>难以执行浮点数计算</p><ol><li>不能像用户空间执行浮点数计算那样，可以通过 trap 的方式将整数模式转换到浮点数模式计算</li><li>内核不能完美支持浮点数计算，本身也无法陷入。非要执行的话，就需要手动保存和恢复浮点寄存器，非常麻烦</li></ol></li><li><p>内核给每个进程<strong>只有一个很小的定长堆栈</strong></p><ol><li>用户空间的栈可以动态增长，可支持非常大的数据结构</li><li>内核栈的大小和体系结构有关（如 x86 可以是 4KB/8KB）</li><li>历史上来说，内核栈大小是两页，32 位是 8KB，64 位是 16KB；每个处理器都有自己的栈</li></ol></li><li><p>由于要支持异步中断、抢占和 SMP，时刻需要注意并发安全和同步</p></li><li>考虑可移植性<ol><li>保持字节序</li><li>64 位对齐</li><li>不假定字长和页面长度</li></ol></li></ol><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><ol><li>内核把进程的列表存放在 task list 双向链表中，每个 entry 的类型是 <code>task_struct</code>，被称为 <code>process descriptor</code></li><li>通过 slab（更新的应该是 SLUB） 分配器分配 task_struct 结构体（对象复用和缓存着色），每个任务的 <code>thread_info</code> 位于内核栈的尾端，其中包含指向 <code>task_struct</code> 的指针及其它信息</li><li>进程通过 PID 进行区分，其值存放在 <code>process descriptor</code> 中。由于进程处理代码需要频繁访问 <code>task_struct</code> 信息，所以在 PowerPC 等机器上，有专门的寄存器存储了相应的指针；而在 x86 体系下，则是利用内核栈尾创建的 <code>thread_info</code>，并借助偏移计算间接查找 <code>task_struct</code> 结构体</li><li><p>进程状态：</p><ol><li>TASK_RUNNING</li><li>TASK_INTERRUPTABLE</li><li>TASK_UNINTERRUPTABLE</li><li>__TASK_TRACED: 被其它进程跟踪的进程（如 ptrace 对调试程序进行跟踪）</li><li><p>__TASK_STOPPED: 进程停止执行，没有投入运行也无法投入运行</p><p><img src="https://pic2.zhimg.com/80/v2-ad2075f3f165ab1ab983605446be9b28_r.png" alt=""></p></li></ol></li><li><p>所有的进程都是 PID 为 1 的 init 进程的后代，init 进程的描述符是作为 init_task 静态分配的（比较特殊）</p></li><li><p>Unix 系统进程创建：</p><ol><li>通过 <code>fork()</code> 拷贝当前进程创建一个子进程（区别父进程：有新的 PID，有某些资源和统计量）</li><li><code>exec()</code> 函数负责读取可执行文件并将其载入地址空间开始运行</li></ol></li><li><p>写时拷贝：内核并非开始就复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝，只有在需要写入的时候，数据才会被复制，从而拥有各自的拷贝。<code>fork()</code> 实际开销：复制父进程的页表，给子进程创建唯一的进程描述符</p></li><li>Linux 中的 <code>fork()</code> 和 <code>vfork()</code> 都是通过 <code>clone()</code> 系统调用实现的。<code>vfork()</code> 的特点是：不拷贝父进程的页表，且子进程作为父进程的单独线程在它的地址空间执行，父进程阻塞直到子进程退出或执行 <code>exec()</code></li><li><p>Linux 中的线程实现：</p><ol><li>从内核角度看，没有线程的概念，所有的线程都当作进程看待，只是与其它进程共享某些资源。每个线程都拥有属于自己的 task_struct</li><li>其它系统中，线程被抽象成一种耗费资源较少的资源，运行迅速的执行单元</li><li>通过 <code>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</code> 创建线程</li><li>对比 <code>fork()</code> 实现：<code>clone(SIGCHLD, 0)</code></li><li>对比 <code>vfork()</code> 实现：<code>clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)</code></li></ol></li><li><p>内核线程：</p><ol><li>内核通常需要在后台执行一些操作，这些任务可通过 kernel thread 完成。这种是运行在内核空间的标准进程</li><li>内核线程没有独立的地址空间，可被调度，可被抢占</li></ol></li><li><p>进程终结：</p><ol><li>通常通过 <code>do_exit()</code> 完成退出，期间会释放相关的资源，最终将进程状态设置为 <code>EXIT_ZOMBIE</code>，但是此时的内核栈、thread_info 和 task_struct 结构体还是存在的，从而给父进程提供信息</li><li>父进程获得已终结的子进程信息后（父进程可通过 <code>wait()</code> 系统调用收集信息），或者通知内核它不关注这些信息，才会释放剩余的内存空间</li></ol></li><li><p>孤儿进程：</p><ol><li>退出时永远处于僵死状态，白白浪费内存</li><li>解决办法就是在当前线程组寻找某个线程作为父亲，实在不行，就让 init 接盘</li></ol></li></ol><h2 id="调度进程"><a href="#调度进程" class="headerlink" title="调度进程"></a>调度进程</h2><ol><li><p>多任务系统分为两类：</p><ol><li>非抢占式多任务（cooperative multitasking）</li><li>抢占式多任务（preemptive multitasking）</li></ol></li><li><p>进程调度策略会关心进程的优先级、时间片</p></li><li>Linux 中的进程分为普通进程和实时进程，其中前者的优先级在 (-20, +19），而后者则是 (0, 99)。此外，实时进程的优先级总是高于普通进程优先级的，所以普通进程的优先级映射过来就是 (100, 139)</li><li>Linux 中可以通过 <code>nice</code> 调整进程的优先级，越小的值拥有越高的权重；反之，则权重越低（体现在时间片上）</li></ol><h3 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h3><ol><li>Linux 2.6 内核引入了 CFS 调度器（位于 <code>sched/fair.c</code>）作为普通进程的调度器，它是一个近乎完美的公平调度器（权衡周转时间和响应时间）。并非采用时间片进行分配，而是给进程分配了处理器使用的比重，从而确保进程调度中能够有恒定的公平性，从而将切换频率置于不断变动中</li><li>CFS 基于一个简单的理念：进程调度的效果应该等同于系统拥有一个完美的多任务处理器，每个进程都能获得 1/n_running 处理器时间</li><li>CFS 允许每个进程运行一段时间，循环轮转，总是选择 vruntime 最小的进程作为下一个执行。也就是说，是通过所有可运行经常总数为基础来计算出进程应该运行多久，而非依靠 nice 值来计算时间片（传统的做法就是这种）</li><li>调度器实现概要：<ol><li><code>sched_entity</code> 结构体跟踪运行记账（其中包含 vruntime）</li><li>所有可运行的进程都位于一棵黑红树中（O(logN) 时间复杂度查找），并且每次都会从树的最左叶子节点上（leftmost）找到 vruntime 最小的那个进程运行（实时上，这个值是提前缓存好的）</li><li>调度器入口处会找到最高优先级的调度类，然后获取到谁是下一个该运行的进程</li><li>睡眠：进程会把自己标记成休眠状态，从可执行红黑树中溢出，并放入等待队列，调用 <code>schedule()</code> 执行一个其他进程</li><li>唤醒：进程被设置为可执行状态，从等待队列移除，添加到可执行红黑树</li></ol></li><li>CFS 实现了如下几种调度策略：<ol><li>SCHED_NORMAL（以前叫做 SCHED_OTHER）：用于普通任务调度</li><li>SCHED_BATCH：并非像普通任务那样被频繁抢占，会尽可能允许任务运行足够长时间，从而利用上 CPU 亲和性以及更好地复用缓存</li><li>SCHED_IDLE：这种任务优先级比 nice 19 还要低</li></ol></li></ol><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ol><li>用户抢占（检查 need_resched 标识符）：从系统调用返回用户空间时；从中断处理返回用户空间时</li><li>内核抢占（thread_info 中存在 preemt_count 计数器，表示有没有锁被持有）：就是调度程序能够在内核任务执行期间被执行<ol><li>只要重新调度是安全的（没有持有锁），内核就可以在任何时间抢占正在执行的任务</li><li>内核抢占时机：<ol><li>中断处理程序正在执行，且返回内核空间之前</li><li>内核代码再次具有可抢占性时</li><li>内核任务显式调用 <code>schedule()</code></li><li>内核中的任务阻塞（此时会导致调用 <code>schedule()</code>）</li></ol></li></ol></li></ol><h3 id="实时调度器"><a href="#实时调度器" class="headerlink" title="实时调度器"></a>实时调度器</h3><ol><li>实时调度器是在 <code>sched/rt.c</code> 中实现的，它使用了 100 个运行队列（对应 1~99 任务优先级），实现了 SCHED_FIFO 和 SCHED_RR 策略。</li><li><p>SCHED_FIFO:</p><ol><li>简单的先入先出调度算法，不依赖时间片</li><li>该级别任务比 SCHED_NORMAL 级别的进程先得到调度</li><li>一旦任务处于执行期间，就会一直执行下去；只有更高优先级的 SCHED_FIFO/SCHED_RR 任务才可以抢占</li></ol></li><li><p>SCHED_RR:</p><ol><li>类似 FIFO，但是每个任务会有分配的时间片，时间片耗尽后就要换其它任务执行</li><li>对于 FIFO 进程，高优先级始终抢占低优先级进程；低优先级进程不能抢占 SCHED_RR 进程，即便其耗尽了时间片</li></ol></li><li><p>Linux 提供的是软实时工作方式，尽力使得进程能够在限定的时间到来前执行，但内核不保证总能满足这些进程的要求</p></li></ol><h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>调度器类需要实现一些 hooks，这样可以在需要的时候做合适的操作。部分 hooks 如下：</p><ul><li><code>enqueue_task</code></li><li><code>dequeue_task</code></li><li><code>yield_task</code></li><li><code>check_preempt_cur</code></li><li><code>pick_next_task</code></li><li><code>set_curr_task</code></li><li><code>task_tick</code></li></ul><h3 id="调度相关的-syscall"><a href="#调度相关的-syscall" class="headerlink" title="调度相关的 syscall"></a>调度相关的 syscall</h3><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>nice()</td><td>设置进程的 nice 值</td></tr><tr><td>sched_setscheduler()</td><td>设置调度策略</td></tr><tr><td>sched_getscheduler()</td><td>获取调度策略</td></tr><tr><td>sched_setparam()</td><td>设置实时优先级</td></tr><tr><td>sched_getparam()</td><td></td></tr><tr><td>sched_rr_get_interval()</td><td>时间片值</td></tr><tr><td>sched_setaffinity()</td><td>设置处理器亲和力</td></tr><tr><td>sched_getaffinity()</td><td>获取进程处理器亲和力</td></tr><tr><td>shced_yield()</td><td>暂时让出处理器</td></tr></tbody></table><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>众所周知，进程是在操作系统提供的用户空间运行的，而如果需要打开文件等操作，需要通过系统调用，陷入到内核态，由操作系统代替完成和硬件的交互，从而为进程提供服务。所以说，系统调用时在用户空间和进程和硬件设备之间的一个中间层。这个中间层的主要作用如下：</p><ol><li>为用户空间提供硬件接口抽象</li><li>系统调用保证系统的安全和稳定</li><li>操作系统可以掌控进程的硬件访问意图，并且代劳</li></ol><p>那么系统调用又是如何实现的呢？一句话总结为：<strong>当系统调用执行时，会陷入到内核，传递系统调用号和参数，执行正确的系统调用函数，并且把返回值带回用户空间。</strong>可见，系统调用非常特殊，完全不同于常规的函数调用，看起来非常 Hack。</p><p>接下来，通过几个问题，加深对上述描述的理解：</p><ol><li><strong>如何陷入到内核？</strong>通过软中断的方式实现，通过引发一个异常触发系统切换到内核态执行异常处理程序。</li><li><strong>什么是系统调用号？</strong>在 Linux 中，每个系统调用都被赋予了一个编号，进程其实是通过系统调用号而不是名称来告知内核自己中意哪个系统调用的。</li><li><strong>如何传递系统调用号？</strong>通过寄存器传递，在 x86 中，就是将系统调用号放在 eax 寄存器传递给内核的。</li><li><strong>参数是如何传递的？</strong>    <ol><li>第一种方式就是将参数放在寄存器中，一般来说系统调用参数不会很多。在 x86 中，可以用 ebx, ecx, edx, esi 和 edi 按顺序存放五个参数。</li><li>第二种方式就是将参数存放在用户空间内存中，并将参数指针存放在寄存器中。这种是为了应付参数超过 6 个情况。</li></ol></li><li><strong>返回值如何带给用户空间？</strong>当然也是通过寄存器来传递的，在 x86 中，可以使用 eax 寄存器。</li></ol><h1 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h1><p><img src="https://pic1.zhimg.com/80/v2-2bbaf34ff51ed6c19c0390d1fd118b40_hd.png" alt="内核数据结构"></p><p>Linux 内核链表实现独树一帜。它是将链表塞入到数据结构，而非常规的那种在数据结构中塞入链表。</p><p>可以看下对比就知道为何特别了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规定义方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux 内核链表定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 所有的 node 形成链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通用的链表操作就可以基于 <code>struct list_head</code> 来实现了。那如何和根据链表指针获得对应的 <code>node</code> 呢？答案是通过 <code>container_of()</code> 宏，实际上 C 语言中，一个给定结构体中的变量偏移在编译时就已经确定了，所以可以借此获得父结构中的任意变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(ptr, type, member) (&#123; \</span><br><span class="line">    const typeof( ((type *)0)-&gt;member) *__mptr = (ptr); \</span><br><span class="line">    (type *)( (char *)__mptr - offsetof(type, member) );&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h1><p><img src="https://pic4.zhimg.com/80/v2-78cb6999358bdd22b1a00c221f1d606e_r.png" alt=""></p><p>中断是各种硬件设备与处理器协同高效工作的方式之一。处理器执行指令的速度非常快，而一些外部设备则会慢很多；为了能够保证 CPU 不浪费时间轮询设备状态，而降低利用率，所以需要中断机制来通知 CPU。当处理器接收到中断后，会去执行已注册的相关中断处理程序。</p><p>需要注意的是，中断和前面提到的异常（Fault）是不同的：</p><ol><li>中断通常是异步发生的，不考虑时钟同步；</li><li>异常则必须与处理器时钟同步，所以也被称为同步中断（如除 0 错误、缺页）。</li></ol><p>Linux 中对于中断的响应和处理分成<strong>上半部</strong>和<strong>下半部</strong>。其中上半部会在接收到中断信号后快速完成必要工作的（有严格的时限），而更加繁重的任务则会在下半部执行。在上半部需要快速执行，且无法睡眠；但下半部则没有这样的限制。</p><h2 id="无须重入"><a href="#无须重入" class="headerlink" title="无须重入"></a>无须重入</h2><p>Linux 中的中断处理不用考虑重入，因为当给定中断处理程序在执行时，对应中断线在所有处理器上被屏蔽，避免同一中断线接收另外的中断。这样做简化了中断处理程序的编写。</p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>所谓的中断上下文（interrupt context），就是在执行中断处理程序时，内核所处的上下文。中断上下文和进程上下文没有半毛钱关系，我们可以把它和进程上下文进行一番对比：</p><table><thead><tr><th>中断上下文</th><th>进程上下文</th></tr></thead><tbody><tr><td>执行中断处理程序时，内核所处的上下文</td><td>内核代表进程执行（系统调用、运行内核线程）时，所处的操作模式</td></tr><tr><td>与进程无瓜，与 current 宏无瓜</td><td>可通过 current 宏关联当前进程</td></tr><tr><td>没有后备进程，无法睡眠，也不能调用会导致睡眠的函数</td><td>可睡眠，可调用调度程序</td></tr><tr><td>有严格的执行时限</td><td>没有非常严格的要求</td></tr></tbody></table><h2 id="下半部及推后执行的工作"><a href="#下半部及推后执行的工作" class="headerlink" title="下半部及推后执行的工作"></a>下半部及推后执行的工作</h2><p>下半部就是执行和中断处理相关，但是中断处理程序中不会执行的工作。引入下半部的目的就是让中断处理程序尽可能地简短、快速，避免屏蔽中断太久，导致系统的响应能力和性能受到影响；而比较繁重的工作可以在下半部执行。</p><p>下半部主要实现方式：</p><ol><li><strong>软中断</strong><ol><li>对于时间要求严格，且能自己高效完成加锁的工作，可使用软中断（如网络、SCSI）</li><li>软中断执行期间，允许响应中断，但它自身<strong>不能睡眠</strong></li></ol></li><li><strong>tasklet</strong><ol><li>基于软中断实现，同一个处理程序的多个实例不能再多个处理器同时运行</li><li>用途广泛，接口简单，性能不错</li><li>不能睡眠</li></ol></li><li><strong>工作队列</strong>中的工作可以交给内核线程推后执行（会在进程上下文执行），可以利用进程上下文的优势，且可以重新调度和睡眠</li></ol><h1 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h1><p>在进行内核编程时，时刻需要注意并发带来的问题，需要能够正确识别临界区，正确加锁、解锁，保证关键数据结构不被错误修改。那么有哪些情况能造成并发问题呢？</p><ol><li><strong>中断</strong>：异步发生，会中断当前正在执行的代码</li><li><strong>软中断和 tasklet</strong>：内核会在任意时刻唤醒软中断和 tasklet，打断当前正在执行的代码</li><li><strong>内核抢占</strong>：内核中的任务可能被其它任务抢占</li><li><strong>睡眠及与用户空间同步</strong>：在内核中执行的进程可能会睡眠，从而导致调度程序被唤醒，并运行新的用户进程</li><li><strong>SMP</strong>：多个处理器会并行执行</li></ol><p><img src="https://pic3.zhimg.com/80/v2-de0df74c2c0f79723ab558d3b2727e71.png" alt=""></p><h1 id="定时器和时间管理"><a href="#定时器和时间管理" class="headerlink" title="定时器和时间管理"></a>定时器和时间管理</h1><p>内核需要在硬件（RTC 和 Timer）的帮助下才能计算和管理时间，内核通过<strong>已知的</strong>（这个时钟周期是可编程的，可确定的）时钟中断间隔来计算 wall time 和 jiffies（系统启动以来的节拍总数）。那么，在时钟中断发生时究竟会做哪些工作呢？以下给出一些会周期执行的工作：</p><ol><li>更新系统运行时间和实际时间</li><li>对于 SMP 系统，需要均衡各处理器上的任务队列，如果运行队列负载不均衡，需要尽量让它们均衡</li><li>检查当前进程是否用尽了自己的时间片，如果时，则重新进行调度</li><li>运行超时的动态定时器</li><li>更新资源消耗和处理器时间统计值</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>内核是把物理内存分页管理的，也就是说页（page）是最基本的管理单元。MMU 也是以页大小为单位转换虚拟地址到硬件地址的。不同的体系结构，页大小不同，一般 32 位系统是 4KB，64 位系统是 8KB。</p><h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>因为硬件存在限制，内核无法对所有的页一视同仁。因此需要把页划分成不同的区（zone），内核需要处理如下因为硬件缺陷而引起的内存寻址问题：</p><ol><li>一些硬件只能用特定的内存地址执行 DMA 操作</li><li>一些体系结构的内存物理寻址范围比虚拟地址范围大</li></ol><p>内核的分区有四种：</p><ol><li><strong>ZONE_DMA</strong>：可执行 DMA 操作的页集合</li><li>ZONE_DMA32：同上，但仅限于 32 位设备</li><li><strong>ZONE_NORMAL</strong>：能够正常映射的页</li><li>ZONE_HIGHMEM：高端内存区域，其中的页不能永久映射到内核地址空间（这里限于 32 位地址空间，64 位就不会有问题了）</li></ol><h2 id="页申请和释放"><a href="#页申请和释放" class="headerlink" title="页申请和释放"></a>页申请和释放</h2><ol><li><code>alloc_page(gfp_mask)</code>：只分配一页，返回指向页结构的指针</li><li><code>alloc_pages(gfp_mask, order)</code>：分配 2^order 个连续页</li><li><code>__get_free_page(gfp_mask)</code>：只分配一页，返回指向其逻辑地址的指针</li><li><code>__get_free_pages(gfp_mask, order)</code>：分配 2^order 个连续物理页，返回逻辑地址指针</li><li><code>get_zeroed_page(gfp_mask)</code>：只分配一页，且填充 0 ，返回逻辑地址指针</li><li><code>__free_pages(struct page *page, unsinged int order)</code></li><li><code>free_pages(unsigned long addr, unsinged int order)</code></li><li><code>free_page(unsigned long addr)</code></li></ol><h2 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h2><p><code>void *kmalloc(size_t size, gfp_t flags)</code>，<code>kmalloc()</code> 类似于 <code>malloc()</code>，可以获得指定字节大小的内核内存，它分配得到的页的物理地址是连续的，所以虚拟地址也是连续的。<br><code>void kfree(const void *ptr)</code> 释放分配的内存空间</p><p>关于标记位，常用的是 GFP_KERNEL，允许睡眠，用于进程上下文空间；另外的 GFP_ATOMIC，则不可以睡眠，可用于进程上下文、中断处理程序、软中断、tasklet。</p><h2 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h2><p><code>vmalloc()</code> 类似 <code>kmalloc()</code>，不同的是，它分配的内存虚拟地址虽然是连续的，但是实际的物理地址无需连续。它通过分配非连续的物理内存，再「修正」页表，从而把内存映射到逻辑地址空间连续的区域。它需要专门的页表来完成连续虚拟地址到实际非连续物理地址的映射，开销较大，且容易引起 TLB 抖动，通常在内核中更倾向于使用 <code>kmalloc()</code>。</p><h2 id="slab-层"><a href="#slab-层" class="headerlink" title="slab 层"></a>slab 层</h2><p>slab 层充当通用数据结构的缓存层的角色，它会为不同的对象划分成不同的高速缓存组，每组存放不同类型的对象。比如，存放 task_struct 和 inode 就分属于不同的组。kmalloc() 也是基于 slab 层之上，使用了一组通用高速缓存。</p><p>slab 分配器引入的目的：</p><ol><li>避免频繁使用的对象需要频繁分配和释放，降低开销</li><li>频繁分配回收容易导致内存碎片，减少碎片问题</li><li>提高性能</li><li>部分缓存专属于某个处理器时，可以实现无锁分配和释放（tcmalloc）</li></ol><p><img src="https://pic1.zhimg.com/80/v2-1540217805cb1d2ee083d293209bbbaf_r.png" alt=""></p><h1 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h1><p>VFS 是 Linux 提供的一个文件系统抽象层，涵盖了任何文件系统的常用功能集和行为，从而支持各种实际的文件系统（如 NTFS, FAT, EXT4）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户空间 write() -&gt; VFS sys_write() -&gt; 文件系统的写方法 -&gt; 存储设备</span><br></pre></td></tr></table></figure></p><p>Unix 文件系统传统抽象概念：File, DirectoryEntry, Index Node 和 Mount Point。Unix 文件的特点是面向字节流抽象设计的，具有简单、灵活的特性。在 Unix 中，目录也是普通文件，其列出了包含在目录中所有文件。</p><p>VFS 中的主要对象：</p><ol><li>超级块对象，代表具体已安装的文件系统</li><li>索引节点对象，代表一个具体的文件</li><li>目录项对象，代表一个目录项，是路径的组成部分</li><li>文件对象，代表由进程打开的文件（其实它会指向目录项对象，而目录项对象才是真正表示已打开的实际文件，因为其中包含了指向 inode 的指针）</li></ol><h1 id="块-I-O"><a href="#块-I-O" class="headerlink" title="块 I/O"></a>块 I/O</h1><p>Linux 中，设备分为三类：</p><ol><li><strong>块设备</strong>：支持随机访问固定大小的数据块，如硬盘、闪存</li><li><strong>字符设备</strong>：以字符流的形式被访问，如键盘</li><li><strong>网络设备</strong></li></ol><p>需要注意的是，针对块设备的请求会被操作系统挂起在 I/O 请求队列上，并且由 I/O 调度程序来管理请求队列。它会决定请求队列中的请求<strong>如何排序</strong>，以及<strong>何时</strong>发送到具体的块设备。之所以这么做，就是期望借助 I/O 调度程序，对请求进行<strong>合并</strong>和<strong>排序</strong>，从而有效提高系统的整体性能（也可能造成某些请求得不到公平对待，甚至出现饥饿的情况）。以下记录的是 Linux 中已经实现的几种 I/O 调度算法：</p><ol><li><p><strong>Linus 电梯</strong></p><ol><li>支持向前和向后合并（通常都是这种居多）</li><li>有较好的全局吞吐量</li><li>会发生请求饥饿问题</li></ol></li><li><p><strong>最终期限（deadline） I/O 调度</strong></p><ol><li>降低了系统的全局吞吐量</li><li>读请求超时 500ms，写请求超时 5s，超时必然得到服务，避免长时间饥饿的问题</li></ol></li><li><p><strong>预测（anticipatory） I/O 调度</strong></p><ol><li>目标是保持较好的读响应同时，提供良好的全局吞吐量。视图减少在进行 I/O 操作期间，处理新到的读请求带来的寻址数量</li><li>请求提交后不会直接返回处理其它请求，而会空闲片刻（几毫秒），等待应用提交其它读请求</li></ol></li><li><p><strong>完全公平排队 I/O 调度（CFQ）</strong></p><ol><li>为特殊工作负载的场景设计，每个进程都有自己的请求队列</li><li>以时间片轮转调度队列，处理队列中的请求</li></ol></li></ol><h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>现代操作系统通过采用虚拟内存技术，为每个进程提供了独立的地址空间，从而给每个进程营造了独享内存的假象，这是内存虚拟化的重要机制。需要注意的是，现代采用虚拟内存的系统通常都使用平坦地址空间，而非分段式的内存模式。</p><p>值得注意的是，内存地址空间会根据需要划分成不同的区域。内核可以给进程地址空间动态添加或减少内存区域。每个进程只能访问有效内存区域内的内存地址，每个内存区域会包含权限等属性。<strong>进程中任意有效地址只能位于唯一的区域，且这些区域不能相互覆盖</strong>。</p><p>内存区域可以包含各种内存对象：</p><ol><li>可执行文件代码的内存映射，text section</li><li>可执行文件已初始化全局变量的内存映射，data section</li><li>包含未初始化的全局变量，BSS 段的零页的内存映射</li><li>进程用户空间栈的零页内存映射</li><li>每个一个诸如 C 库或动态连接程序等共享的  text section, data section 和 bss 也被载入到进程地址空间</li><li>内存映射文件</li><li>共享内存段</li><li>匿名映射，如 malloc() 分配的内存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mm_struct -&gt; vm_area_struct</span><br></pre></td></tr></table></figure><h2 id="64-位系统进程地址空间布局"><a href="#64-位系统进程地址空间布局" class="headerlink" title="64 位系统进程地址空间布局"></a>64 位系统进程地址空间布局</h2><p><img src="https://pic4.zhimg.com/80/v2-5f2b9c321b7100a11e2dae9e48bce81f_r.png" alt=""><br>每一个进程都有 64bit 的地址空间，其中用户空间可以使用一半的地址空间（128 TiB），而另一半则是内核空间使用。内核通常驻留在内存中，并且会被映射到每个进程的虚拟内存当中。而在内核中，所有的内核线程都共享一个地址空间。详细的内存布局可以参考后面的学习资料~</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>Linux 中使用三级页表完成地址转换，使用多级页表可以节约地址转换需要占用的空间。但由于完成虚拟页地址到物理页地址转换都需要在三级页表中查找到映射，开销比较高。所以很多体系结构提供了 TLB 作为地址映射的硬件缓存。<br><img src="https://pic4.zhimg.com/80/v2-e7ae1f0fcc4b3a1d0af4e65a1ca04101_r.png" alt=""><br><img src="https://pic4.zhimg.com/80/v2-ff24fef84f1c136922f8bf1f5679ea99_hd.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体上来说，这本书还是比较适合对操作系统基本概念有一定了解，且对于 Linux 内核也有一点了解的前提下阅读，否则在看到一些概念的时候会比较吃力。比如对于进程、线程的抽象定义，虚拟内存中讲到的分页、分段概念以及多级页表的概念。另外，对于常用数据结构需要有清晰的认识；并发相关的同步问题也有了解。<br>虽然整本书是基于 Linux 2.6.3x 内核为基础的，如今的 Linux 内核已经发展到 5.x 时代了，这期间变化肯定有很多。但这本书的价值还是存在的，其中讲得很多思想、方法依然实用，可以变通地去看待和理解。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol><li>POSIX: Portable Operating System Interface</li><li>TLB: Translation Lookup Buffer</li><li>CFS: Complete Fair Scheduler</li><li>CFQ: Complete Fair Queueing，这个是 IO 调度器之一</li><li>VFS: Virtual File System</li><li>VMA: Virtual Memory Area</li><li>MMU: Memory Map Unit</li><li>jiffies: Linux 中用来记录系统启动以来的节拍数的全局变量，还有一个 jiffies_64</li><li>ISR: Interrupt Service Routine</li></ol><h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><ul><li>《Linux 内核设计与实现 Linux Kernel Development，第 3 版》</li><li><a href="https://unix.stackexchange.com/questions/364660/are-threads-implemented-as-processes-on-linux" target="_blank" rel="noopener">Are Threads Implemented As Processes on Linux</a></li><li><a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">POSIX 线程</a></li><li><a href="https://juejin.im/post/5d23326d6fb9a07efe2de11e" target="_blank" rel="noopener">Linux 线程实现</a></li><li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener">Linux Sched Doc CFS</a></li><li><a href="https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf" target="_blank" rel="noopener">A complete guide to Linux process scheduling</a></li><li><a href="https://www.win.tue.nl/~aeb/linux/lk/lk-9.html" target="_blank" rel="noopener">Linux Memory</a></li><li><a href="https://www.it.iitb.ac.in/frg/wiki/images/f/fc/113050076_Rajesh_Prodduturi_week5_presentation_3_2012-08-04.pdf" target="_blank" rel="noopener">Linux memory management</a></li><li><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="noopener">x86_64 内存映射</a></li><li><a href="https://simonis.github.io/Memory/" target="_blank" rel="noopener">The Memory Layout of a 64-bit Linux Process</a></li><li><a href="https://stackoverflow.com/questions/55443733/linux-kernel-memory-layout" target="_blank" rel="noopener">Linux kernel memory layout</a></li><li><a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html" target="_blank" rel="noopener">Chapter 3 Page Table Management</a></li><li><a href="https://ifaceless.space/2019/11/18/linux-kernel-scheduler-papers/">Linux 调度器资料整理</a></li><li><a href="https://makelinux.github.io/kernel_map/" target="_blank" rel="noopener">Linux Kernel Map</a></li><li><a href="https://hackernoon.com/entering-god-mode-the-kernel-space-mirroring-attack-8a86b749545f" target="_blank" rel="noopener">Entering God Mode — The Kernel Space Mirroring Attack</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近抽时间把 &lt;a href=&quot;http://pages.cs.wisc.edu/~remzi/OSTEP/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Operating Systems: Three Easy Pieces&lt;/em&gt;&lt;/a&gt; 终于看完了（其实 2017 年就知道它了，没想到拖到了 2019 年 😅），全书分三个部分（虚拟化、并发、持久化）对操作系统的一些通用设计思想进行了介绍，学完后，对于进程、内存虚拟化、并发、文件系统有了更加深刻的认识。但是，真实的世界是什么样子的呢？这就是希望在阅读《Linux 设计与实现》（&lt;em&gt;Linux Kernel Development&lt;/em&gt;）后找到想要的答案。当然，在学习中也针对很多部分搜集了不少学习资料，整理在文后，方便加深理解。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ifaceless.space/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ifaceless.space/tags/Linux/"/>
    
      <category term="调度器" scheme="http://ifaceless.space/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="操作系统" scheme="http://ifaceless.space/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="内存管理" scheme="http://ifaceless.space/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="文件系统" scheme="http://ifaceless.space/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>限流算法学习：漏桶 &amp; 令牌桶算法</title>
    <link href="http://ifaceless.space/2019/10/11/rate-limit-policies/"/>
    <id>http://ifaceless.space/2019/10/11/rate-limit-policies/</id>
    <published>2019-10-11T13:20:11.000Z</published>
    <updated>2019-11-28T09:41:31.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本节主要学习下两种常用的单机限流思想，分别是<strong>漏桶算法</strong>和<strong>令牌桶算法</strong>。此外，还将给出使用 Python 及 Go 语言实现，便于加深理解。当然，现实中肯定不能直接用下面的代码。实际应用时，我们不大可能在单机执行限流，下面的实现也并非线程或 goroutine 安全的。<br><a id="more"></a><br>实际限流可以考虑在 Nginx 层对请求限流，或者如果真的要自己在业务方实现一套限流策略的话，可以考虑基于 Redis 实现分布式限流策略。并且在实际应用中，可能还会基于不同的维度进行限流，如用户 id，请求 IP 等，实际应用需要考虑的东西更多。</p><h1 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h1><p>可以把请求当作水流，水流全部进入有限大小的水缸，同时水缸会按照固定的速率漏水。当水流湍急，水缸漏水太慢的话，会得知水缸积水，直到溢出（此时拒绝服务）。</p><p><img src="https://pic2.zhimg.com/80/v2-bdf9f813d2f9d8622174e9e58be308b6_hd.png" alt=""></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>实现起来很简单，并且能够以比较恒定的速率服务请求</li><li>缺点是无法应对突发流量，很容易导致溢出</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeakyBucketRateLimiter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity=<span class="number">10</span>, leak_rate=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化漏桶</span></span><br><span class="line"><span class="string">        :param capacity: 桶容量</span></span><br><span class="line"><span class="string">        :param leak_rate: 恒定的消费速度（Reqs/秒）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._capacity = float(capacity)</span><br><span class="line">        self._leak_rate = float(leak_rate)</span><br><span class="line">        self._water_level = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 上次漏水的时间</span></span><br><span class="line">        self._last_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, level=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 执行漏水</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        delta = self._water_level - self._leak_rate * (now - self._last_time)</span><br><span class="line">        self._water_level = min(<span class="number">0.0</span>, delta)</span><br><span class="line">        self._last_time = now</span><br><span class="line">        <span class="comment"># 尝试加水，并看水桶是否满了</span></span><br><span class="line">        <span class="keyword">if</span> level + self._water_level &gt; self._capacity:</span><br><span class="line">            <span class="keyword">raise</span> RateLimitExceeded()</span><br><span class="line">        self._water_level += level</span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeakyBucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    currentLevel <span class="keyword">int</span></span><br><span class="line">    leakRate <span class="keyword">int</span> <span class="comment">// consume how many requests per sec</span></span><br><span class="line">    lastLeakedAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeakyBucketRateLimitter</span><span class="params">(capacity, leakRate <span class="keyword">int</span>)</span> *<span class="title">LeakyBucketRateLimiter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LeakyBucketRateLimiter&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        currentLevel: <span class="number">0</span>,</span><br><span class="line">        leakRate: leakRate,</span><br><span class="line">        lastLeakedAt: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *LeakyBucketRateLimiter)</span> <span class="title">Acquire</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    <span class="comment">// leak water</span></span><br><span class="line">    currentLevel := r.currentLevel - r.leakRate*<span class="keyword">int</span>(now.Sub(r.lastLeakedAt).Seconds())</span><br><span class="line">    r.currentLevel = max(currentLevel, <span class="number">0</span>)</span><br><span class="line">    r.lastLeakedAt = now</span><br><span class="line">    <span class="comment">// try to add water, test bucket is full or not.</span></span><br><span class="line">    currentLevel = n + r.currentLevel</span><br><span class="line">    <span class="keyword">if</span> currentLevel &gt; r.capacity &#123;</span><br><span class="line">        <span class="keyword">return</span> errRateLimitExceeds</span><br><span class="line">    &#125;</span><br><span class="line">    r.currentLevel = currentLevel</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h1><p>同样想象我们有一个桶，专门存放令牌，会以恒定的速率生成令牌，并将其放入桶中。每当有请求过来时，需要先从桶中取到一个或多个令牌，如果获取成功，则为请求提供服务，否则拒绝服务。</p><p><img src="https://pic3.zhimg.com/80/v2-f2b510a893be6ff316bbde684b70c2e2_hd.png" alt=""></p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>实现同样是很简单</li><li>可以应对突发流量，面对瞬间大流量，可以在短时间内获得大量令牌，且生产令牌毫不费力</li><li>可以做流量整形</li></ol><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenBucketRateLimiter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity=<span class="number">1</span>, fill_rate=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化令牌桶限流器</span></span><br><span class="line"><span class="string">        :param capacity: 令牌桶容量</span></span><br><span class="line"><span class="string">        :param fill_rate: 放入令牌的速度（Reqs/秒）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._capacity = float(capacity)</span><br><span class="line">        self._rate = float(fill_rate)</span><br><span class="line">        self._bucket_tokens = float(capacity)</span><br><span class="line">        <span class="comment"># 上次添加令牌的时间</span></span><br><span class="line">        self._last_time = int(time.time())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, tokens=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 发放令牌</span></span><br><span class="line">        <span class="keyword">if</span> self._bucket_tokens &lt; self._capacity:</span><br><span class="line">            now = time.time()</span><br><span class="line">            delta = (now - self._last_time) * self._rate</span><br><span class="line">            self._last_time = now</span><br><span class="line">            self._bucket_tokens = min(self._capacity, self._bucket_tokens + delta)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tokens &gt; self._bucket_tokens:</span><br><span class="line">            <span class="comment"># 无法获取令牌了，数量不够</span></span><br><span class="line">            <span class="keyword">raise</span> RateLimitExceeded()</span><br><span class="line">        self._bucket_tokens -= tokens</span><br></pre></td></tr></table></figure><h3 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TokenBucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    tokens <span class="keyword">int</span></span><br><span class="line">    putRate <span class="keyword">int</span> <span class="comment">// put how many tokens per sec</span></span><br><span class="line">    lastPutAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTokenBucketRateLimiter</span><span class="params">(capacity, fillRate <span class="keyword">int</span>)</span> *<span class="title">TokenBucketRateLimiter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;TokenBucketRateLimiter&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        tokens: <span class="number">0</span>,</span><br><span class="line">        putRate: fillRate,</span><br><span class="line">        lastPutAt: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TokenBucketRateLimiter)</span> <span class="title">Acquire</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.tokens &lt; r.capacity &#123;</span><br><span class="line">        <span class="comment">// put tokens in the bucket</span></span><br><span class="line">        now := time.Now()</span><br><span class="line">        howMany := r.putRate * <span class="keyword">int</span>(now.Sub(r.lastPutAt).Seconds())</span><br><span class="line">        r.tokens = min(r.capacity, howMany+r.tokens)</span><br><span class="line">        r.lastPutAt = now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if we have enough tokens</span></span><br><span class="line">    <span class="keyword">if</span> r.tokens &lt; n &#123;</span><br><span class="line">        <span class="keyword">return</span> errRateLimitExceeds</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release tokens</span></span><br><span class="line">    r.tokens -= n</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/a/1190000015967922" target="_blank" rel="noopener">接口限流算法介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;本节主要学习下两种常用的单机限流思想，分别是&lt;strong&gt;漏桶算法&lt;/strong&gt;和&lt;strong&gt;令牌桶算法&lt;/strong&gt;。此外，还将给出使用 Python 及 Go 语言实现，便于加深理解。当然，现实中肯定不能直接用下面的代码。实际应用时，我们不大可能在单机执行限流，下面的实现也并非线程或 goroutine 安全的。&lt;br&gt;
    
    </summary>
    
      <category term="Web 开发" scheme="http://ifaceless.space/categories/Web-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web 开发" scheme="http://ifaceless.space/tags/Web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="限流" scheme="http://ifaceless.space/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 Go 语言实现一个简单的 LRU Cache</title>
    <link href="http://ifaceless.space/2019/09/22/implement-lru-cache-in-go/"/>
    <id>http://ifaceless.space/2019/09/22/implement-lru-cache-in-go/</id>
    <published>2019-09-22T13:28:32.000Z</published>
    <updated>2019-11-28T09:41:31.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>LRU (Least-Recently-Used) Cache 是经常使用的一种内存缓存，可以将一些热点数据存放在其中，进而提高接口的响应速度。在实际应用中，cache miss 后，实际可能会回源到 Redis 集群获取缓存数据，如果 Redis 集群也没有，才会回源数据库。也就是引入 LRU Cache 后相当于给应用层添加了一级高速缓存。当然，更为实际一点的是，我们需要使用的是带有过期时间的 LRU Cache，否则后台更新了课程数据，由于内存缓存的原因而得不到及时更新。<br><a id="more"></a><br>本节主要是学习下 LRU Cache 实现原理，只探讨最核心的实现思想，不考虑复杂的情况（如 goroutine 安全，缓存带过期时间等）。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>LRU Cache 提供的功能有两个：</p><ol><li>顾名思义，缓存能力</li><li>当缓存空间满了后，会将最少访问的节点删除掉，从而为新的 key/value 提供缓存空间</li></ol><p>具体实现的思路如下：</p><ol><li>需要使用一个 map 维护 key -&gt; entry node 的映射关系，从而能够基于此快速找到相关的节点；</li><li>需要使用一个双向链表来维护 entry node；</li><li><code>cache.set</code> 时，需要首先检查缓存是否超出界限了，如果是的话，需要将链表尾巴（即最少访问的节点）移除；然后将新的节点插入在链表的头部，并在 map 中刷新 key 对应的 entry node 指针；</li><li><code>cache.get</code> 时，如果 hit 到缓存了，则将对应的 entry node 调整在链表头部，保证最频繁的节点始终往前靠。</li></ol><h1 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package lrucache implements a cache with limited capacity, which evicts</span></span><br><span class="line"><span class="comment">// least-used-entry when it overflows.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Caution: not production ready, not goroutine safe.</span></span><br><span class="line"><span class="keyword">package</span> lrucache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"path/to/bit/zerzura/log"</span></span><br><span class="line">    <span class="string">"path/to/bit/zerzura/datastructures/list"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    defaultCapacity = <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Node</span><br><span class="line">    list *list.List</span><br><span class="line">    stats *Stats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(cache *LRUCache)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Capacity</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cache *LRUCache)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">cap</span> = defaultCapacity</span><br><span class="line">        &#125;</span><br><span class="line">        cache.capacity = <span class="built_in">cap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span> *<span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    cache := &amp;LRUCache&#123;</span><br><span class="line">        capacity: defaultCapacity,</span><br><span class="line">        cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Node, defaultCapacity),</span><br><span class="line">        list: list.New(),</span><br><span class="line">        stats: &amp;Stats&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(cache)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"LRUCache(cap=%d, len=%d, hits=%d, misses=%d)"</span>, lru.capacity, lru.Len(), lru.stats.hits, lru.stats.misses)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lru.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(lru.cache)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    log.Debugf(<span class="string">"lru.set (%s, %v)"</span>, key, value)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt;= lru.capacity &#123;</span><br><span class="line">        node := lru.list.Tail()</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            entry := node.Value.(*entry)</span><br><span class="line">            log.Infof(<span class="string">"[lru.set] evict entry %v"</span>, entry)</span><br><span class="line">            <span class="built_in">delete</span>(lru.cache, entry.key)</span><br><span class="line">            lru.list.RemoveNode(node)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"unexpected state, node is nil, that's impossible"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; node != <span class="literal">nil</span> &#123;</span><br><span class="line">        lru.list.RemoveNode(node)</span><br><span class="line">    &#125;</span><br><span class="line">    lru.cache[key] = lru.list.Insert(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;entry&#123;key: key, value: value&#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        log.Infof(<span class="string">"[lru.get] cache misses for key %s"</span>, key)</span><br><span class="line">        lru.stats.miss()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    entry := node.Value.(*entry)</span><br><span class="line">    entry.hits++</span><br><span class="line">    lru.list.RemoveNode(node)</span><br><span class="line">    lru.cache[key] = lru.list.Insert(<span class="number">0</span>, entry)</span><br><span class="line">    lru.stats.hit()</span><br><span class="line">    log.Debugf(<span class="string">"[lru.get] cache hits, got entry %v."</span>, entry)</span><br><span class="line">    <span class="keyword">return</span> entry.value, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">    hits <span class="keyword">int</span></span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">hit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.hits++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">miss</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.misses++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="keyword">string</span></span><br><span class="line">    hits <span class="keyword">int</span></span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;LRU (Least-Recently-Used) Cache 是经常使用的一种内存缓存，可以将一些热点数据存放在其中，进而提高接口的响应速度。在实际应用中，cache miss 后，实际可能会回源到 Redis 集群获取缓存数据，如果 Redis 集群也没有，才会回源数据库。也就是引入 LRU Cache 后相当于给应用层添加了一级高速缓存。当然，更为实际一点的是，我们需要使用的是带有过期时间的 LRU Cache，否则后台更新了课程数据，由于内存缓存的原因而得不到及时更新。&lt;br&gt;
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="LRU" scheme="http://ifaceless.space/tags/LRU/"/>
    
      <category term="缓存" scheme="http://ifaceless.space/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Python 标准库源码之 threading 模块</title>
    <link href="http://ifaceless.space/2019/09/14/python-stdlib-threading/"/>
    <id>http://ifaceless.space/2019/09/14/python-stdlib-threading/</id>
    <published>2019-09-14T13:03:33.000Z</published>
    <updated>2019-11-28T09:41:31.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>虽然说 Python 受限于 CPython 的实现，存在的 GIL 会导致我们在使用多线程的时候，没法利用多核跑多线程。但是有的时候还是会用到线程的，尤其是针对一些 I/O 密集型的任务，也可以使用它们。</p><p>在使用多线程编程时，我们随时需要注意<strong>竞态条件（race condition）</strong>和<strong>数据竞争（data race）</strong>的问题，前者会导致我们在不同的时间点运行程序得到的输出可能不同；而后者则更为可怕，容易导致共享的数据结构被错误修改，甚至导致程序崩溃或者出现莫名其妙的 Bug。这个时候自然就要用到 Python threading 模块为我们提供的若干同步原语了。<br><a id="more"></a><br>那么，我们常用的 Lock、RLock、条件变量（Condition Variables）、信号量（Semaphore）等是如何实现的呢？接下来的源码学习是基于 <a href="https://github.com/python/cpython/blob/master/Lib/threading.py" target="_blank" rel="noopener">CPython master 分支的线程模块</a>。希望在学习完它们的实现后，能够加深理解，合理运用。</p><h1 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h1><p>CPython 的 threading 模块实际上是基于 Java 的线程模型实现的，所以熟悉 Java 的话，自然也不会对该模块的实现感到陌生。该模块是基于更底层的 <code>_thread</code> 模块，抽象出更加方便使用的线程模型，核心包括 <code>threading.Thread</code> 线程类封装，便于用户继承或组合；此外还有一些同步原语的实现。<code>Python/thread_nt.h</code> 文件中是 C 语言实现的底层和线程有关的函数（如锁的创建和维护、线程的创建和管理）。</p><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>该模块中，<code>Lock</code> 其实是使用了底层 <code>_thread.allocate_lock</code> 函数来创建锁的。代码也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock = _allocate_lock</span><br></pre></td></tr></table></figure><p>Lock 为我们提供了 <code>acquire()</code> 和 <code>release()</code> 这两个主要的方法。当一个线程持有锁时，其它线程调用 <code>acquire()</code> 方法时会被阻塞（此时线程一般就是睡眠等待了），直到主动 <code>release()</code> 后，等待锁的线程会被唤醒。</p><p>关于 Lock 有两点值得注意：</p><ol><li>该锁是不可重入的，也就是如果在一个函数中递归 <code>acquire()</code> 会导致死锁的问题。为了避免这种问题，一般会使用 <code>RLock</code> 来代替</li><li>Lock 并非 Mutex（互斥锁），且它底层是通过信号量那样实现的，本身不会记录谁持有了该锁，也就是说 Lock 可以在不同的线程中被引用，可以在主线程获取，而在子线程释放它。具体可以在 <code>CPython/Python/thread_nt.h:PyThread_allocate_lock</code> 可以看到它的实现如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock support. It has to be implemented as semaphores.</span></span><br><span class="line"><span class="comment"> * I [Dag] tried to implement it with mutex but I could find a way to</span></span><br><span class="line"><span class="comment"> * tell whether a thread already own the lock or not.</span></span><br><span class="line"><span class="comment"> * Lock 支持：它必须以信号量的方式来实现。我尝试使用互斥锁实现过，但是我</span></span><br><span class="line"><span class="comment"> * 发现了另外一种方式可以得知一个线程是否持有了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PyThread_type_lock</span><br><span class="line">PyThread_allocate_lock(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PNRMUTEX aLock;</span><br><span class="line">    dprintf((<span class="string">"PyThread_allocate_lock called\n"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">        PyThread_init_thread();</span><br><span class="line">    aLock = AllocNonRecursiveMutex() ;</span><br><span class="line">    dprintf((<span class="string">"%lu: PyThread_allocate_lock() -&gt; %p\n"</span>, PyThread_get_thread_ident(), aLock));</span><br><span class="line">    <span class="keyword">return</span> (PyThread_type_lock) aLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 PNRMUTEX 定义如下，它并不会告诉我们当前是哪个线程</span></span><br><span class="line"><span class="comment">// 持有了锁</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NRMUTEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PyMUTEX_T cs;</span><br><span class="line">    PyCOND_T cv;</span><br><span class="line">    <span class="keyword">int</span> locked;</span><br><span class="line">&#125; NRMUTEX;</span><br><span class="line"><span class="keyword">typedef</span> NRMUTEX *PNRMUTEX;</span><br></pre></td></tr></table></figure></li></ol><p>比较有趣的是，其实 <code>PyCOND</code> 即条件变量是通过信号量来实现的；而接下来我们会看到，在 Python 的 threading 模块中，我们使用了 Condition 实现了信号量。</p><p><img src="https://pic2.zhimg.com/80/v2-ee4c29657d4deb6d0953bc8531241697_hd.png" alt=""></p><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>RLock 就是可重入锁（Reentrant Lock），它可以被持有锁的线程多次执行 <code>acquire()</code>，而不会发生阻塞和死锁的问题。它的实现思路很简单：</p><ol><li>规定如果一个线程成功持有了该锁，则将该锁的所有权交给该线程，并且只有该线程可以释放锁，其它线程无法释放；</li><li>当在持有锁的线程中递归获取锁的时候，实际并不会执行底层的 <code>_lock.acquire()</code> 方法，而是只给计数器递增；且释放锁的时候也是先给计数器递减，直到为 0 后才会释放锁。</li></ol><p>所以在使用 RLock 的时候一定要记得 <code>acquire()</code> 和 <code>release()</code> 的调用次数得匹配才能真正释放锁。接下来简单看下源码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RLock</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _CRLock <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># 接下来重点看 Python 版本的 RLock 实现</span></span><br><span class="line">        <span class="keyword">return</span> _PyRLock(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> _CRLock(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RLock</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里是真正的锁</span></span><br><span class="line">        self._block = _allocate_lock()</span><br><span class="line">        <span class="comment"># 记录谁对该锁有所有权</span></span><br><span class="line">        self._owner = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 记录该锁被获取的次数，类似引用计数</span></span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, blocking=True, timeout=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        me = get_ident()</span><br><span class="line">        <span class="keyword">if</span> self._owner == me:</span><br><span class="line">            <span class="comment"># 如果当前持有锁的线程就是当前需要获得锁的线程，计数器递增即可</span></span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        rc = self._block.acquire(blocking, timeout)</span><br><span class="line">        <span class="keyword">if</span> rc:</span><br><span class="line">            <span class="comment"># 如果成功获取到锁后，会把持有锁的线程记录下来，标记该线程是所有权拥有者</span></span><br><span class="line">            self._owner = me</span><br><span class="line">            self._count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rc</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._owner != get_ident():</span><br><span class="line">            <span class="comment"># 显而易见，非拥有者不能释放锁，想都不用想！</span></span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot release un-acquired lock"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里只是递减计数器，只有_count 减没了才会真正释放</span></span><br><span class="line">        self._count = count = self._count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> count:</span><br><span class="line">            self._owner = <span class="keyword">None</span></span><br><span class="line">            self._block.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面的方法是用于条件变量实现时使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_acquire_restore</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="comment"># 恢复锁的获取，并且恢复嵌套层次</span></span><br><span class="line">        self._block.acquire()</span><br><span class="line">        self._count, self._owner = state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_release_save</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 需要保证不管有多少层嵌套，都能真正释放锁，但同时返回当前的嵌套状态等信息便于恢复</span></span><br><span class="line">        <span class="keyword">if</span> self._count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot release un-acquired lock"</span>)</span><br><span class="line">        count = self._count</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        owner = self._owner</span><br><span class="line">        self._owner = <span class="keyword">None</span></span><br><span class="line">        self._block.release()</span><br><span class="line">        <span class="keyword">return</span> (count, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_owned</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._owner == get_ident()</span><br></pre></td></tr></table></figure></p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>条件变量是后面几个同步原语实现的基础，值得重点学习下。条件变量的实现原理比较简单：所有等待的线程会被加入到等待队列中，只有在需要的时候会被唤醒（可以想想如何实现 waiter 线程的等待和唤醒呢？）。</p><p><img src="https://pic2.zhimg.com/80/v2-b4516542d0e21eab291382ac3f8ed364_hd.png" alt=""></p><p>在分析源码前，我们可以看看 <code>Condition</code> 类提供了哪些主要接口：</p><ul><li><code>wait(timeout=None)</code>，线程可以调用该接口等待被唤醒</li><li><code>notify()</code>，线程可以调用该接口通知队列中一个或多个等待线程被唤醒</li></ul><p>接下来看看源码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lock=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> lock <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            lock = RLock()</span><br><span class="line">        self._lock = lock</span><br><span class="line">        <span class="comment"># Export the lock's acquire() and release() methods</span></span><br><span class="line">        self.acquire = lock.acquire</span><br><span class="line">        self.release = lock.release</span><br><span class="line">        <span class="comment"># If the lock defines _release_save() and/or _acquire_restore(),</span></span><br><span class="line">        <span class="comment"># these override the default implementations (which just call</span></span><br><span class="line">        <span class="comment"># release() and acquire() on the lock). Ditto for _is_owned().</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._release_save = lock._release_save</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._acquire_restore = lock._acquire_restore</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._is_owned = lock._is_owned</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        self._waiters = _deque()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_release_save</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._lock.release() <span class="comment"># No state to save</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_acquire_restore</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self._lock.acquire() <span class="comment"># Ignore saved state</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_owned</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Return True if lock is owned by current_thread.</span></span><br><span class="line">        <span class="comment"># This method is called only if _lock doesn't have _is_owned().</span></span><br><span class="line">        <span class="keyword">if</span> self._lock.acquire(<span class="keyword">False</span>):</span><br><span class="line">            self._lock.release()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot wait on un-acquired lock"</span>)</span><br><span class="line">        waiter = _allocate_lock()</span><br><span class="line">        waiter.acquire()</span><br><span class="line">        self._waiters.append(waiter)</span><br><span class="line">        saved_state = self._release_save()</span><br><span class="line">        gotit = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">try</span>: <span class="comment"># restore state no matter what (e.g., KeyboardInterrupt)</span></span><br><span class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                waiter.acquire()</span><br><span class="line">                gotit = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">                    gotit = waiter.acquire(<span class="keyword">True</span>, timeout)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    gotit = waiter.acquire(<span class="keyword">False</span>)</span><br><span class="line">            <span class="keyword">return</span> gotit</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._acquire_restore(saved_state)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> gotit:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self._waiters.remove(waiter)</span><br><span class="line">                <span class="keyword">except</span> ValueError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_for</span><span class="params">(self, predicate, timeout=None)</span>:</span></span><br><span class="line">        endtime = <span class="keyword">None</span></span><br><span class="line">        waittime = timeout</span><br><span class="line">        result = predicate()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="keyword">if</span> waittime <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> endtime <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    endtime = _time() + waittime</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    waittime = endtime - _time()</span><br><span class="line">                    <span class="keyword">if</span> waittime &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            self.wait(waittime)</span><br><span class="line">            result = predicate()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot notify on un-acquired lock"</span>)</span><br><span class="line">        all_waiters = self._waiters</span><br><span class="line">        waiters_to_notify = _deque(_islice(all_waiters, n))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> waiters_to_notify:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> waiter <span class="keyword">in</span> waiters_to_notify:</span><br><span class="line">            waiter.release()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                all_waiters.remove(waiter)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>:</span></span><br><span class="line">    <span class="string">"""This class implements semaphore objects.</span></span><br><span class="line"><span class="string">    Semaphores manage a counter representing the number of release() calls minus</span></span><br><span class="line"><span class="string">    the number of acquire() calls, plus an initial value. The acquire() method</span></span><br><span class="line"><span class="string">    blocks if necessary until it can return without making the counter</span></span><br><span class="line"><span class="string">    negative. If not given, value defaults to 1.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># After Tim Peters' semaphore class, but not quite the same (no maximum)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"semaphore initial value must be &gt;= 0"</span>)</span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, blocking=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Acquire a semaphore, decrementing the internal counter by one.</span></span><br><span class="line"><span class="string">        When invoked without arguments: if the internal counter is larger than</span></span><br><span class="line"><span class="string">        zero on entry, decrement it by one and return immediately. If it is zero</span></span><br><span class="line"><span class="string">        on entry, block, waiting until some other thread has called release() to</span></span><br><span class="line"><span class="string">        make it larger than zero. This is done with proper interlocking so that</span></span><br><span class="line"><span class="string">        if multiple acquire() calls are blocked, release() will wake exactly one</span></span><br><span class="line"><span class="string">        of them up. The implementation may pick one at random, so the order in</span></span><br><span class="line"><span class="string">        which blocked threads are awakened should not be relied on. There is no</span></span><br><span class="line"><span class="string">        return value in this case.</span></span><br><span class="line"><span class="string">        When invoked with blocking set to true, do the same thing as when called</span></span><br><span class="line"><span class="string">        without arguments, and return true.</span></span><br><span class="line"><span class="string">        When invoked with blocking set to false, do not block. If a call without</span></span><br><span class="line"><span class="string">        an argument would block, return false immediately; otherwise, do the</span></span><br><span class="line"><span class="string">        same thing as when called without arguments, and return true.</span></span><br><span class="line"><span class="string">        When invoked with a timeout other than None, it will block for at</span></span><br><span class="line"><span class="string">        most timeout seconds. If acquire does not complete successfully in</span></span><br><span class="line"><span class="string">        that interval, return false. Return true otherwise.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> blocking <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"can't specify timeout for non-blocking acquire"</span>)</span><br><span class="line">        rc = <span class="keyword">False</span></span><br><span class="line">        endtime = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            <span class="keyword">while</span> self._value == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> blocking:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> endtime <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                        endtime = _time() + timeout</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        timeout = endtime - _time()</span><br><span class="line">                        <span class="keyword">if</span> timeout &lt;= <span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                self._cond.wait(timeout)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._value -= <span class="number">1</span></span><br><span class="line">                rc = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> rc</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Release a semaphore, incrementing the internal counter by one or more.</span></span><br><span class="line"><span class="string">        When the counter is zero on entry and another thread is waiting for it</span></span><br><span class="line"><span class="string">        to become larger than zero again, wake up that thread.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'n must be one or more'</span>)</span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._value += n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                self._cond.notify()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span><span class="params">(Semaphore)</span>:</span></span><br><span class="line">    <span class="string">"""Implements a bounded semaphore.</span></span><br><span class="line"><span class="string">    A bounded semaphore checks to make sure its current value doesn't exceed its</span></span><br><span class="line"><span class="string">    initial value. If it does, ValueError is raised. In most situations</span></span><br><span class="line"><span class="string">    semaphores are used to guard resources with limited capacity.</span></span><br><span class="line"><span class="string">    If the semaphore is released too many times it's a sign of a bug. If not</span></span><br><span class="line"><span class="string">    given, value defaults to 1.</span></span><br><span class="line"><span class="string">    Like regular semaphores, bounded semaphores manage a counter representing</span></span><br><span class="line"><span class="string">    the number of release() calls minus the number of acquire() calls, plus an</span></span><br><span class="line"><span class="string">    initial value. The acquire() method blocks if necessary until it can return</span></span><br><span class="line"><span class="string">    without making the counter negative. If not given, value defaults to 1.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></span><br><span class="line">        Semaphore.__init__(self, value)</span><br><span class="line">        self._initial_value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Release a semaphore, incrementing the internal counter by one or more.</span></span><br><span class="line"><span class="string">        When the counter is zero on entry and another thread is waiting for it</span></span><br><span class="line"><span class="string">        to become larger than zero again, wake up that thread.</span></span><br><span class="line"><span class="string">        If the number of releases exceeds the number of acquires,</span></span><br><span class="line"><span class="string">        raise a ValueError.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'n must be one or more'</span>)</span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            <span class="keyword">if</span> self._value + n &gt; self._initial_value:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">"Semaphore released too many times"</span>)</span><br><span class="line">            self._value += n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                self._cond.notify()</span><br></pre></td></tr></table></figure><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></span><br><span class="line">    <span class="string">"""Class implementing event objects.</span></span><br><span class="line"><span class="string">    Events manage a flag that can be set to true with the set() method and reset</span></span><br><span class="line"><span class="string">    to false with the clear() method. The wait() method blocks until the flag is</span></span><br><span class="line"><span class="string">    true. The flag is initially false.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># After Tim Peters' event class (without is_posted())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._flag = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reset_internal_locks</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># private! called by Thread._reset_internal_locks by _after_fork()</span></span><br><span class="line">        self._cond.__init__(Lock())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_set</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return true if and only if the internal flag is true."""</span></span><br><span class="line">        <span class="keyword">return</span> self._flag</span><br><span class="line"></span><br><span class="line">    isSet = is_set</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Set the internal flag to true.</span></span><br><span class="line"><span class="string">        All threads waiting for it to become true are awakened. Threads</span></span><br><span class="line"><span class="string">        that call wait() once the flag is true will not block at all.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._flag = <span class="keyword">True</span></span><br><span class="line">            self._cond.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Reset the internal flag to false.</span></span><br><span class="line"><span class="string">        Subsequently, threads calling wait() will block until set() is called to</span></span><br><span class="line"><span class="string">        set the internal flag to true again.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._flag = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Block until the internal flag is true.</span></span><br><span class="line"><span class="string">        If the internal flag is true on entry, return immediately. Otherwise,</span></span><br><span class="line"><span class="string">        block until another thread calls set() to set the flag to true, or until</span></span><br><span class="line"><span class="string">        the optional timeout occurs.</span></span><br><span class="line"><span class="string">        When the timeout argument is present and not None, it should be a</span></span><br><span class="line"><span class="string">        floating point number specifying a timeout for the operation in seconds</span></span><br><span class="line"><span class="string">        (or fractions thereof).</span></span><br><span class="line"><span class="string">        This method returns the internal flag on exit, so it will always return</span></span><br><span class="line"><span class="string">        True except if a timeout is given and the operation times out.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            signaled = self._flag</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> signaled:</span><br><span class="line">                signaled = self._cond.wait(timeout)</span><br><span class="line">            <span class="keyword">return</span> signaled</span><br></pre></td></tr></table></figure><h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>通常可以使用 Barrier 实现并发初始化，然后一切就绪后才会进入下一个阶段。应用示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> get_ident <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Barrier, Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_prepared</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"All are ready"</span>)</span><br><span class="line"></span><br><span class="line">barrier = Barrier(parties=<span class="number">4</span>, action=signal_prepared)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Thread(target=load_disk_files).start()</span><br><span class="line">    Thread(target=make_cache).start()</span><br><span class="line">    Thread(target=init_db_pool).start()</span><br><span class="line">    print(<span class="string">"I'm ready, wait for other workers"</span>)</span><br><span class="line">    barrier.wait()</span><br><span class="line">    print(<span class="string">"Time to start our server"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_disk_files</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">u"[&#123;&#125;] load_disk_files"</span>.format(get_ident()))</span><br><span class="line">    barrier.wait()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cache</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">u"[&#123;&#125;] make cache"</span>.format(get_ident()))</span><br><span class="line">    barrier.wait()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_db_pool</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">u"[&#123;&#125;] init db pool"</span>.format(get_ident()))</span><br><span class="line">    barrier.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="https://pic3.zhimg.com/80/v2-976ddfaeddc70d04ee29843cfd125713_hd.png" alt=""></p><p>接下来看看 Barrier 是如何实现的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Barrier 是基于部分的 `pthread_barrier_*` API 和 Java 中的 `CyclicBarrier`</span></span><br><span class="line"><span class="comment"># 参考：</span></span><br><span class="line"><span class="comment"># 1. http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and</span></span><br><span class="line"><span class="comment"># 2. http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/CyclicBarrier.html</span></span><br><span class="line"><span class="comment"># 在内部维护了两种主要的状态：`filling` 和 `draining`，从而让屏障变成可循环使用的。</span></span><br><span class="line"><span class="comment"># 只有上一个周期完全排水（`drained`）完毕才可以允许新的线程进入（对比下漏桶限流算法）</span></span><br><span class="line"><span class="comment"># 此外，这里还提供了 `resetting` 状态，它类似于 `draining`，但是会让线程离开的时候抛出 `BrokeBarrierError`</span></span><br><span class="line"><span class="comment"># `broken` 状态表示所有的线程都产生了异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barrier</span>:</span></span><br><span class="line">    <span class="string">"""I</span></span><br><span class="line"><span class="string">    我们通常可以使用屏障让多个线程在相同的同步点同步开始（可以想象下有个水缸，水不断地流进来</span></span><br><span class="line"><span class="string">    但是会在某个点一起放开，形成洪流...）。所有调用了 `wait()` 的线程会在条件满足时几乎同时被唤醒，</span></span><br><span class="line"><span class="string">    然后大家就可以一起快乐地干活了。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parties, action=None, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Create a barrier, initialised to 'parties' threads.</span></span><br><span class="line"><span class="string">        'action' is a callable which, when supplied, will be called by one of</span></span><br><span class="line"><span class="string">        the threads after they have all entered the barrier and just prior to</span></span><br><span class="line"><span class="string">        releasing them all. If a 'timeout' is provided, it is used as the</span></span><br><span class="line"><span class="string">        default for all subsequent 'wait()' calls.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._action = action</span><br><span class="line">        self._timeout = timeout</span><br><span class="line">        self._parties = parties</span><br><span class="line">        self._state = <span class="number">0</span> <span class="comment">#0 filling, 1, draining, -1 resetting, -2 broken</span></span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="string">"""Wait for the barrier.</span></span><br><span class="line"><span class="string">        When the specified number of threads have started waiting, they are all</span></span><br><span class="line"><span class="string">        simultaneously awoken. If an 'action' was provided for the barrier, one</span></span><br><span class="line"><span class="string">        of the threads will have executed that callback prior to returning.</span></span><br><span class="line"><span class="string">        Returns an individual index number from 0 to 'parties-1'.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            timeout = self._timeout</span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._enter() <span class="comment"># Block while the barrier drains.</span></span><br><span class="line">            index = self._count</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> index + <span class="number">1</span> == self._parties:</span><br><span class="line">                    <span class="comment"># We release the barrier</span></span><br><span class="line">                    self._release()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># We wait until someone releases us</span></span><br><span class="line">                    self._wait(timeout)</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self._count -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># Wake up any threads waiting for barrier to drain.</span></span><br><span class="line">                self._exit()</span><br><span class="line">    <span class="comment"># Block until the barrier is ready for us, or raise an exception</span></span><br><span class="line">    <span class="comment"># if it is broken.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_enter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self._state <span class="keyword">in</span> (<span class="number">-1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># It is draining or resetting, wait until done</span></span><br><span class="line">            self._cond.wait()</span><br><span class="line">        <span class="comment">#see if the barrier is in a broken state</span></span><br><span class="line">        <span class="keyword">if</span> self._state &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> BrokenBarrierError</span><br><span class="line">        <span class="keyword">assert</span> self._state == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optionally run the 'action' and release the threads waiting</span></span><br><span class="line">    <span class="comment"># in the barrier.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_release</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self._action:</span><br><span class="line">                self._action()</span><br><span class="line">            <span class="comment"># enter draining state</span></span><br><span class="line">            self._state = <span class="number">1</span></span><br><span class="line">            self._cond.notify_all()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#an exception during the _action handler. Break and reraise</span></span><br><span class="line">            self._break()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait in the barrier until we are released. Raise an exception</span></span><br><span class="line">    <span class="comment"># if the barrier is reset or broken.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wait</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._cond.wait_for(<span class="keyword">lambda</span> : self._state != <span class="number">0</span>, timeout):</span><br><span class="line">            <span class="comment">#timed out. Break the barrier</span></span><br><span class="line">            self._break()</span><br><span class="line">            <span class="keyword">raise</span> BrokenBarrierError</span><br><span class="line">        <span class="keyword">if</span> self._state &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> BrokenBarrierError</span><br><span class="line">        <span class="keyword">assert</span> self._state == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If we are the last thread to exit the barrier, signal any threads</span></span><br><span class="line">    <span class="comment"># waiting for the barrier to drain.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_exit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self._state <span class="keyword">in</span> (<span class="number">-1</span>, <span class="number">1</span>):</span><br><span class="line">                <span class="comment">#resetting or draining</span></span><br><span class="line">                self._state = <span class="number">0</span></span><br><span class="line">                self._cond.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Reset the barrier to the initial state.</span></span><br><span class="line"><span class="string">        Any threads currently waiting will get the BrokenBarrier exception</span></span><br><span class="line"><span class="string">        raised.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            <span class="keyword">if</span> self._count &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self._state == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">#reset the barrier, waking up threads</span></span><br><span class="line">                    self._state = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> self._state == <span class="number">-2</span>:</span><br><span class="line">                    <span class="comment">#was broken, set it to reset state</span></span><br><span class="line">                    <span class="comment">#which clears when the last thread exits</span></span><br><span class="line">                    self._state = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._state = <span class="number">0</span></span><br><span class="line">            self._cond.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Place the barrier into a 'broken' state.</span></span><br><span class="line"><span class="string">        Useful in case of error. Any currently waiting threads and threads</span></span><br><span class="line"><span class="string">        attempting to 'wait()' will have BrokenBarrierError raised.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> self._cond:</span><br><span class="line">            self._break()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_break</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># An internal error was detected. The barrier is set to</span></span><br><span class="line">        <span class="comment"># a broken state all parties awakened.</span></span><br><span class="line">        self._state = <span class="number">-2</span></span><br><span class="line">        self._cond.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parties</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of threads required to trip the barrier."""</span></span><br><span class="line">        <span class="keyword">return</span> self._parties</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n_waiting</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of threads currently waiting at the barrier."""</span></span><br><span class="line">        <span class="comment"># We don't need synchronization here since this is an ephemeral result</span></span><br><span class="line">        <span class="comment"># anyway. It returns the correct value in the steady state.</span></span><br><span class="line">        <span class="keyword">if</span> self._state == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self._count</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">broken</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return True if the barrier is in a broken state."""</span></span><br><span class="line">        <span class="keyword">return</span> self._state == <span class="number">-2</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Python 源码的注释太丰富了，以至于我都不想翻译成中文。所以结合注释看代码即可~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;虽然说 Python 受限于 CPython 的实现，存在的 GIL 会导致我们在使用多线程的时候，没法利用多核跑多线程。但是有的时候还是会用到线程的，尤其是针对一些 I/O 密集型的任务，也可以使用它们。&lt;/p&gt;
&lt;p&gt;在使用多线程编程时，我们随时需要注意&lt;strong&gt;竞态条件（race condition）&lt;/strong&gt;和&lt;strong&gt;数据竞争（data race）&lt;/strong&gt;的问题，前者会导致我们在不同的时间点运行程序得到的输出可能不同；而后者则更为可怕，容易导致共享的数据结构被错误修改，甚至导致程序崩溃或者出现莫名其妙的 Bug。这个时候自然就要用到 Python threading 模块为我们提供的若干同步原语了。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ifaceless.space/categories/Python/"/>
    
    
      <category term="Python" scheme="http://ifaceless.space/tags/Python/"/>
    
      <category term="多线程" scheme="http://ifaceless.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码学习" scheme="http://ifaceless.space/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Go 编写姿势</title>
    <link href="http://ifaceless.space/2019/09/03/golang-traps/"/>
    <id>http://ifaceless.space/2019/09/03/golang-traps/</id>
    <published>2019-09-03T13:44:19.000Z</published>
    <updated>2019-11-28T09:41:31.554Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一般情况下，interface 可以直接进行值传递，除非你需要修改 interface 指向的数据。interface 本身很轻量，其包括指向数据类型的指针和存储数据的指针。</li><li>Value Receiver 方法可以通过值或者指针调用；Pointer Receiver 则只接受指针调用。换句话说，指针调用方法更加轻松，限制更少。</li><li>Mutex 和 RWMutex 可以直接使用其零值，零值表示 Unlock 状态。已经被使用的 Mutex 不能被拷贝。</li><li><p>对于 Map &amp; Slice，需要注意其作为参数和返回值的时候，可能会受到外界操作的影响。 安全的做法是在内部做一次拷贝，内部可安全使用。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line"><span class="built_in">copy</span>(d.trips, trips)</span><br></pre></td></tr></table></figure></li><li><p>Channel 的 size 要么是 1，要么是无缓冲的（这个还是要看情况吧）</p></li><li>常规情况下，枚举从 1 开始计数；除非 0 是有一定意义的。如：<code>LogToStdout = 0</code></li><li><p>直接导出自定义错误要小心，最好<strong>只公开错误匹配器</strong>，方便进行错误检查：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">_, ok := err.(errNotFound)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合理使用 Error Wrapping，不用添加过多冗余信息，如：<code>failed to : error message</code>。</p></li><li>在生产环境中，运行的程序避免 panic，panic/recover 不是错误处理策略，而是当不可恢复的事情发生时，程序才必须 panic。</li><li>使用 <a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> 替代标准库 <code>sync/atomic</code>，避免忘记使用原子操作。</li><li><code>import _</code> 应该只用于 <code>main</code> 文件中，尽可能靠近程序启动位置。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>优先使用 <code>strconv</code> 而非 <code>fmt</code> 转换类型，性能更好。</li><li>不要反复（如循环中）从固定字符串创建字节 slice，反之亦然。</li><li>map 创建时尽量提供容量 hint，这样可以避免在添加元素期间过多次地分配。map 虽然不能保证分配 hint 个容量，添加元素时依然可以进行分配，但它可以在运行时有更少的分配。</li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ol><li>保证一致性，便于代码的维护、减少学习成本</li><li>相似的声明放在一个分组（import/var/const/type）。仅将相关的声明放到一起！</li><li>包命名规则：<ol><li>全部小写。无大写或下划线</li><li>多数使用命名导入的情况下，无需重命名包</li><li>简短 &amp; 简洁</li><li>不要使用复数</li></ol></li><li>函数分组与顺序：<ol><li>函数粗略按照调用顺序排序</li><li>同一个文件中，函数应该按照接收者分组</li><li>导出的函数应该先出现在文件中，放在 <code>var</code>, <code>struct</code>, <code>const</code> 定义的后面</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>对于未导出的顶层常量和变量，使用 <code>_</code> 作为前缀</strong>。未导出的错误值，使用 <code>err</code> 开头。原因：顶层变量和常量具有包范围作用域，使用通用名称可能会导致在其他文件中意外使用错误值。</li><li>结构体嵌入，多一行空行隔开</li><li><p><code>nil</code> 是一个有效的 slice；<strong>零值切片（使用 <code>var</code> 声明的切片）可立即使用，无需调用 <code>make()</code> 创建。</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果要声明格式字符串，设置为 <code>const</code> 类型，有助于 <code>go vet</code> 执行字符串静态检查：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul><li><a href="https://github.com/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener">Uber Go Guide</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">The Go common mistakes guide</a></li><li><a href="https://www.kancloud.cn/kancloud/effective/72199" target="_blank" rel="noopener">Effective 中文版</a></li><li><a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">Pointers v.s. Values</a></li><li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just checked errors, handle them gracefully</a></li><li><a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Package Names</a></li><li><a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Go 包样式指南</a></li><li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></li><li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;一般情况下，interface 可以直接进行值传递，除非你需要修改 interface 指向的数据。interface 本身很轻量，其包括指向数据类型的指针和存储数据的指针。&lt;/li&gt;
&lt;li&gt;Value Receiver 方法可以通过值或者指针调用；Point
      
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="最佳实践" scheme="http://ifaceless.space/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>野猪🐗书读书笔记之事务</title>
    <link href="http://ifaceless.space/2019/08/24/ddia-transaction/"/>
    <id>http://ifaceless.space/2019/08/24/ddia-transaction/</id>
    <published>2019-08-24T03:37:50.000Z</published>
    <updated>2019-11-24T09:45:59.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>由于数据存储期间，可能发生错误、故障的点特别多，比如网络中断、磁盘写满等，面对这些复杂的情况，应用层应付起来非常困难。所以就有了事务的概念，说道事务，我们最先能想到的就是：可以一次事务中将很多读写入操作打包成一个逻辑操作单元，整个事务不成功（Committed）便成仁（Rollback）。如果失败，应用层可根据情况安全地重试，不用担心部分写入的问题。</p><a id="more"></a><p>总的来说，事务就是一层抽象，为简化应用层编程模型而生！当然，并非所有的数据库都支持事务，但是对关系型数据库而言，这个基本是标配；某些 NoSQL 数据库可能因为性能、可用性以及扩展性考虑，而放弃了对事务的支持。另外，分布式数据库下，事务的实现会更加困难，并且执行开销也很大，但并不代表它不能实现。典型的 分布式关系数据库如 TiDB 以及 Google Spanner 就提供了事务支持。</p><h1 id="深入理解-ACID"><a href="#深入理解-ACID" class="headerlink" title="深入理解 ACID"></a>深入理解 ACID</h1><ol><li><strong>Atomicity（原子性）</strong>：将多个写操作纳入一个原子事务中，并在故障（进程崩溃、网络中断、磁盘故障）发生时能够及时中止事务，并将部分完成的写入全部丢弃。</li><li><p><strong>Consistency（一致性）</strong>：</p><ol><li>对数据有特定的状态预期，任何数据变更必须满足这些状态约束（或者恒等条件）</li><li>应用程序应该负责保证这种一致性，数据库只是存储</li><li><strong>这个更多的是应用层属性</strong>，所以 C 原本不属于 ACID，只是作者 Joe Hellerstein 认为听起来顺口就加了进来😢</li></ol></li><li><p><strong>Isolation（隔离性）</strong>：并发执行的多个事务相互隔离，不能相互交叉。经典的教材把其称为<em>可串行化</em>。但实践中，串行化隔离级别较少使用，更多的还是较弱的隔离级别。</p></li><li><p><strong>Durability（持久性）</strong>：数据库承诺，一旦事务提交成功，即便硬件故障或数据库崩溃，事务写入的数据也不会丢失。</p><ol><li>对于如主从复制的数据库集群，意味着写入的数据复制到了多个节点</li><li>完美的持久性无法保证（把硬盘拔了、全部机房烧了🔥呢？）</li></ol></li><li><p>理性看待各家数据库宣称的 ACID 兼容；实际各家实现都可能不同</p></li><li>不符合 ACID 标准的系统通常称为 BASE：<ul><li>Basically Available</li><li>Soft State</li><li>Eventually Consistency</li></ul></li><li>ACID 数据库基于这样的理念：<strong>如果存在违反 AID 的风险，就放弃整个事务，而非部分放弃</strong>！</li></ol><h1 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h1><ol><li>安全的并行事务：两个事务间没数据依赖关系，操作的是完全不同的数据</li><li>不安全的并行事务（会引入竞争条件）：<ol><li>A 事务修改了<strong>某数据</strong>；B 事务又读取<strong>该数据</strong>；</li><li>A 事务和 B 事务<strong>同时修改相同</strong>的数据。</li></ol></li><li>隔离就是为了保证事务能够安全地并发执行，假装没有发生并发；可串行地隔离意味着数据库会保证事务的执行结果和串行执行结果一致。</li><li>为何产生弱隔离级别？<ol><li>串行隔离性能不好</li><li>弱隔离可解决部分并发问题；但是还是需要彻底理解各种隔离级别以及它们可能产生的问题，才能更好地完成业务需求</li></ol></li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>在学习各种隔离级别前，有必要了解如下几个关键要点：</p><table><thead><tr><th>要点</th><th>解释</th></tr></thead><tbody><tr><td>脏读 Dirty Read</td><td>在事务 A 中读取到了事务 B 尚未提交的写入。<em>采用 <strong>Read Committed</strong> 及以上级别可防范</em>。</td></tr><tr><td>脏写 Dirty Write</td><td>在事务 A 中覆盖了事务 B 尚未提交的写入。<em>几乎所有的数据库都可以防止脏写，最简单就是加锁</em>。</td></tr><tr><td>读倾斜（不可重复读） Non-Repeatable Read</td><td>在事务执行期间，不同的时间点读取同一条记录，得到的值不同。<em>快照隔离可轻松应付，通常使用 MVCC 实现快照隔离（如 InnoDB）</em>。</td></tr><tr><td>更新丢失 Lost Update</td><td>两个事务中都执行了 Read-Modify-Write 的操作序列，出现了其中一个覆盖了另一个的写入，但没有包含对方最新值的情况（典型的例子是：读取某个字段-&gt;字段值加 1-&gt;写入该字段的新值，可能会出现两个事务同时执行了 +1，但最终结果不是预期的 +2 效果）。<em>通常可以采用数据支持的原子写操作，或者使用 SELECT…FOR UPDATE 显式加锁的方式解决；当然，某些快照隔离的实现可以自动防止这种异常</em></td></tr><tr><td>写倾斜 Write Skew</td><td>典型的场景是：事务中查询数据，再根据查询结果做出决策，最后修改数据库。但是如果事务提交时，支持决策的前提条件不再成立（比如另一个事务中做了修改，导致同样的查询条件，得到的结果不同）。<em>只有串行化隔离级别才能真正防止这种异常</em></td></tr><tr><td>幻读 Phantom Read</td><td>事务读取了某些符合查询条件的记录，同时另一个事务执行写入，改变了先前的查询结果。<em>快照隔离可防止简单的幻读</em></td></tr></tbody></table><h2 id="ANSI-SQL-几种隔离级别定义："><a href="#ANSI-SQL-几种隔离级别定义：" class="headerlink" title="ANSI SQL 几种隔离级别定义："></a>ANSI SQL 几种隔离级别定义：</h2><p>实际上各家数据库的支持是不尽相同的😣。</p><table><thead><tr><th>级别</th><th>P1 脏读</th><th>P2 不可重复读</th><th>P3 幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>Read Committed</td><td>禁止</td><td>允许</td><td>允许</td></tr><tr><td>Repeatable Read</td><td>禁止</td><td>禁止</td><td>允许</td></tr><tr><td>Serializable</td><td>禁止</td><td>禁止</td><td>禁止</td></tr></tbody></table><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><ol><li><p>最基本的事务隔离级别，需要提供下面两个保证：</p><ol><li>防止脏读</li><li>防止脏写</li></ol></li><li><p>实现：</p><ol><li>为了防止脏写，当事务需要修改某个对象（比如行或文档）时，必须要获得该对象的锁，一直持有该锁直到事务提交或中止；    </li><li>为了防止脏读，使用锁的方式虽然也可以实现，但在运行较长时间的写事务会导致许多只读事务等待时间太长，影响只读事务的响应延迟，可操作性差。通常对于每个待更新的对象，数据库维护其旧值和当前持锁事务将要设置的新值两个版本。在事务提交前，所有其它读操作都读取旧值；仅当写事务提交后，才会切换到读取新值。</li></ol></li></ol><h2 id="快照隔离级别和可重复读"><a href="#快照隔离级别和可重复读" class="headerlink" title="快照隔离级别和可重复读"></a>快照隔离级别和可重复读</h2><ol><li><p>Rread Committed 不能解决<strong>不可重复读</strong>的问题，而在一些场景下就不能容忍：</p><ol><li>备份</li><li>分析查询和完整性检查</li></ol></li><li><p>快照隔离保证每个事务只看到特定时间点的旧数据，不感知其它事务中对数据的修改。读取操作不会阻止写操作，反之亦然。</p></li><li>数据库使用了<strong>多版本并发控制（Multi-Version Concurrency Control, MVCC）</strong>技术来实现快照隔离。而 MVCC 也可以用来实现 Read Committed 隔离级别（只需要保留两个版本即可，已提交的旧数据和尚未提交的新版本数据），典型的做法是对每个不同的查询单独创建一个快照；而快照隔离级别则使用一个快照运行整个事务。<br> <img src="./mvvc.png" alt=""></li><li>一致性快照中数据可见性规则：<ol><li>事务开始时，创建该对象的事务已经完成提交</li><li>对象没有被标记删除；或者即便标记了，但是删除事务在当前事务开始的时候尚未提交</li></ol></li></ol><h2 id="防止更新丢失"><a href="#防止更新丢失" class="headerlink" title="防止更新丢失"></a>防止更新丢失</h2><ol><li><p>产生更新丢失的典型场景是：Read-Modify-Write，当两个并发事务在同样的数据记录上执行类似操作时，二者相互不会感知对方的修改值，最终导致某个事务的修改值可能丢失。场景如下：</p><ol><li>递增计数器；更新账户余额</li><li>对复杂对象的一部分进行修改（如一个大 JSON 对象）</li></ol></li><li><p>如何解决？</p><ol><li><p>采用<strong>原子写操作</strong>（如果数据库支持的话）：</p><ol><li><code>UPDATE counter SET value = value + 1 WHERE id = 1</code>;</li><li>通常采用读取对象并加独占锁的方式来实现（在当前事务未提交前，其它事务也不可读）；或者可以采用单线程执行原子操作</li></ol></li><li><p><strong>显式加锁</strong>：</p><ol><li><code>SELECT * FROM figures WHERE name = &#39;robot&#39; FOR UPDATE</code></li><li>对所选行加锁，其它事务若要同时尝试读取对象，则要等待当前正在执行的序列全部完成</li></ol></li><li><p><strong>自动检测更新丢失</strong>：</p><ol><li>事务管理器如果检测到更新丢失风险，会中止当前事务，强制退回到安全的 R-M-W 方式</li><li>MySQL InnoDB 不支持检测；PostgreSQL 的可重复读、Oracle 可串行化和 SQL Server 快照隔离级别都支持</li></ol></li><li><strong>原子比较和设置</strong>：<ol><li>只有在上次读取的数据未发生变化时才允许更新；否则回退到 R-M-W 方式</li><li>使用前需要仔细检查</li></ol></li></ol></li></ol><h2 id="写倾斜与幻读"><a href="#写倾斜与幻读" class="headerlink" title="写倾斜与幻读"></a>写倾斜与幻读</h2><p><img src="./write-skew.png" alt=""></p><ol><li><p>写倾斜可以认为是一种更广义的更新丢失问题，即如果两个事务读取相同的一组对象，然后更新其中的一部分：</p><ol><li>不同的事务更新不同的对象，则可能发生写倾斜</li><li>不同的事务更新相同的对象，则可能发生脏写或更新丢失</li></ol></li><li><p>相关场景：</p><ol><li>会议室预定系统</li><li>多人游戏</li><li>声明一个用户名</li><li>防止双重开支（积分等）</li></ol></li><li><p>如何应对写倾斜：</p><ol><li>如值班医生的例子，可以采用 <code>SELECT...FOR UPDATE</code> 方式<strong>显式加锁</strong>，但如果查询结果为空，这样做也不能奏效</li><li>实体化冲突，比如会议室预定，可以提前将未来 N 个月的对应的所有时间和房间组合创建好，这样显示加锁可以生效</li><li>采用串行化隔离级别</li></ol></li></ol><h1 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h1><h2 id="严格串行执行"><a href="#严格串行执行" class="headerlink" title="严格串行执行"></a>严格串行执行</h2><ol><li>采用单线程按顺序执行事务，避免检测、事务冲突等问题；同时可能会比支持并发的系统效率更高，避免锁的开销</li><li>为什么可行？<ol><li>内存更便宜</li><li>OLTP 事务通常很快执行完，只产生少量读取</li></ol></li><li>典型的代表：VoltDB / H-Store, Redis 和 Datomic</li><li>通常不能支持交互式的多语句事务（否则得等待太久了）<br> <img src="./procedure.png" alt=""></li><li>满足以下约束，串行执行事务科实现串行化隔离：<ol><li>事务必须<strong>简短高效</strong></li><li>仅限于活动数据集完全可以加载到内存的场景</li><li>写入吞吐必须足够低，才能在单核上处理；否则需要采用分区，但最好不要使用跨分区事务（避免协调开销）</li><li>跨分区事务可以支持，但占比必须要小</li></ol></li></ol><h2 id="两阶段锁（Two-Phase-Lock-2PL）"><a href="#两阶段锁（Two-Phase-Lock-2PL）" class="headerlink" title="两阶段锁（Two-Phase Lock, 2PL）"></a>两阶段锁（Two-Phase Lock, 2PL）</h2><ol><li>2PL 是比较老牌的串行化算法，应用于 MySQL InnoDB 和 SQL Server 的「可串行化隔离」和 DB2 的「可重复读隔离」。悲观事务模型。</li><li>典型特征：<ol><li>读写互斥</li><li>并发写互斥</li></ol></li><li><p>基本思路（数据库会为每个对象维护读写锁来隔离读写操作，锁可以处于<strong>共享模式</strong>或<strong>独占模式</strong>）：</p><ol><li>如果事务要读取对象，必须先以共享模式获得锁。多个事务可同时以获得对象的共享锁；但如果某个事务获得了对象的独占锁，则其他事务都需要等待</li><li>如果事务要修改对象，必须以独占模式获取锁。如果对象已经加锁（不管是读还是写），则该事务必须等待</li><li>如果事务先读后写，则将共享锁升级为独占锁</li><li>事务获取锁后，直到事务结束才会释放</li></ol></li><li><p>两阶段的含义：</p><ol><li>事务执行前<strong>获取锁</strong></li><li>事务结束后<strong>释放锁</strong></li></ol></li><li><p>2PL 的问题：</p><ol><li>系统吞吐量和查询响应时间相对于弱隔离级别下降很多</li><li>锁的开销多；事务的并发性降低</li><li>访问延迟不确定性高</li><li>死锁问题，如果检测到死锁，事务会被强行中止（应用层可选择重试）</li></ol></li><li><p>谓词锁：</p><ol><li>不属于特定的对象，作用于特定的搜索条件查询到的所有对象</li><li>可以保护数据库中尚不存在但可能马上会被插入的对象（会引起幻读）</li><li>2PL 和谓词锁结盟，可阻止任何形式的写倾斜和其它竞争条件，使得隔离真正串行化</li><li>缺点：性能不佳</li></ol></li><li><p>索引区间锁（next-key locking）</p><ol><li>核心就是将保护对象扩大化，不如为谓词锁精确，但开销低，所以实践中常用</li><li>会对合适的索引加区间锁，如果没有合适的索引，就回退到整张表加共享锁</li></ol></li></ol><h2 id="可串行化快照隔离（Serializable-Snapshot-Isolation-SSI）"><a href="#可串行化快照隔离（Serializable-Snapshot-Isolation-SSI）" class="headerlink" title="可串行化快照隔离（Serializable Snapshot Isolation, SSI）"></a>可串行化快照隔离（Serializable Snapshot Isolation, SSI）</h2><ol><li>SSI 是乐观事务模型实现，如果可能发生冲突，也不会阻止事务提交，而是在真正提交时检查是否发生了冲突（即违反隔离性原则），如果是，则会中止并接下来重试。</li><li>适用于事务之间竞争不大，冲突较少的场景，会比悲观方式高效很多（所以也比较适用于互联网环境）。</li><li>事务无需等待其它事务所持有的锁，要求读写型事务要简短（长时间的读取事务没有限制）<br><img src="./collision-detection.png" alt=""></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">《数据密集型应用设计》第二部分</a></li><li><a href="https://www.zhihu.com/question/280650327" target="_blank" rel="noopener">知乎：SQL 四种隔离级别的若干迷惑？</a></li><li><a href="https://zhuanlan.zhihu.com/p/38214642" target="_blank" rel="noopener">数据库事务隔离标准分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;由于数据存储期间，可能发生错误、故障的点特别多，比如网络中断、磁盘写满等，面对这些复杂的情况，应用层应付起来非常困难。所以就有了事务的概念，说道事务，我们最先能想到的就是：可以一次事务中将很多读写入操作打包成一个逻辑操作单元，整个事务不成功（Committed）便成仁（Rollback）。如果失败，应用层可根据情况安全地重试，不用担心部分写入的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://ifaceless.space/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="《数据密集型应用设计》" scheme="http://ifaceless.space/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
      <category term="事务" scheme="http://ifaceless.space/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>野猪🐗书读书笔记之数据复制和分区</title>
    <link href="http://ifaceless.space/2019/08/18/ddia-data-replication-and-partition/"/>
    <id>http://ifaceless.space/2019/08/18/ddia-data-replication-and-partition/</id>
    <published>2019-08-18T11:27:19.000Z</published>
    <updated>2019-11-24T09:45:59.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>完成第一部分的数据系统基础学习后，就开始进入分布式数据系统的世界了。前面学习的内容主要是针对单节点的情况；然而，在现实中，我们需要考虑到系统的<strong>扩展性</strong>、<strong>容错性</strong>以及<strong>延迟性</strong>等，这就引入了分布式系统。分布式系统中通常会有很多个节点，复杂度自然也上来了。这个部分将主要学习数据系统的复制、分区、事务、一致性共识算法、以及分布式系统设计时的一些挑战等，这些知识都比较硬核，也非常有趣。所以，「上车，走吧~」</p><p>本篇笔记重点是关于数据系统的复制和分区，可以了解下常规的主从复制原理、多主复制的应用场景，另外还介绍了无主复制的系统（如亚马逊 Dynamo 系统）。最后就是关于数据分区的介绍，可以了解下常见的分区策略，动态平衡策略等。</p><a id="more"></a><h1 id="为什么需要分布式系统？"><a href="#为什么需要分布式系统？" class="headerlink" title="为什么需要分布式系统？"></a>为什么需要分布式系统？</h1><h2 id="共享架构"><a href="#共享架构" class="headerlink" title="共享架构"></a>共享架构</h2><p>针对共享架构，如果负载增加，最常见的扩展方式就是采买更强大的 CPU、添加更多的内存等。这种被称为垂直扩展，但是这种方式并不一定奏效，天花板是看得见的。并且扩展的成本非线性，而应对负载的能力却不一定能线性提高。</p><h2 id="无共享架构"><a href="#无共享架构" class="headerlink" title="无共享架构"></a>无共享架构</h2><p>在无共享架构中，每个节点使用独立的 CPU、内存和磁盘，节点之间的通信采用以太网。该架构无需特殊的硬件支持，性价比高。扩展性好（水平扩展），并且有强大的容错能力和负载均衡能力。不过这种架构最大的问题是会带来更大的复杂性，甚至会限制实际可使用的数据模型。</p><h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><h2 id="主节点和从节点"><a href="#主节点和从节点" class="headerlink" title="主节点和从节点"></a>主节点和从节点</h2><ol><li>每个保存了数据库完整数据集的节点叫作副本</li><li>主从复制方案：<ol><li>指定某个副本为主副本（主节点）。写入会发给主节点</li><li>主节点在将新数据存储后，将更改作为复制的日志或者更改流的方式发给从节点。从节点获取更改日志，并应用到本地，这里必须要保持和主副本相同的写入顺序</li><li>客户端读取时，可读取从副本的数据<br><img src="./master-slave-replication.png" alt=""></li></ol></li></ol><h3 id="同步复制-v-s-异步复制"><a href="#同步复制-v-s-异步复制" class="headerlink" title="同步复制 v.s. 异步复制"></a>同步复制 v.s. 异步复制</h3><p><img src="./data-sync.png" alt=""></p><ol><li>对于关系数据库，两种复制方式通常是可配置的；而其他系统可能只可指定其中一种方式。</li><li>同步复制：<ol><li>优点：一旦向用户确认写入请求，则主从数据一致，并都处于最新版本。主库宕机，也可以放心从从库读取。</li><li>缺点：如果从节点无法完成确认（如网络拥塞、故障等），写入会失败。主节点会阻塞后续写请求，降低系统吞吐量和可靠性。</li></ol></li><li><strong>半同步</strong>：实践中，如果开启了同步复制模式，通常是其中的<strong>某个从节</strong>（可根据情况选择其他从节点提升为同步模式）点为同步复制，而其他为异步复制模式。</li><li><strong>全异步</strong>：<ol><li>优点：系统的吞吐性能很好</li><li>缺点：数据的持久化无法得到保证，可能存在数据丢失的情况</li></ol></li></ol><h3 id="配置新的从节点"><a href="#配置新的从节点" class="headerlink" title="配置新的从节点"></a>配置新的从节点</h3><ol><li><p>什么时候需要？</p><ol><li>提高负载能力</li><li>提供容错能力</li><li>替换失败的副本</li></ol></li><li><p>要想做到不停机完成新节点添加，逻辑上主要操作如下：</p><ol><li><strong>生成快照</strong>：在某刻对主节点的数据副本产生一个一致性快照（避免长时间锁库）</li><li><strong>快照发送</strong>：快照发送到新的从节点（这样大部分的历史数据就有了）</li><li><strong>变更日志</strong>：从节点上线连接到主节点，<strong>请求快照点之后发生的所有数据更改日志</strong>（增量）</li><li><strong>追赶</strong>：获得日志后，从节点应用快照后的数据变更。继续处理主节点上新数据变化。并重复步骤 1~4</li></ol></li></ol><h3 id="节点失效怎么办？"><a href="#节点失效怎么办？" class="headerlink" title="节点失效怎么办？"></a>节点失效怎么办？</h3><ol><li><strong>从节点失效：追赶式恢复</strong>。从节点可根据副本的复制日志得知故障前最后一笔事务，然后向主节点请求该事务之后中断期间内的所有数据变更，并应用变更，完成追赶。</li><li><p><strong>主节点失效：节点切换</strong>：</p><ol><li>故障切换可手动，可自动。</li><li>自动切换常规步骤：<ol><li><em>确定主节点失效</em>。多采用基于超时的机制，可以周期性地发送心跳包。</li><li><em>选举新的主节点</em>。涉及到共识的算法，原则是要保证新的主节点与原来的数据差异最小，尽可能减少数据丢失风险。</li><li><em>重新配置系统，生效主节点</em>。客户端需要将写请求发送到新的主节点，对于原主节点恢复后需要确保其被降级为从节点，认可新的主节点。</li></ol></li></ol></li><li><p>需要思考的问题：</p><ol><li>如果采用异步复制，新的主节点选举后，原主节点也上线，新的主节点可能会收到<strong>写冲突</strong>。简单粗暴的方式就是，抛弃原主节点未完成复制的写请求，违背数据持久化承诺。</li><li><strong>脑裂（Brain-Split）</strong>问题，两个主节点都接收写请求，会导致数据冲突、丢失或者破坏等。可粗暴地关闭某个主节点。</li><li>超时设置多久才合适？太长，意味着主节点宕机后，总体恢复时间变长；太短，会导致很多不必要的切换。尤其是系统处于高负载的压力下，同时网络拥塞严重，不必要的切换会导致情况更加糟糕。</li></ol></li></ol><h3 id="复制日志如何实现"><a href="#复制日志如何实现" class="headerlink" title="复制日志如何实现"></a>复制日志如何实现</h3><ol><li><p><strong>基于语句的复制</strong>：</p><ol><li>看起来不复杂</li><li>不适用的场景：调用非确定性函数的语句；副本需要严格按照完全相同的顺序执行语句（针对依赖数据库的现有数据的情况）；有副作用的语句，在不同的节点可能会产生不同的副作用</li></ol></li><li><p><strong>基于 WAL 传输</strong>：</p><ol><li>可以基于 WAL 构建一个完整的副本</li><li>日志描述的数据结构很底层，复制方案与存储引擎紧密耦合；协议版本升级需要顾虑的较多</li></ol></li><li><p><strong>基于行的逻辑日志复制</strong>：</p><ol><li>逻辑日志，区分物理存储引擎的数据表示。描述数据表行级别的写请求。</li><li>与存储引擎逻辑解耦，便于保持向后兼容。这样主从节点甚至可以运行不同的版本或者使用不同的存储引擎。</li><li>容易解析，易于外部系统处理</li></ol></li><li><p><strong>基于触发器的复制</strong>：给应用层提供了一定的灵活性，但是复制开销更高。</p></li></ol><h2 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h2><h3 id="读自己的写（Read-After-Write）"><a href="#读自己的写（Read-After-Write）" class="headerlink" title="读自己的写（Read After Write）"></a>读自己的写（Read After Write）</h3><p><img src="./read-after-write.png" alt=""></p><ol><li>该机制要保证用户总能看到自己最近提交的更新。</li><li>如何实现？<ol><li>如果用户访问可能被修改的内容，则从主节点读；否则从从节点读。</li><li>针对大部分都会被修改的场景，上述方式会丧失从节点的存在意义。可以考虑跟踪最新的更新时间，对于更新时间在最近一分钟的，从主节点读取。同时需要添加监控。</li></ol></li></ol><h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p><img src="./monotonic-read.png" alt=""></p><ol><li>用户在读取修改了的数据时，出现「回滚」的现象。也就是明明修改了，并且第一次读的时候看到了新的数据，但是在第二次读取的时候却看到了旧的数据（多节点数据未同步）。</li><li>单调读要提供的保证就是避免这种奇怪的回滚现象，它比强一致性要弱，但比最终一致性要强。</li><li>可能的解决方案：可以考虑同一个用户总是从某个固定的副本读取（不同的用户分发到不同的副本）。</li></ol><h3 id="前缀一致读"><a href="#前缀一致读" class="headerlink" title="前缀一致读"></a>前缀一致读</h3><p><img src="./prefix-read.png" alt=""></p><ol><li>该机制要保证对于一系列按照特定顺序的写请求，在读取这些内容时要要遵循同样的顺序。否则可能会看到先有果，再有因的奇怪现象，仿佛遇到了先知。</li><li>可能的解决方案：确保拥有因果关系的写入都提交给某个特定分区完成，但是实际效率比较低。</li></ol><h2 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h2><p><img src="./multi-master-nodes.png" alt=""></p><ol><li>主从模式的缺点：系统仅有一个主节点，承载所有的写请求。如果主节点宕机，会影响所有的写入操作。</li><li>多主节点复制：<ol><li>每个主节点分别接受写请求，并复制（异步 or 同步）给对应的从节点</li><li>每个主节点扮演其它主节点的从节点</li></ol></li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>多数据中心</li><li>离线客户端操作（典型的例子是 WizNote），每个设备都充当主节点的本地数据库，设备之间采用异步同步方式完成数据同步。同步滞后时间不定。</li><li>协作编辑</li></ol><h2 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h2><ol><li>亚马逊的 Dynamo 系统是典型的代表，Riak、Cassandra 也受到了启发。</li><li>客户端直接将写请求发送给多个副本，或者交给协调者（不保证写入顺序）来发送。</li><li><p>数据一致性保证？</p><ol><li>读时修复</li><li>反熵：补偿机制，寻找节点之间的差异，将缺少的数据给补充好。该过程不保证特定顺序的复制写入。<br><img src="./repair-on-read.png" alt=""></li></ol></li><li><p>读写 quorum：</p><ol><li>保证：w + r &gt; n（总节点数）</li><li>通常 n 为奇数，w = r = (n+1)/2 （向上舍入）</li><li>quorum 不一定非得是多数，读写节点集合中至少有一个是重叠的节点才最为关键！</li><li>不能保证总能读取到最新值，Dynamo 数据库通常针对最终一致性场景优化的。</li></ol></li><li>并发检测（这块还是建议看书中的例子吧）：<ol><li>最后写入者获胜（LWW），丢弃并发写入。可实现最终收敛目标，但是牺牲了数据持久性为代价。</li><li>Happens-before 关系与并发</li><li>确定前后关系：使用版本号</li><li>合并同时写入的值</li><li>版本矢量</li></ol></li></ol><h1 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h1><ol><li>定义：每条数据（或者记录、文档）只属于某个特定分区，每个分区可视为一个完整的小型数据库，是整个数据集的一部分。</li><li><p>为什么要分区？</p><ol><li>提高系统扩展性：将大的数据集分散到更多的节点，负载均衡</li><li>提高查询吞吐量：跨分区并发查询</li></ol></li><li><p>分区和复制通常结合使用，每个分区在多个节点上都有副本，提高系统的容错性：<br> <img src="./partition.png" alt=""></p></li></ol><h2 id="KV-数据分区"><a href="#KV-数据分区" class="headerlink" title="KV 数据分区"></a>KV 数据分区</h2><ol><li><p>分区可能带来的问题：</p><ol><li>分区不均匀，会造成访问倾斜的问题，甚至可能造成热点</li><li>可采用随机分配到所有节点避免热点问题，但是查询会很困难（可能需要并发请求所有分区）</li></ol></li><li><p>基于关键字区间分区：</p><ol><li>核心是<strong>为每个分区分配一段连续的关键字或者关键字区间</strong>（以最小值和最大值来表示）</li><li>关键字区间段不一定要均匀分布</li><li>支持区间查询方便（有一定顺序）</li><li>可能会有热点问题（比如按照时间戳范围划分，可能最新的日期读写就很多），可以考虑再添加别的字段来组合决定分区</li></ol></li><li><p>基于关键字哈希值分区：</p><ol><li>好的哈希函数可处理数据倾斜，均匀分布</li><li>丧失良好的区间查询特性<br><img src="./partition-with-hash.png" alt=""></li></ol></li><li><p>负载倾斜和热点：</p><ol><li>即便通过哈希值分区的方案，也不能完全避免热点问题。极端情况是，所有的读写都针对同一个关键字（如微博大 V），导致所有请求都到了同一个分区。</li><li>大多数系统无法自动消除这种高度倾斜的负载，需要应用层介入。</li></ol></li></ol><h2 id="分区和二级索引"><a href="#分区和二级索引" class="headerlink" title="分区和二级索引"></a>分区和二级索引</h2><ol><li>二级索引的挑战是不能规整地映射到分区中。</li><li><p>基于文档分区的二级索引：</p><ol><li>每个分区只关注自己的分区的文档，并建立了独立的索引</li><li>查询时延迟放大严重，需要分散查询并合并结果，代价较高<br><img src="./secondary-index-on-doc.png" alt=""></li></ol></li><li><p>基于词条分区的二级索引：</p><ol><li>对所有数据构建全局索引；全局索引并非存储在一个节点上（会进行分区），可以和关键字采取不同的分区策略</li><li>可支持高效地区间查询</li><li>读取高效，不需要 scatter/gather 模式</li><li>写入速度慢，且很复杂，会有显著的写放大问题</li><li>所有现有的数据库都难以支持同步更新二级索引，所以通常都是异步更新<br><img src="./secondary-index-on-terms.png" alt=""></li></ol></li></ol><h2 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h2><ol><li>即将数据和请求从一个节点迁移到另一个节点，这种迁移负载的过程被叫作再平衡（动态平衡）</li><li><p>什么情况下需要？</p><ol><li>查询压力增加，需要增加 CPU 处理负载</li><li>数据规模增加</li><li>节点故障</li></ol></li><li><p>再平衡需要满足的要求：</p><ol><li>平衡之后，负载、数据存储、读写请求等在集群范围更加均匀分布</li><li>平衡过程不能影响线上服务</li><li>避免不必要的负载迁移，尽量减少网络和磁盘 I/O 影响</li></ol></li></ol><h3 id="动态平衡策略"><a href="#动态平衡策略" class="headerlink" title="动态平衡策略"></a>动态平衡策略</h3><ol><li><p>直接取模怎么样？</p><ol><li>方法比较简单，应用层可根据比如用户 ID 和分区数量取模，得到具体要访问的分区对应的节点</li><li>扩展或移除节点困难，涉及到大量数据的移动，应用层代码也可能会被波及</li></ol></li><li><p>固定数量的分区：</p><ol><li>初始时根据长远规划，设置一个远超实际节点数的分区数（比如 1000），每个节点分配多个分区。<strong>每个分区的大小和数据集大小成正比，和节点数无关</strong>。</li><li>新增节点时，从其他节点匀走若干分区，直到再次达到全局平衡；删除节点，则采取相反的措施。</li><li>需要改变分区和节点的映射关系；但是总的分区数不会变，关键字映射也不会变。</li><li>对于数据规模高度不确定或者可变的场景不适用。</li><li>Riak, ES, Couchbase 等支持这种动态平衡策略。<br><img src="./rebalance.png" alt=""></li></ol></li><li><p>动态分区</p><ol><li>如 HBase 和 RethinkDB，可以在分区数据增长到某个阈值（HBase 默认阈值为 10GB）自动拆分成两个分区；如果数据被大量删除，且分区缩小到某个阈值，将相邻的分区进行合并。<strong>类似 B 树分裂</strong>。</li><li>分区数量自动适配分区总量，少量数据-&gt;少量分区-&gt;较小的系统开销；每个分区最大值可被限制。<strong>分区总数和数据集大小成正比，和节点数无关</strong>。</li><li>预分裂可避免初期先验条件不足，无法确定较适合的边界，导致写入都集中在单个节点处理的问题。HBase 和 MongoDB 都支持配置初始分区。</li><li>适合关键字区间分区和哈希分区策略。</li></ol></li><li><p>按节点比例分区：Cassandra 和 Ketama 采用了将分区数和集群节点数成正比关系的方式，每个节点的分区数固定：</p><ol><li>节点数不变时，分区大小和数据集总量成正比</li><li>节点数增加时，分区则会变小</li><li>分区大小保持稳定，可添加更多的节点承载更多的数据</li></ol></li></ol><h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><ol><li><p>典型的服务发现问题，处理策略如下：</p><ol><li><strong>集群中的节点感知分区情况</strong>：允许客户端连接任意节点。如果某个节点恰好拥有请求的分区，则直接处理；否则将请求转发给别的节点，等待答复，并返回给客户端。</li><li><strong>路由层感知分区情况</strong>：所有客户端请求发送至一个路由代理层，由它来做转发。</li><li><strong>客户端感知分区和节点分配关系</strong>：客户端可决定连接到哪个节点，无需中介。<br><img src="./route-policies.png" alt=""></li></ol></li><li><p>很多分布式系统使用了独立的协调服务（如 ZooKeeper）跟踪集群中的元数据，比如 HBase，Kafka 等。<br><img src="./zookeeper-save-meta.png" alt="">  </p></li><li><p>另外一种思路是节点之间采用 gossip 协议同步集群状态变化，此时请求可发到任意节点，该节点负责处理或转发。最大的好处是不依赖第三方服务，但是节点复杂性也增加了。典型的代表是 Cassandra 和 Riak，当然还有 Redis Cluster。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">《数据密集型应用设计》第二部分</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;完成第一部分的数据系统基础学习后，就开始进入分布式数据系统的世界了。前面学习的内容主要是针对单节点的情况；然而，在现实中，我们需要考虑到系统的&lt;strong&gt;扩展性&lt;/strong&gt;、&lt;strong&gt;容错性&lt;/strong&gt;以及&lt;strong&gt;延迟性&lt;/strong&gt;等，这就引入了分布式系统。分布式系统中通常会有很多个节点，复杂度自然也上来了。这个部分将主要学习数据系统的复制、分区、事务、一致性共识算法、以及分布式系统设计时的一些挑战等，这些知识都比较硬核，也非常有趣。所以，「上车，走吧~」&lt;/p&gt;
&lt;p&gt;本篇笔记重点是关于数据系统的复制和分区，可以了解下常规的主从复制原理、多主复制的应用场景，另外还介绍了无主复制的系统（如亚马逊 Dynamo 系统）。最后就是关于数据分区的介绍，可以了解下常见的分区策略，动态平衡策略等。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://ifaceless.space/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="分布式数据库" scheme="http://ifaceless.space/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据复制" scheme="http://ifaceless.space/tags/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"/>
    
      <category term="数据分区" scheme="http://ifaceless.space/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>野猪🐗书读书笔记之数据系统基础</title>
    <link href="http://ifaceless.space/2019/08/14/ddia-data-sys-basics/"/>
    <id>http://ifaceless.space/2019/08/14/ddia-data-sys-basics/</id>
    <published>2019-08-14T14:12:51.000Z</published>
    <updated>2019-11-24T09:45:59.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>《数据密集型应用系统设计》（Design Data-Intensive Applications）是一本非常有诚意、非常优秀的讲解针对数据密集场景下系统设计相关的目标、原则和技术选型等知识。作者结合理论与实践，为我们展现了一些技术的发展趋势以及它们之间的对比；同时还介绍了一些关键技术（如存储引擎、序列化协议、分布式一致性）等的实现原理，让我们能够<strong>知其然，更知其所以然</strong>。</p><a id="more"></a><p>好书自然要精读细品，写点读书笔记才能把握自己的学习进度和理解程度。总的来说，笔记形式将以图文为主，思维导图为辅的方式来呈现。<strong>由于该书的封面是一头野猪🐗，故将本系列读书笔记命名为《野猪书读书笔记》</strong>。<br>书中主要分为三个部分展开：</p><ul><li>讨论有关增强数据密集型应用系统所需要的若干基本原则。</li><li>从单机数据存储专享跨机器的分布式系统。</li><li>主要针对派生数据的系统设计，并讨论批处理和流式处理。</li></ul><p>野猪书学习完成后，可以考虑如下深入学习路线：</p><ul><li>关系型数据库：<ul><li>MySQL </li><li>存储引擎（InnoDB &amp; MyISAM）</li></ul></li><li>分布式数据库：<ul><li>一致性协议（Paxos, Raft, Zookeeper）</li><li>数据库（TiDB ）</li><li>存储引擎（TiKV &amp; RocksDB &amp; LevelDB）</li></ul></li><li>非关系数据库或缓存系统：<ul><li>Redis（设计思想、数据结构、集群管理）</li><li>HBase（设计思想、使用方式和场景、存储管理）</li></ul></li><li>消息队列系统：<ul><li>应用层框架（Celery）</li><li>AMQP 协议实现的消息队列服务（RabbitMQ）</li><li>简易的消息队列服务（Beanstalk）</li><li>高吞吐量的消息队列服务（RocksDB、Kafka）</li></ul></li><li>搜索引擎：ElasticSearch</li></ul><h1 id="可靠、可扩展与可维护的应用系统"><a href="#可靠、可扩展与可维护的应用系统" class="headerlink" title="可靠、可扩展与可维护的应用系统"></a>可靠、可扩展与可维护的应用系统</h1><ol><li><strong>数据密集型（Data-Intensive）</strong>是指对于一个应用系统而言，「数据」是其成败的决定性因素，包括<strong>数据的规模、数据的复杂度或数据产生和变化的速率等</strong>。</li><li><strong>计算密集型（Compute-Intensive）</strong>，以计算为主的系统，CPU 主频通常是它的制约瓶颈</li><li><strong>数据系统</strong>：<ol><li>通常来说，数据库、缓存、消息队列被认为是不同类型的系统，有不同的性能和设计实现；</li><li>但近年来，技术的发展导致它们之间的界限逐渐模糊。比如 Redis 既可以存储，也可以做消息队列；Kafka 可以做消息队列，也具备持久化的能力。因此，统一称为「数据系统（data system）」；</li><li>应用系统的需求更加广泛，单一组件无法满足所有的数据处理和存储需求；通常需要组合多个组件，并通过应用层代码驱动实现衔接。</li></ol></li></ol><h2 id="可靠性（Reliability）"><a href="#可靠性（Reliability）" class="headerlink" title="可靠性（Reliability）"></a>可靠性（Reliability）</h2><ol><li>目标：<strong>当意外情况（包括硬件、软件故障以及人为失误）发生时，系统应该可以继续正常工作。虽然性能会有所降低，但会确保功能正确。</strong></li><li>可能出错的事称为<strong>错误（faults）或故障</strong>，系统可应对错误，则称为<strong>容错（fault-tolerant）</strong>或者**弹性（resilient）。</li><li><strong>失效（failure）</strong>比 fault 严重，意味着整个系统无法对外提供用户所需服务。</li><li>硬件故障问题可以通过增加冗余的方式来有效解决，但为了提高可用性，软件容错的方式也可以用来容忍多机失效的手段，作为硬件容错的补充。</li><li>软件故障问题通常难以预料，且一旦发生产生的影响会非常广泛，横跨整个系统都可能。并无快速解决之法。在使用之处，需要考虑好很多细节，梳理依赖假设和系统间的交互。另外，进行全面测试，做好进程隔离，允许崩溃后自动重启。</li><li>保证系统可靠性，减少人为失误：<ol><li>以最小出错的方式设计系统</li><li>想办法分离最容易出错的地方、容易发生故障的接口</li><li>充分地测试</li><li>当发生人为失误时，提供快速恢复机制，减少故障影响</li><li>提供详细清晰的子系统，包括性能指标和错误率</li><li>推行管理流程并加以培训</li></ol></li></ol><h2 id="可扩展性（Scalability）"><a href="#可扩展性（Scalability）" class="headerlink" title="可扩展性（Scalability）"></a>可扩展性（Scalability）</h2><ol><li>目标：<strong>随着规模增长（包括数据量、流量或者复杂度），系统应用能以合理的方式匹配这种增长。</strong></li><li>用来描述系统应对负载增加能力的术语。</li><li><strong>描述负载</strong>：需要知道什么是负载参数。参数的最佳选择取决于系统的体系结构，可能是 Web 服务的每秒请求量，数据库写入比例，聊天室活动人数，缓存命中率，用户关注者分布情况等。</li><li><strong>描述性能</strong>：<ol><li>批处理系统关注的是吞吐量（throughout）</li><li>Web 服务器更关注请求响应时间，更经常关注的是平均响应时间</li><li>中位数响应时间通常也叫 p50</li><li>常见的还会关注 p95, p99, p999 值</li><li>服务质量目标 Service Level Objectives, SLO</li><li>服务质量协议 Service Level Agreements, SLA</li></ol></li></ol><h2 id="可维护性（Maintainability）"><a href="#可维护性（Maintainability）" class="headerlink" title="可维护性（Maintainability）"></a>可维护性（Maintainability）</h2><ol><li>目标：<strong>随着时间的推移，新的人员参与到系统的开发和运维，以维护现有功能或适配新场景，系统都应该高效运转。</strong></li><li>谁都不情愿维护遗留系统，为什么呢？因为可能要修复别人埋下的坑，做不喜欢的事情。所以在做系统设计之初，就应该关注系统设计的三大原则，尽可能减少维护期的麻烦：<ol><li>可运维性：运维更轻松</li><li>简单性：简化系统复杂度，但并非减少产品功能。可以通过较好的抽象来让系统变得更清晰和易于理解</li><li>可演化性：易于改变</li></ol></li></ol><h1 id="数据模型和查询语言"><a href="#数据模型和查询语言" class="headerlink" title="数据模型和查询语言"></a>数据模型和查询语言</h1><ol><li>复杂的应用程序会有很多层，但核心思想是：每层都通过提供一个简洁的数据模型来隐藏下层的复杂性</li></ol><h2 id="关系数据库和文档数据库"><a href="#关系数据库和文档数据库" class="headerlink" title="关系数据库和文档数据库"></a>关系数据库和文档数据库</h2><ol><li><p>NoSQL 数据库几大驱动因素：</p><ol><li>比关系数据库扩展性好，支持超大数据集或超高写入吞吐量</li><li>开源免费居多</li><li>关系模型不能很好支持某些特定查询</li></ol></li><li><p>任何对人类有意义的东西都可能在将来某个时刻发生改变。所以在数据库中我们使用关联的 ID 作为标志的好处就是它没有直接意义，永远不需要直接改变</p></li><li><p>层次模型：</p><ol><li>代表是 IBM 的 Information Mangagement System, IMS</li><li>类似 JSON 结构，能够很好表示一对多关系；多对多关系很难表示</li></ol></li><li><p>网络模型：</p><ol><li>层次模型的推广，支持多对一和多对多的关系</li><li>查询困难、更新复杂且不够灵活</li><li>对应用程序的数据模型进行更改是非常困难的事情</li><li>应用需要关心复杂的访问路径</li></ol></li><li><p>关系模型：</p><ol><li>定义了所有数据的格式：关系（表）只是元组（行）的集合</li><li>查询优化器可以自动决定查询顺序执行；使用何种索引。相当于自动维护「访问路径」</li><li>应用添加新功能变得容易</li></ol></li><li><p>关系数据库和文档数据库：</p><ol><li>表示多对一和多对多都使用了标识符</li><li>前者叫作外键（或者可以在应用中关联）；后者叫作文档引用</li></ol></li><li><p>读时模式：文档数据库中，数据结构是隐式的，只有在读取时才解释</p></li><li>写时模式：关系数据库中，模式是显式的，数据库保证写入时遵循模式</li><li>融合关系模型和文档模型是未来发展的一个较好的途径</li></ol><h2 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h2><ol><li><p>SQL：</p><ol><li>声明式</li><li>简洁、易使用</li><li>很多限制的事实，也成为数据库自动优化提供了空间</li><li>底层易于使用并发查询</li></ol></li><li><p>IMS/CODASYL（层次模型、网络模型）：</p><ol><li>命令式</li></ol></li><li><p>MapReduce：</p><ol><li>一种编程模型，用于在许多机器上批量处理海量数据</li><li>既非声明式，也非完全命令式；介于二者之间</li><li>底层编程模型，用于在计算集群上分布执行；可执行的操作限定为纯函数</li></ol></li></ol><h2 id="图数据库模型"><a href="#图数据库模型" class="headerlink" title="图数据库模型"></a>图数据库模型</h2><ol><li>关系数据库适合处理简单的多对多模型；但随着数据之间的关联越来越复杂，转换为图模型会更加自然</li><li>顶点和边组成</li><li>建模示例：<ol><li>人际关系</li><li>Web 网页</li><li>公路或者铁路网</li></ol></li><li>更强大用处：提供了单个数据存储区保存完全不同类型对象的一致性方式</li></ol><h3 id="属性图模型（Property-Graph）"><a href="#属性图模型（Property-Graph）" class="headerlink" title="属性图模型（Property Graph）"></a>属性图模型（Property Graph）</h3><ol><li>代表：Neo4j, Titan, InfiniteGraph</li><li><p>顶点（vertice）：</p><ol><li>唯一标志</li><li>出边集合</li><li>入边集合</li><li>属性集合</li></ol></li><li><p>边（edge）：</p><ol><li>唯一标志</li><li>边开始顶点</li><li>边结束的顶点</li><li>标签</li><li>属性集合</li></ol></li></ol><h3 id="三元图存储模型（Triplestore）"><a href="#三元图存储模型（Triplestore）" class="headerlink" title="三元图存储模型（Triplestore）"></a>三元图存储模型（Triplestore）</h3><ol><li>代表：Datomic, AllegroGraph</li><li>几乎等同于属性图模型，可能作为构建应用程序的补充</li><li>形式：(主体，谓语，客体)</li><li>主体相当于图中的顶点，客体则是以下两种之一：<ol><li>原始数据类型中的值（字符串或数字），如 <code>(lucy, age, 40)</code></li><li>图的另外一个顶点，如 <code>(lucy, mariedTo, alain)</code></li></ol></li></ol><h3 id="查询语言-1"><a href="#查询语言-1" class="headerlink" title="查询语言"></a>查询语言</h3><ol><li>Cypher，最早用于 Neo4j。声明式查询语言</li><li>SQL:1999 标准后，可以使用递归公用表达式（WITH RECURSIVE）来表示可变的遍历路径查询</li><li>SPARQL：采用 RDF 数据模型的三元存储查询语言</li><li>Datalog：数据模型采用「谓语（主体，客体）」模式；规则可以在不同的查询中组合和复用；对于简单查询虽然繁琐，但针对复杂数据，则更加灵活</li></ol><h1 id="数据存储和检索"><a href="#数据存储和检索" class="headerlink" title="数据存储和检索"></a>数据存储和检索</h1><h2 id="数据库核心：数据结构"><a href="#数据库核心：数据结构" class="headerlink" title="数据库核心：数据结构"></a>数据库核心：数据结构</h2><ol><li>索引可以帮助高效地查询数据库中特定的键；是基于原始数据派生而来的额外数据结构</li><li>任何类型的索引通常都会降低写的速度</li></ol><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><ol><li>以 Bitcast 为代表的存储引擎，采用了哈希索引</li><li>适合每个键的值更新频繁的场景</li><li>哈希索引的特点：<ol><li>哈希表必须全部存放在内存中，键值指向的是文件段中的偏移，用于查找具体的数据</li><li>可采用分段的思想，再配合后台合并、压缩等手段来避免磁盘写入耗尽的问题，减少磁盘碎片</li><li>新的数据采用追加而非原地修改的策略，提高写入吞吐量</li><li>区间查询效率不高</li></ol></li></ol><h3 id="SSTables-和-LSM-Tree"><a href="#SSTables-和-LSM-Tree" class="headerlink" title="SSTables 和 LSM-Tree"></a>SSTables 和 LSM-Tree</h3><ol><li>SSTable 的全称：Sorted String Table，排序字符串表</li><li>LSM-Tree 的全称：Log-Structured Merge-Tree</li><li><p>相比哈希索引的优点：</p><ol><li>合并段更简单高效，对于大文件也是如此</li><li>段文件中的 key-value 顺序是按照键排序过的，便于合并和查找</li><li>在文件中查找特定键时无需在内存中保存所有键的索引（稀疏索引放在内存中）</li><li>支持范围查找</li></ol></li><li><p>构建和维护 SSTables</p><ol><li>在内存中维护一个内存表，写入时先写入该表（有序的数据结构，如红黑树或者跳表）</li><li>内存表超过一定阈值时，直接写盘，形成 SSTable；在写盘同时，可添加新的内存表实例，接收后续写请求</li><li>对于读请求，内存表-&gt;最新磁盘段文件-&gt;次新段文件-&gt;…直到找到目标或者为空</li><li>后台定期合并、压缩，丢弃被覆盖或删除的值</li></ol></li><li>避免崩溃的方式：每个写入记录到日志，当内存表写入 SSTable 后才可以丢弃相应日志</li><li>基于合并和压缩排序文件原理的存储引擎通常都叫作 LSM 存储引擎</li><li>性能优化：<ol><li>分层压缩，LevelDB &amp; RocksDB</li><li>按大小分级，HBase, Cassandra 则两种都支持</li><li>布隆过滤器</li></ol></li></ol><h3 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h3><ol><li>广泛使用认可的索引结构，很多数据库中标准索引实现；即使在非关系数据库中也有用到</li><li>B-Tree 是面向块或者页进行设计的，它将数据库分解成固定大小的块或页，一般为 4 KB，页是内部读写的最小单元</li><li>每个页面都有标识符，可被引用</li><li>一个页所包含的页面引用数量称为分支因子</li><li><p>更新策略：</p><ol><li>搜索包含指定键的子页</li><li>修改该页的值</li><li>整页回写到磁盘（相当于覆盖原先的页，对该页的任何引用依然有效）</li></ol></li><li><p>新加键策略：</p><ol><li>找到可容纳新键范围的页，然后添加到该页</li><li>若页面空间不足，则将其分裂为两个半满的页，同时修改父页，记录分裂后的新的键的范围</li></ol></li><li><p>一个具有 N 个键的 B-Tree 的深度为 O(log N)；多数数据库可以适合 3~4 层 B-Tree。分支因子为 500 的 4KB 四级树可存储 256TB 的数据</p></li><li>崩溃恢复：WAL, Write-Ahead Log。通过该日志来恢复</li><li>需要考虑并发控制</li><li>写放大的问题（页分裂）</li><li>事务支持更加容易</li></ol><h2 id="事务处理（OLTP）和分析处理（OLAP）"><a href="#事务处理（OLTP）和分析处理（OLAP）" class="headerlink" title="事务处理（OLTP）和分析处理（OLAP）"></a>事务处理（OLTP）和分析处理（OLAP）</h2><ol><li>二者对比：<br> <img src="./compare-oltp-olap.png" alt=""></li><li>大的企业会单独建立数仓，同步来自 OLTP 系统的数据，在单独的数仓中进行分析处理，不会影响线上业务</li><li>导入数仓：ELT, Extract-&gt;Transform-&gt;Load<br> <img src="./etl.png" alt=""></li><li>常见数仓系统：Apache Hive, Spark SQL, Cloudera Implala</li></ol><h3 id="星型与雪花型分析模式"><a href="#星型与雪花型分析模式" class="headerlink" title="星型与雪花型分析模式"></a>星型与雪花型分析模式</h3><ol><li>常见的是星型模式，也称为维度建模。特点是有一个<strong>事实表</strong>，关联了很多个<strong>维度表</strong>。事实表本身可能会很庞大，其中的每一行都代表一个事件，维度通常代表事件的<strong>Who, What, Where, When, How, Why</strong><br> <img src="./star-pattern.png" alt=""></li><li>雪花❄️ 模型是星型模型的变体，它将维度进一步细分为子空间，从而更加规范化。但是这个会增加分析查询的复杂度，所以星型分析模式更受欢迎</li></ol><h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><ol><li>数仓中的列通常很宽，有的可能多达 100 个</li><li>核心思想是将每列中的所有值存储在一起，所有的数据时存储在一组列文件中，每个文件都以相同顺序保存数据行</li><li><p>列压缩：</p><ol><li>很容易进行压缩</li><li>常用位图编码，并配合游程编码降低存储空间（这个主要是针对零位稀疏的情况）<br><img src="./bitmap.png" alt=""></li></ol></li><li><p>列排序：</p><ol><li>可以根据查询需求选择排序的列</li><li>排序可帮助进一步压缩（重复值也可以采用简单的游程编码，所以即便是数十亿行也不怕）</li><li>基于第一个排序键的压缩效果通常最好</li><li>排序类似于关系数据库中用的索引，方便查询</li></ol></li><li>写入可以采取类似 LSM-Tree 的思路</li><li>物化视图：查询结果的实际副本，被写入到磁盘了；虚拟视图则是用于编写查询的快捷方式</li></ol><h1 id="数据编码与演化"><a href="#数据编码与演化" class="headerlink" title="数据编码与演化"></a>数据编码与演化</h1><h2 id="数据编码格式"><a href="#数据编码格式" class="headerlink" title="数据编码格式"></a>数据编码格式</h2><ol><li>程序中至少有两种常用的数据表示形式：<ol><li>内存中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中，对于 CPU 的高效访问和操作做了优化</li><li>数据写入文件或者网络传输时，需要进行编码为字节序列</li></ol></li></ol><h3 id="语言特定的格式"><a href="#语言特定的格式" class="headerlink" title="语言特定的格式"></a>语言特定的格式</h3><ol><li>常见的包括：<ol><li>java.io.Serializable</li><li>Ruby 中的 Marshal</li><li>Python 中的 pickle</li></ol></li><li>优点：对于某种语言自身来说，编解码会很方便，不需要引入第三方依赖</li><li>缺点：<ol><li>与特定语言绑定，不利于和其它语言的异构系统通讯</li><li>可能会有安全性问题</li><li>兼容性不能保证</li><li>效率通常比较低，需要花费较多的 CPU 时间或者内存空间</li></ol></li></ol><h3 id="JSON、XML-和二进制变体"><a href="#JSON、XML-和二进制变体" class="headerlink" title="JSON、XML 和二进制变体"></a>JSON、XML 和二进制变体</h3><ol><li>JSON、CSV、XML 都是文本格式，可读性较好</li><li><p>存在的问题：</p><ol><li>数字编码不明确（比如 CSV 中就无法区分是数字还是数字组成的字符串；JSON 中对于大于 2^53 的整数就傻眼了）</li><li>不支持二进制（虽然可以用 base64 搞事情，但是会增加空间和编解码的时间）</li><li>CSV 无任何模式</li><li>XML 和 JSON 均有可选的模式</li></ol></li><li><p>一些变种，它们的应用并不是很广泛：</p><ol><li>JSON（BSON、BJSON、UBJSON、BISON、Smile 和 Message Pack）</li><li>XML（WBXML 和 Fast Infoset）</li></ol></li><li><p>后面的🌰都以表达下面的信息为例，来做对照：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userName"</span>: <span class="string">"Martin"</span>,</span><br><span class="line">    <span class="attr">"favoriteNumber"</span>: <span class="number">1337</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [<span class="string">"daydreaming"</span>, <span class="string">"hacking"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Message Pack 是 JSON 的二进制编码，示例如下：<br> <img src="./msg-pack-encode.png" alt=""></p></li></ol><h3 id="Thrift-amp-Protocol-Buffers"><a href="#Thrift-amp-Protocol-Buffers" class="headerlink" title="Thrift &amp; Protocol Buffers"></a>Thrift &amp; Protocol Buffers</h3><ol><li>Thrift 是 Facebook 开发，2007~2008 年开源</li><li>Thrift 是一个比较完整的 RPC 框架，在它的协议层提供了多种 Protocol 的实现，方便应付多种场景。比如常见的 <code>BinaryProtocol</code> 和 <code>CompactProtocol</code>。</li><li><p>BinaryProtocol 编码示例：</p><ol><li>与 Message Pack 编码相比，没有了字段名</li><li>使用了 field tag 来映射 IDL 定义的各个字段<br><img src="./thrift-bin-proto-encode.png" alt=""></li></ol></li><li><p>CompactProtocol 编码示例：</p><ol><li>field tag 和 type 使用一个字节表示</li><li>field tag 使用了偏移计算</li><li>整数采用变长字节，而非 BinaryProtocol 中 1337 使用的 8 字节，换成变长字节只需要 2 字节即可<br><img src="./thrift-comp-proto-encode.png" alt=""></li></ol></li><li><p>Protocol Buffers Google 开发，2007~2008 年开源</p></li><li><p>使用 PB 编码的示例：<br> <img src="./pb-encode.png" alt=""></p></li><li><p><code>required</code> 和 <code>optional</code> 这种修饰是不会体现在编码中的，而是在运行时做的检查</p></li><li>保证前后向兼容：<ol><li>field tag 至关重要，不可随便更改</li><li>optional 字段的 field tag 可以删除，但不要复用已删除的 field tag</li><li>新增字段必须是 optional 或者带有默认值，保证向后兼容</li><li>不可轻易修改 field 类型</li></ol></li></ol><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><ol><li>Apache Avro 是 Hadoop 的子项目，提供了两种模式语言：Avro IDL 和 JSON 格式</li><li><p>特点：</p><ol><li>没有标签号</li><li>编码非常紧凑</li><li>编码中没有字段类型</li></ol></li><li><p>编码示例：<br> <img src="./avro-encode.png" alt=""></p></li><li><p>区分读模式和写模式。写模式和读模式不必完全一模一样，只需要保持兼容</p></li><li>写模式和读模式中的字段顺序可不同，因为在模式解析时会使用字段名匹配</li><li>动态生成模式是最大的特点，不需要像 PB 或者 Thrift 中那样，显式分配 field tag，比较灵活。特别适合编码数据库表。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">数据密集型应用设计：第一部分</a></li><li><a href="http://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a></li><li><a href="https://developers.google.cn/protocol-buffers/" target="_blank" rel="noopener">Protocol Buffers</a></li><li><a href="http://avro.apache.org/docs/current/gettingstartedpython.html" target="_blank" rel="noopener">Avro Python Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;《数据密集型应用系统设计》（Design Data-Intensive Applications）是一本非常有诚意、非常优秀的讲解针对数据密集场景下系统设计相关的目标、原则和技术选型等知识。作者结合理论与实践，为我们展现了一些技术的发展趋势以及它们之间的对比；同时还介绍了一些关键技术（如存储引擎、序列化协议、分布式一致性）等的实现原理，让我们能够&lt;strong&gt;知其然，更知其所以然&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://ifaceless.space/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="《数据密集型应用设计》" scheme="http://ifaceless.space/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
      <category term="分布式" scheme="http://ifaceless.space/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据模型" scheme="http://ifaceless.space/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据库存储" scheme="http://ifaceless.space/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    
      <category term="数据编码" scheme="http://ifaceless.space/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Go 源码学习之 Context</title>
    <link href="http://ifaceless.space/2019/08/02/go-context-intro/"/>
    <id>http://ifaceless.space/2019/08/02/go-context-intro/</id>
    <published>2019-08-02T12:33:11.000Z</published>
    <updated>2019-11-24T09:45:59.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在一次排查某 HTTP 接口请求频繁因 context canceled 错误导致请求处理失败的问题期间，深入了解了下 Go 语言的 Context 实现。本文将首先介绍我们是如何排查诡异的 <code>context canceled</code> 产生原因（也就是在哪儿因为什么而导致取消的）；接下来将深入介绍 Context 诞生的目的、源码解析及应用场景等，便于更进一步加深对它的理解；最后我们也会谈及使用 Context 的一些痛点。</p><a id="more"></a><h1 id="排查-context-canceled-的艰辛历程"><a href="#排查-context-canceled-的艰辛历程" class="headerlink" title="排查 context canceled 的艰辛历程"></a>排查 context canceled 的艰辛历程</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们部署在生产环境的 HTTP 服务中提供了一个用于记录用户课程学习进度的接口，在 Sentry 中发现，有大量 context canceled 报错出现，导致在执行数据库查询时失败，从而导致完整的请求处理流程没有走完（用户的学习进度计算、业务方消息通知等没有执行）。但早期由于 Sentry 接入存在问题，导致错误记录没有上报；直到问题修复后，才在 Sentry 上观察到大量报错提示。由此，开启了<strong>定位 context canceled 问题</strong>之旅~</p><h2 id="报告详细错误日志"><a href="#报告详细错误日志" class="headerlink" title="报告详细错误日志"></a>报告详细错误日志</h2><p>我们首先对发生错误的位置，添加了更详细的错误日志，如请求上下文以及错误发生时的调用栈。待上线后，在 Sentry 中观察到了出错时详细的调用栈如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">File &quot;git.xixi.com/group/project-foo/pkg/models/prog/learn_progress.go&quot;, line 109, in Create</span><br><span class="line">    d.Detect()</span><br><span class="line">  File &quot;git.xixi.com/group/project-foo/pkg/controller/learn_progress.go&quot;, line 46, in Update</span><br><span class="line">    success := learnProgress.Create(ctx, memberID, unitID, bizType, progress, clientUpdatedAt) != nil</span><br><span class="line">  File &quot;git.xixi.com/group/project-foo/pkg/web/handlers/learn_progress.go&quot;, line 77, in Post</span><br><span class="line">    success := h.ctrl.Update(h.R.Context(), memberID, unitID, bizType, progress, item.ClientUpdateAt)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/bit/zerzura@v4.1.1+incompatible/rest/handler.go&quot;, line 53, in ServeHTTP</span><br><span class="line">    render(handler.Post())</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/chi@v3.3.2+incompatible/mux.go&quot;, line 291, in func1</span><br><span class="line">    handler.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/chi@v3.3.2+incompatible/mux.go&quot;, line 424, in routeHTTP</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/bit/zerzura@v4.1.1+incompatible/rest/middleware/sentry_meta.go&quot;, line 19, in func1</span><br><span class="line">    next.ServeHTTP(w, r.WithContext(ctx))</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/go/box@v0.0.0-20190710074902-1cbc4c2abdad/zapi/middleware/auth/nginx.go&quot;, line 200, in func1</span><br><span class="line">    next.ServeHTTP(w, r1)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/go/box@v0.0.0-20190710074902-1cbc4c2abdad/zapi/context.go&quot;, line 67, in func1</span><br><span class="line">    next.ServeHTTP(w, r1)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/cors@v1.0.0/cors.go&quot;, line 199, in func1</span><br><span class="line">    next.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/go/box@v0.0.0-20190710074902-1cbc4c2abdad/zapi/middleware/cors.go&quot;, line 51, in 1</span><br><span class="line">    defaultCORS.Handler(next).ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/chi@v3.3.2+incompatible/middleware/heartbeat.go&quot;, line 21, in 1</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/chi@v3.3.2+incompatible/middleware/recoverer.go&quot;, line 35, in func1</span><br><span class="line">    next.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/chi@v3.3.2+incompatible/middleware/logger.go&quot;, line 46, in 1</span><br><span class="line">    next.ServeHTTP(ww, WithLogEntry(r, entry))</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/go/box@v0.0.0-20190710074902-1cbc4c2abdad/zapi/middleware/realip.go&quot;, line 18, in func1</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/go/box@v0.0.0-20190710074902-1cbc4c2abdad/zapi/middleware/sentry.go&quot;, line 83, in func1</span><br><span class="line">    next.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/git.xixi.com/bit/zerzura@v4.1.1+incompatible/rest/middleware/stats.go&quot;, line 66, in 1</span><br><span class="line">    next.ServeHTTP(lw, r1)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1995, in ServeHTTP</span><br><span class="line">    f(w, r)</span><br><span class="line">  File &quot;/go/pkg/mod/github.com/go-chi/chi@v3.3.2+incompatible/mux.go&quot;, line 81, in ServeHTTP</span><br><span class="line">    mx.handler.ServeHTTP(w, r)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 2774, in ServeHTTP</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">  File &quot;net/http/server.go&quot;, line 1878, in serve</span><br><span class="line">    serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br></pre></td></tr></table></figure></p><p>由于我们是将请求的 <code>Context</code> 一直传递到最下层的，而在父 Context 收到取消信号后也会通知到子 Context，所以我们有理由相信这个取消的触发是在某个父 Context 节点。但具体是在哪儿，什么原因导致的并不清楚。</p><h2 id="修复问题-amp-添加检测"><a href="#修复问题-amp-添加检测" class="headerlink" title="修复问题 &amp; 添加检测"></a>修复问题 &amp; 添加检测</h2><p>不过为了避免因为 <code>sql/driver</code> 层收到 Context Cancel 信号而导致查询失败，进而导致后续的处理流程未能执行，我们决定先修复问题，再排查原因。那怎么修复呢？其实非常简单，我们提供了一个不带 Cancel 的 Context 继续往 <code>sql/driver</code> 层传递，但该 Context 同样继承了父 Context 的 Value，这样一些元信息也可以被继续传递下去。同时为了在检查到原有子 Context 收到 Cancel 信号时，报告详细的错误和 Context String，我们也实现了一个简单的检测器。相关源码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> noCancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *noCancelCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(time.Time, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> time.Time&#123;&#125;, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *noCancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *noCancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *noCancelCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.ctx.Value(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithoutCancel</span><span class="params">(ctx context.Context)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;noCancelCtx&#123;ctx: ctx&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Detector <span class="keyword">struct</span> &#123;</span><br><span class="line">    where <span class="keyword">string</span></span><br><span class="line">    isDone <span class="keyword">bool</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContextDoneDetector</span><span class="params">(ctx context.Context)</span> *<span class="title">Detector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Detector&#123;ctx: ctx&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Detector)</span> <span class="title">Detect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> d.isDone &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-d.ctx.Done():</span><br><span class="line">        d.isDone = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> where <span class="keyword">string</span></span><br><span class="line">        _, file, line, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            where = fmt.Sprintf(<span class="string">"%s:%d"</span>, file, line)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            where = <span class="string">"unknown"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.WithContext(d.ctx).Errorf(<span class="string">"detect context done signal in \"%s\". context is %s"</span>, where, d.ctx)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后对原有的业务代码进行一些改造如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create 创建用户学习进度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(learnProgressDB *LearnProgressDAO)</span> <span class="title">Create</span><span class="params">(ctx context.Context, memberID <span class="keyword">int64</span>, unitID <span class="keyword">int64</span>, bizType <span class="keyword">int16</span>, progress <span class="keyword">int32</span>, clientUpdatedAt <span class="keyword">int64</span>)</span> *<span class="title">LearnProgress</span></span> &#123; </span><br><span class="line">    d := utils.NewContextDoneDetector(ctx)</span><br><span class="line">    d.Detect()</span><br><span class="line">    <span class="comment">// ...此处省略 N 行</span></span><br><span class="line">    d.Detect()</span><br><span class="line">    <span class="comment">// 替换成不带 Cancel 的 Context</span></span><br><span class="line">    ctxWithoutCancel := utils.WithoutCancel(ctx)</span><br><span class="line">    result, err := db.Exec(ctxWithoutCancel, i, args...)</span><br><span class="line">    <span class="comment">// ...继续省略</span></span><br><span class="line">    d.Detect()</span><br><span class="line">    object :=  db.QueryRow(ctxWithoutCancel, <span class="string">"SELECT id, member_id, unit_id, biz_type, progress, "</span>+</span><br><span class="line">        <span class="string">"client_updated_at FROM learn_progress WHERE id = ?"</span>, id)</span><br><span class="line">    learnProgress := &amp;LearnProgress&#123;&#125;</span><br><span class="line">    d.Detect()</span><br><span class="line">    err = object.Scan(&amp;learnProgress.ID, &amp;learnProgress.MemberID, &amp;learnProgress.UnitID, &amp;learnProgress.BizType,</span><br><span class="line">        &amp;learnProgress.Progress, &amp;learnProgress.ClientUpdatedAt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.WithContext(ctx).WithError(err).Errorf(<span class="string">"create and get progress %d error"</span>, id)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    d.Detect()</span><br><span class="line">    <span class="keyword">return</span> learnProgress</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上线后，因为 context canceled 而导致请求处理流程不能走完的问题解决了。同时也报告出很多检查到上层 Context 取消的信号，详细的日志如下：<br><img src="./context-log.png" alt="context log"></p><h2 id="分析-HTTP-Server-源码"><a href="#分析-HTTP-Server-源码" class="headerlink" title="分析 HTTP Server 源码"></a>分析 HTTP Server 源码</h2><p>显然，从日志中可以看到有两处 <code>Cancel Context</code> 有极大的嫌疑，那么剩下的问题就是要确定这两个 Cancel Context 是怎么来的？这样，接下来我们再去确认是<strong>哪个 Cancel Context 在哪</strong>优先被 cancel 从而导致子节点收到了 <code>ctx.Done()</code> 信号，不就可以解答疑惑了吗？</p><p>分析这棵 Context 树可以发现，我们优先去看 HTTP Server 处理请求部分的代码，就最容易找顺着请求处理的各个流程来定位到 Cancel Context 是在何处生成的，以及在何处会被调用的。</p><p>一般我们启动 Server 是调用了 <code>ListenAndServe</code> 接口，顺着该接口往下分析即可找到线索，详细的分析如下（和我们确定问题无关紧要的代码先忽略了）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe 用于启动服务并监听指定的端口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serve 用于接收请求连接，并为每个新的连接服务创建一个 service goroutine。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 此处省略不少</span></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    <span class="comment">// 这里创建了一个根 context</span></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    <span class="comment">// 第一个 WithValue 正是 `http.&amp;contextKey&#123;"http-server"&#125;`</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="comment">// ...此处省略很多</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="comment">// 启动新的 service goroutine 处理连接服务，上面的 ctx 被传递进去了！！</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// serve 读取请求，并调用 `srv.Handler` 来处理请求，进而执行到业务逻辑，处理完请求后</span></span><br><span class="line"><span class="comment">// 给客户端返回响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注意，这里添加了 `http.&amp;contextKey&#123;"local-addr"&#125;` 子 Context</span></span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">    <span class="comment">// ...此处省略很多</span></span><br><span class="line">    <span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line">    <span class="comment">// Bingo，这里看到了第一个 WithCancel 创建的子 Context 了</span></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    c.cancelCtx = cancelCtx</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line">    c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    <span class="comment">// 注意这里的 checkConnErrorWriter，后面分析会涉及</span></span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// readRequest 会返回一个 response，其中包括添加子 Cancel Context</span></span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="comment">// ...此处省略很多</span></span><br><span class="line">        <span class="comment">// 注意这里的 startBackgroundRead，下面分析会看到</span></span><br><span class="line">        <span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</span><br><span class="line">            registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            w.conn.r.startBackgroundRead()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 ServeHTTP，进而将请求传递到业务代码中，等待处理完毕</span></span><br><span class="line">        <span class="comment">// 在上述日志中，我们可以看到，在这个调用没有结束的时候，context</span></span><br><span class="line">        <span class="comment">// 已经 cancel 了。而这个调用中 我们确认没有异步 cancel context 的代码</span></span><br><span class="line">        <span class="comment">// 并且，`*http.response` 即 `w` 这个结构体中 `cancelCtx` 是个私有字段，不会</span></span><br><span class="line">        <span class="comment">// 被外部访问到，所以不可能在 ServeHTTP 期间调用了 `cancelCtx` 函数</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        <span class="comment">// 通过对代码的分析，只有此处调用了一次 `*http.response` 里面的 cancelCtx</span></span><br><span class="line">        <span class="comment">// 所以我们确认导致下层收到 context cancel 信号的触发点不在此处！</span></span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        w.finishRequest()</span><br><span class="line">        <span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">            <span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readRequest 从连接中读取下一个请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">readRequest</span><span class="params">(ctx context.Context)</span> <span class="params">(w *response, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...此处省略很多</span></span><br><span class="line">    <span class="comment">// 可以看到第二个 cancel context 节点诞生了</span></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    req.ctx = ctx</span><br><span class="line">    <span class="comment">// ...此处省略很多</span></span><br><span class="line">    w = &amp;response&#123;</span><br><span class="line">        conn: c,</span><br><span class="line">        cancelCtx: cancelCtx,</span><br><span class="line">        req: req,</span><br><span class="line">        reqBody: req.Body,</span><br><span class="line">        handlerHeader: <span class="built_in">make</span>(Header),</span><br><span class="line">        contentLength: <span class="number">-1</span>,</span><br><span class="line">        closeNotifyCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="comment">// We populate these ahead of time so we're not</span></span><br><span class="line">        <span class="comment">// reading from req.Header after their Handler starts</span></span><br><span class="line">        <span class="comment">// and maybe mutates it (Issue 14940)</span></span><br><span class="line">        wants10KeepAlive: req.wantsHttp10KeepAlive(),</span><br><span class="line">        wantsClose: req.wantsClose(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isH2Upgrade &#123;</span><br><span class="line">        w.closeAfterReply = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.cw.res = w</span><br><span class="line">    w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)</span><br><span class="line">    <span class="keyword">return</span> w, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据详细打印的 Context 日志，并结合 HTTP Server 处理部分的代码分析，可以简单绘制出这棵 Context 树大体如下：<br><img src="context-tree.png" alt="context tree"></p><p>在进行 Server 处理连接请求的源码中，可以发现不太可能是第二个 Cancel Context 发送的取消信号。那么，问题只能出现在一个 Cancel Context 上面了。<br>接下来，就看看 Connection 关联的 <code>cancelCtx()</code> 究竟会在哪几处调用？利用搜索可以找到如下两个嫌疑很大的地方：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleReadError 在从客户端读取失败时会被调用。这里的错误之所以</span></span><br><span class="line"><span class="comment">// 被省略，是因为错误通常就是 io.EOF 或者 "use of closed network connection"</span></span><br><span class="line"><span class="comment">// 标准库认为我们对具体报错不感兴趣，所以连 error 是什么在业务代码中是无法获取</span></span><br><span class="line"><span class="comment">// 到的。</span></span><br><span class="line"><span class="comment">// 总之，执行到此处，就意味着连接已经挂了，所以一定要通知取消 context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *connReader)</span> <span class="title">handleReadError</span><span class="params">(_ error)</span></span> &#123;</span><br><span class="line">    cr.conn.cancelCtx()</span><br><span class="line">    cr.closeNotify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w checkConnErrorWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err = w.c.rwc.Write(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; w.c.werr == <span class="literal">nil</span> &#123;</span><br><span class="line">        w.c.werr = err</span><br><span class="line">        w.c.cancelCtx()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过进一步分析，<code>checkConnErrorWriter</code> 只有在请求处理完毕，<code>w.finishRequest()</code> 时才可能会在某个时刻被调用。所以不可能是这里的 <code>cancelCtx()</code> 调用导致的，因为在报错时，显然还没有完成 <code>ServeHTTP()</code> 的流程。一通排查下来，只可能是在 <code>handleReadError()</code> 时报错了。结合网上的搜索信息，我们判断极有可能是客户端连接断开导致的大量报错，也就是说 <code>handleReadError()</code> 被调用才导致的。</p><h2 id="添加-HTTP-Middleware-监测连接断开"><a href="#添加-HTTP-Middleware-监测连接断开" class="headerlink" title="添加 HTTP Middleware 监测连接断开"></a>添加 HTTP Middleware 监测连接断开</h2><p>那么我们如何验证的确是 connection closed 导致的呢？通过上面的代码可以看到，在处理错误时调用了 <code>closeNotify()</code> 方法，该方法会将 <code>*http.response</code> 的 <code>closeNotifyCh</code> 发送一个 true 值。进一步发现，<code>*http.response</code> 实现了接口 <code>CloseNotifier</code>，所以我们可以在代码中监听这个信号来进一步验证连接是不是真的断开了。</p><p>为此，我们实现了一个简单的中间件，启动一个 goroutine 去监听关闭信号，并在收到信号时向 Sentry 中打印相关报错：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MonitorCloseNotifier</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &amp;&amp; strings.EqualFold(r.URL.Path, <span class="string">"/check_health"</span>) &#123;</span><br><span class="line">            next.ServeHTTP(w, r)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        log.Warn(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;()</span><br><span class="line">                cc := w.(http.CloseNotifier).CloseNotify()</span><br><span class="line">                value := &lt;-cc</span><br><span class="line">                ctx := context.WithValue(</span><br><span class="line">                    r.Context(),</span><br><span class="line">                    log.SentrySpecificMetaCtxKey,</span><br><span class="line">                    collectSentryMeta(r, <span class="string">"login_id"</span>),</span><br><span class="line">                )</span><br><span class="line">                log.WithContext(ctx).Errorf(</span><br><span class="line">                    <span class="string">"connection read error, maybe 'use of closed network connection' or 'io.EOF'. return value: %v"</span>, value)</span><br><span class="line">            &#125;()</span><br><span class="line">            next.ServeHTTP(w, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在完成代码变更，并进行金丝雀小流量验证时，在 Sentry 上看到了相关的报错。由此确认是在何处因为什么导致了 Context Cancel。<br><img src="./conn-close-error.png" alt="connection error"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>历经多次代码变更和日志分析才最终确定<strong>在何处因为什么</strong>导致了 Context Cancel，整个过程非常坎坷。那为什么没有直接进行调试呢？那样定位问题不是更快速些吗？原因是这样，最开始我们并不知道什么原因导致的；这样也就没法在本地复现问题，由于这些问题是在线上产生的，也不大可能直接在线上拦截用户请求并调试，那样可能更加繁琐、耗时，且实施成本更大（因为我们也不知道哪个用户使用什么设备在什么时候会发生问题）。</p><p>所以采取分析错误日志加验证的方式来确定问题所在。当然，之所以这么麻烦也是因为 Context Cancel 时提供的 Error 太单一了。如果最初 API 设计时就能提供自定义的错误，那么我们可以根据具体错误来定位到可能产生报错的位置，这样会更加快捷！</p><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p><code>context</code> 包最初是由 Google 官方开发，并在 Go 1.7 版本正式引入到标准库中的。引入该包的目的是为了提供统一的姿势<strong>处理超时、取消信号传递和在 API 之间传递请求上下文数据</strong>。它提供了几个重要的接口用于创建 Context 树🌲：</p><ul><li><code>WithCancel</code></li><li><code>WithDeadline</code></li><li><code>WithTimeout</code></li><li><code>WithValue</code></li></ul><p>这些接口会接收一个 parent context，并返回一个 derived context。在我们的代码中，应该层层传递该 context，一般约定函数的第一个参数就是 context，签名类似：<code>func foo(ctx context.Context)</code>。</p><p>对于 <code>WithCancel</code>, <code>WithDeadline</code>, <code>WithTimeout</code> 而言，它们都会返回 <code>cancelFunc</code> 供使用者调用。当 <code>cancelFunc</code> 被调用时，除了自身会被取消外，其子 context 都会被取消。示例图如下：<br><img src="./context-cancel.png" alt="context cancel"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Context-Interface"><a href="#Context-Interface" class="headerlink" title="Context Interface"></a>Context Interface</h3><p><code>Context</code> 本身是一个接口，其定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Deadline 会返回什么时间 context 会被取消。如果没有设置</span></span><br><span class="line">    <span class="comment">// 过期时间，则 ok 返回 false。</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done 在 context 被取消时对应的 channel 会被关闭，从而达到</span></span><br><span class="line">    <span class="comment">// 通知正在监听的 goroutine 终止手头工作的目的。对于不可取消的</span></span><br><span class="line">    <span class="comment">// context，则返回 nil。</span></span><br><span class="line">    <span class="comment">// 对于 WithCancel, WithDeadline, WithTimeout 而言，最终都会</span></span><br><span class="line">    <span class="comment">// 关闭 done channel。</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err 会在 Done 被关闭时，返回错误（这里的错误在 context 包内仅限 Canceled 和超时 DeadlineExceeded）</span></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value 用于返回存储在 Context 中指定 key 对应的上下文数据。如果找不到就返回空。</span></span><br><span class="line">    <span class="comment">// 这里如果在当前 context 找不到，就会一直往上找 parent 直到根节点。</span></span><br><span class="line">    <span class="comment">// 仅限于使用 Context 存储一些请求相关（request-scoped）数据，并在应用中传递，</span></span><br><span class="line">    <span class="comment">// 对于一些额外的参数，传递绝对不推荐使用它！</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TODO-amp-Background"><a href="#TODO-amp-Background" class="headerlink" title="TODO &amp; Background"></a>TODO &amp; Background</h3><p>在 <code>context</code> 包中定义了两种 <code>emptyCtx</code>，分别是 <code>todo</code> 和 <code>background</code>。相关实现非常简单：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// emptyCtx 是不会被取消，无任何值和 deadline 的。之所以没有使用空结构体（struct&#123;&#125;）</span></span><br><span class="line"><span class="comment">// 是因为要保证该类型的每个值都要有不同的地址</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background 通常在 main 函数、测试中初始化，或者请求对应的顶层 Context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123; <span class="keyword">return</span> background &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 通常在不知道该用什么 Context 的时候，可以使用它</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123; <span class="keyword">return</span> todo &#125;</span><br></pre></td></tr></table></figure></p><h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><p>我们通常使用 <code>WithCancel()</code> 接口来创建一个可被取消的 Context，该接口会返回一个新的子 Context 节点和用于取消时调用的函数 <code>cancelFunc</code>。相关源码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CancelFunc 通知取消任务，不会等待任务执行完毕；只能被有效调用一次</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">WithCancel</span> 会返回一个 <span class="title">parent</span> 的拷贝，同时带有 <span class="title">Done</span> <span class="title">channel</span>。</span></span><br><span class="line"><span class="function">// 取消该 <span class="title">context</span> 时会释放关联的资源，所以当该 <span class="title">Context</span> 完成时需要尽快调用 <span class="title">cancel</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx 会返回一个初始化好的 cancelCtx 实例</span></span><br><span class="line"><span class="comment">// 关于什么是 cancelCtx 会在下面分析它的源码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// propagateCancel 本质上是为了将子 canceler 挂载到父 canceler 节点上</span></span><br><span class="line"><span class="comment">// 这样在父节点收到取消通知时，才能一一通知到子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// parent 不支持取消的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里只是判断是不是有 context 包中定义的</span></span><br><span class="line">    <span class="comment">// cancelCtx 结构而已</span></span><br><span class="line">    <span class="comment">// parentCancelCtx(parent) 确认 parent 是否为</span></span><br><span class="line">    <span class="comment">// cancelCtx 或者 timerCtx 类型</span></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            <span class="comment">// parent 如果被取消，自然不需要 removeChild，因为</span></span><br><span class="line">            <span class="comment">// parent 对应的子树会被 detatch 掉，确保释放资源</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延迟初始化了 children</span></span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 为什么是放在字典，而非列表呢？</span></span><br><span class="line">                <span class="comment">// 原因很简单，是为了方便删除 child</span></span><br><span class="line">                <span class="comment">// delete(p.children, child)</span></span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把子节点挂载到 cancel context 的父节点上</span></span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                <span class="comment">// 对于父节点返回 Done channel 的进行监听</span></span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">                <span class="comment">// 等待 cancel ctx 被结束</span></span><br><span class="line">                <span class="comment">// 这里只可能是 timerCtx, cancelCtx</span></span><br><span class="line">                <span class="comment">// goroutine 退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于可被取消的 Context 都实现了下面的接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// canceler 就是实现了 cancel 的 context 类型。在标准库中</span></span><br><span class="line"><span class="comment">// 仅有 `cancelCtx` 和 `timerCtx` 实现了该接口</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在分析 WithCancel 的源码时，可以发现，我们创建了一个 <code>cancelCtx</code> 实例，并将原有的 Context 作为父节点记录了下来。那么 <code>cancelCtx</code> 是怎么实现的呢？又是如何处理取消逻辑的呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Context 会指向 parent</span></span><br><span class="line">    Context</span><br><span class="line">    <span class="comment">// mu 用来保证 goroutine 安全</span></span><br><span class="line">    mu sync.Mutex <span class="comment">// protects following fields</span></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">     <span class="comment">// 之所以使用字典来存储，是因为不关心子节点顺序，同时为了方便删除</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err error <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Done 会返回一个延迟初始化的 chan 供下游监听完成信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 延迟初始化</span></span><br><span class="line">        c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    d := c.done</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel 负责关闭 c.done chan，同时取消每个子节点</span></span><br><span class="line"><span class="comment">// 并根据需要将对应的节点从它的父节点的 children 中移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 确保下次调用时已经关闭了</span></span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">        <span class="comment">// 依次 cancel 所有的子节点</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="WithDeadline-amp-WithTimeout"><a href="#WithDeadline-amp-WithTimeout" class="headerlink" title="WithDeadline &amp; WithTimeout"></a>WithDeadline &amp; WithTimeout</h3><p>如果我们需要对 goroutine 设置超时或者到达指定时间后退出的话，就可以使用 <code>WithDeadline()</code> 或 <code>WithTimeout()</code> 来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithDeadline 会创建一个带有到期时间控制的 context，在时间到达后会自动</span></span><br><span class="line"><span class="comment">// 关闭 done channel，同时下游的节点也会收到取消通知。需要注意的是，对于</span></span><br><span class="line"><span class="comment">// 这种类型的 cancel，对应的 Error 是 DeadlineExceeded</span></span><br><span class="line"><span class="comment">// 另外，返回的 cancelFunc 一定要被调用一次，确保资源最终能被释放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果父节点提前结束，则不用再为子节点添加额外的计时资源了</span></span><br><span class="line">    <span class="comment">// 因为当父节点结束时，子节点也会被通知到</span></span><br><span class="line">    <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        <span class="comment">// 这里，如果说已经到期了，自然没必要引入一个计时器资源</span></span><br><span class="line">        <span class="comment">// 所以直接返回一个 Cancel Context 了</span></span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        cancelCtx: newCancelCtx(parent),</span><br><span class="line">        deadline: d,</span><br><span class="line">    &#125;</span><br><span class="line">    propagateCancel(parent, c)</span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果指定的时间点已经过了的话，则直接取消</span></span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 当时间到了后，会执行 cancel 方法</span></span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithTimeout 指定超时时间的 Context，其实就是复用了 WithDeadline 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timerCtx</code> 是实现带定时功能的 Context 类型，它的实现比较简单：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// timer 资源的访问是由 cancelCtx 中的 Lock 来保障的</span></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> c.deadline, <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel 主要在 timerCtx 取消时，释放掉 timer 资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将当前节点的 done channel close 掉，同时取消相关子节点</span></span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 释放 timer 资源</span></span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><p>通常使用 <code>WithValue()</code> 方法给 Context 附加一些请求相关的上下文数据，它的实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证 Key 本身是可比较的即可</span></span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往 parent 去找，一直找到为止</span></span><br><span class="line">    <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="传递请求相关的数据"><a href="#传递请求相关的数据" class="headerlink" title="传递请求相关的数据"></a>传递请求相关的数据</h3><p>使用 WithValue 将需要的请求数据存储在 Context 中，方便向下传递。我们一般要尽量避免在业务代码中直接解析 Context 中的某些 Key。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> contextKey <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 不要使用 string key，避免冲突</span></span><br><span class="line">    traceIDCtxKey = &amp;contextKey&#123;name: <span class="string">"request-trace-id"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议使用函数封装下，对外提供统一的接口方便使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTraceID</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.WithValue(ctx, traceIDCtxKey, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraceIDFrom</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> traceID, ok := ctx.Value(traceIDCtxKey).(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> traceID</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exampleWithValue</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    doStuff := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        traceID := TraceIDFrom(ctx)</span><br><span class="line">        fmt.Printf(<span class="string">"got request trace id: %s\n"</span>, traceID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟传递请求 trace id，这些可以被日志框架等提取并存储到日志中</span></span><br><span class="line">    id, _ := uuid.GenerateUUID()</span><br><span class="line">    ctx = WithTraceID(ctx, id)</span><br><span class="line">    doStuff(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exampleWithTimeout 模拟一组请求，并且假设每个请求处理时间为 0~3 秒的随机时间</span></span><br><span class="line"><span class="comment">// 同时我们将超时时间设置为 1 秒，这样在请求期间就会有些因为超时而主动结束后续执行流程</span></span><br><span class="line"><span class="comment">// 的 goroutine 收到取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exampleWithTimeout</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    doRequest := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟请求</span></span><br><span class="line">        time.Sleep(time.Duration(rand.Int63n(<span class="number">3</span>)) * time.Second)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Printf(<span class="string">"[%d]request canceled\n"</span>, id)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 处理其它业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, time.Second*<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            doRequest(ctx, id+<span class="number">1</span>)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>不建议将 Context 存放在结构体中，而应该作为参数显式传递；一般接收 Context 作为参数的函数，应该将该参数放在第一个参数位置（这个是惯例了）；</li><li>在给函数传递 Context 时，如果不知道用什么 Context，就可以使用 <code>Context.TODO()</code>，避免传递 nil</li><li>Context Value 需要有约束，必须应该符合<strong>请求相关</strong>的上下文数据，并且一般是在框架或者 HTTP 中间件中设置 Value，业务代码中尽可能避免直接操作 Context Value。在我们的业务代码中应当显式传参，这样可以利用静态语言的特性，使得一些问题可以在编译阶段就能发现；不要为了图方便，用 Context 带一些可选参数。</li><li>在使用 <code>WithValue(key, value)</code> 时，Key 应该避免使用字符串，防止名字冲突和污染；</li><li>在使用 <code>WithCancel</code>, <code>WithTimeout</code>, <code>WithDeadline</code> 时，一定要保证返回的 cancel 方法至少被调用一次，避免 goroutine 泄露或者其它资源泄露；</li><li>由于目前在标准库以及一些第三方库中都在使用 Context，一路传递下来，整体链路很长。而当发生 Context Cancel 时，排查起来就非常麻烦。所以需要对所使用各类框架或者库在整个执行过程的生命周期需要有一定的了解，再配合日志等手段进行排查起来会更加有效。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">Go语言实战笔记（二十）| Go Context</a></li><li><a href="https://blog.golang.org/context" target="_blank" rel="noopener">Go Concurrency Patterns: Context</a></li><li><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39" target="_blank" rel="noopener">How to correctly use context.Context in Go 1.7</a></li><li><a href="https://medium.com/@cep21/go-1-7-httptrace-and-context-debug-patterns-608ae887224a" target="_blank" rel="noopener">Go 1.7 httptrace and context debug patterns</a></li><li><a href="https://medium.com/@blanchon.vincent/go-context-and-cancellation-by-propagation-7a808bbc889c" target="_blank" rel="noopener">Go: Context and Cancellation by Propagation</a></li><li><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39" target="_blank" rel="noopener">How to correctly use context.Context in Go 1.7</a></li><li><a href="https://liudanking.com/sitelog/understanding-golang-http-timeout/" target="_blank" rel="noopener">深入理解 Golang HTTP Timeout</a></li><li><a href="https://www.calhoun.io/pitfalls-of-context-values-and-how-to-avoid-or-mitigate-them/" target="_blank" rel="noopener">Pitfalls of context values and how to avoid or mitigate them in Go</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在一次排查某 HTTP 接口请求频繁因 context canceled 错误导致请求处理失败的问题期间，深入了解了下 Go 语言的 Context 实现。本文将首先介绍我们是如何排查诡异的 &lt;code&gt;context canceled&lt;/code&gt; 产生原因（也就是在哪儿因为什么而导致取消的）；接下来将深入介绍 Context 诞生的目的、源码解析及应用场景等，便于更进一步加深对它的理解；最后我们也会谈及使用 Context 的一些痛点。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://ifaceless.space/categories/Go/"/>
    
    
      <category term="Go" scheme="http://ifaceless.space/tags/Go/"/>
    
      <category term="标准库" scheme="http://ifaceless.space/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
      <category term="源码解读" scheme="http://ifaceless.space/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Context" scheme="http://ifaceless.space/tags/Context/"/>
    
  </entry>
  
  <entry>
    <title>CSS 学习笔记</title>
    <link href="http://ifaceless.space/2019/07/16/css-learning-notes/"/>
    <id>http://ifaceless.space/2019/07/16/css-learning-notes/</id>
    <published>2019-07-16T14:35:57.000Z</published>
    <updated>2019-11-24T09:45:59.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从 0 到 1 实现一个网站，前端部分自然是要了解 CSS 的。CSS 的全称是 Cascading Style Sheets，它是一种专门用于给结构化文档（如 Web HTML）添加样式的语言。我们可以通过使用 CSS 来为网页布局，设定字体的样式，设定动画等，让我们的网站更加炫酷，更加现代化。而这些通过传统的编程语言来实现会非常繁琐，使用 CSS 只需要按需定义即可，极大地提高了开发效率。本篇笔记主要是记录核心的 CSS 技巧，相关的练习位于 GitHub <a href="https://www.github.com/ifaceless/learning-css" target="_blank" rel="noopener">learning-css 仓库</a>。</p><a id="more"></a><h1 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h1><ul><li><p>多重样式优先级顺序（依次增加）：</p><ol><li>通用选择器（<code>*</code>）</li><li>元素（类型）选择器</li><li>类选择器</li><li>属性选择器</li><li>伪类</li><li>ID 选择器</li><li>内联样式</li></ol></li><li><p><code>!important</code> 规则在被应用样式声明中时，该样式声明会覆盖 CSS 中任何其他的声明，使用它并非好习惯：</p><ol><li><strong>Always</strong>：要优化考虑使用样式规则的优先级来解决问题，而非 <code>!important</code></li><li><strong>Only</strong>：只有在需要覆盖全站或外部 CSS 的特定页面中使用它</li><li><strong>Never</strong>：永远不要在全站范围使用它</li><li><strong>Never</strong>：永远不要在你的插件中使用它</li></ol></li><li><p>CSS 链接样式：</p><ol><li>四种特殊状态可以分别设置：<ol><li><code>a:link</code>: 正常，未访问过的链接</li><li><code>a:visited</code>: 已访问过的链接</li><li><code>a:hover</code>: 鼠标放在链接上时</li><li><code>a:active</code>: 链接被点击的那刻</li></ol></li><li>上述顺序很重要，简记：<code>L(ink)OV(isited)E and H(over)A(ctive)TE</code></li></ol></li><li><p>所有的 HTML 元素都可以看做是一个 Box。CSS 盒模型本质上就是封装了 HTML 元素的盒子。图示如下：<img src="./box.png" alt=""></p></li><li><p>当指定 CSS 元素的高度和宽度时，只是在设置<strong>内容区域</strong>的高度和高度。实际元素尺寸计算：</p><ol><li>总宽度 = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距</li><li>总高度 = 内容高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距</li></ol></li><li><p>盒样式应用（适用于 margin, padding 等简写样式的情况）：</p><ul><li>四个值：a, b, c, d -&gt; 上，下，左，右（逆时针方向）</li><li>三个值：a, b, c -&gt; 上，左右，下</li><li>两个值：a, b -&gt; 上下，左右</li><li>一个值：a -&gt; 上下左右</li></ul></li><li><p>outline 是在 border 外部的，在元素周围绘制出元素的边缘，起到突出元素的作用。使用方式类似 <code>border</code>，可设定的属性包括：<code>outline-style</code>, <code>outline-color</code>, <code>outline-width</code> 等。需要注意的是，<code>outline</code> 是不占空间的，不会增加额外的宽度和高度。<code>outline</code> 也可能是非矩形的，和浏览器实现有关。</p></li><li><p>margin &amp; padding：<img src="./margin-padding.png" alt=""></p></li><li><p>隐藏元素：</p><ul><li><code>display:none</code>：不会占据空间，会从布局中移除</li><li><code>visibility:hidden</code>：会占据空间，影响布局</li></ul></li><li><p><strong>块（ block）元素</strong>：</p><ul><li>占据全部宽度，并且会产生换行</li><li>width, height, padding, margin 都是可控制的</li><li>块元素：<code>&lt;address/&gt;</code>, <code>&lt;blockquote/&gt;</code>, <code>&lt;center/&gt;</code>, <code>&lt;dir/&gt;</code>, <code>&lt;div/&gt;</code>, <code>&lt;dl/&gt;</code>, <code>&lt;fieldset/&gt;</code>, <code>&lt;form/&gt;</code>, <code>&lt;h1/&gt;</code>, <code>&lt;h2/&gt;</code>, <code>&lt;h3/&gt;</code>, <code>&lt;h4/&gt;</code>, <code>&lt;h5/&gt;</code>, <code>&lt;h6/&gt;</code>, <code>&lt;hr/&gt;</code>, <code>&lt;isindex/&gt;</code>, <code>&lt;menu/&gt;</code>, <code>&lt;noframes/&gt;</code>, <code>&lt;noscript&gt;</code>, <code>&lt;ol/&gt;</code>, <code>&lt;p/&gt;</code>, <code>&lt;pre/&gt;</code>, <code>&lt;table/&gt;</code>, <code>&lt;ul/&gt;</code>, <code>&lt;li/&gt;</code></li></ul></li><li><p><strong>内联（inline）元素</strong>：</p><ul><li>只占据必要的宽度，不会换行</li><li>width, height, padding-top, padding-bottom, margin-top, margin-bottom 都不可改变</li><li>内联元素：<code>&lt;a/&gt;</code>, <code>&lt;abbr/&gt;</code>, <code>&lt;acronym/&gt;</code>, <code>&lt;b/&gt;</code>, <code>&lt;bdo/&gt;</code>, <code>&lt;big/&gt;</code>,  <code>&lt;br /&gt;</code>, <code>&lt;cite/&gt;</code>, <code>&lt;code/&gt;</code>, <code>&lt;dfn/&gt;</code>, <code>&lt;em/&gt;</code>, <code>&lt;font/&gt;</code>, <code>&lt;i/&gt;</code>, <code>&lt;img/&gt;</code>, <code>&lt;input/&gt;</code>, <code>&lt;kbd/&gt;</code>, <code>&lt;label/&gt;</code>, <code>&lt;q/&gt;</code>, <code>&lt;s/&gt;</code>, <code>&lt;samp/&gt;</code>, <code>&lt;select/&gt;</code>, <code>&lt;small/&gt;</code>, <code>&lt;span/&gt;</code>, <code>&lt;strike/&gt;</code>, <code>&lt;strong/&gt;</code>, <code>&lt;sub/&gt;</code>, <code>&lt;sup/&gt;</code>, <code>&lt;textarea/&gt;</code>, <code>&lt;tt/&gt;</code>, <code>&lt;u/&gt;</code>, <code>&lt;var/&gt;</code></li></ul></li><li><p>主要使用的三种样式：</p><ul><li><code>display:block</code>：显式为块元素</li><li><code>display:inline</code>：显示为内联元素</li><li><code>display:inline-block</code>：显示为内联块元素，表现为同行显示，同时可以修改 width/height/padding/margin 等，效果如下：<br>  <img src="./list.png" alt=""></li></ul></li><li><p>CSS 定位（Position）：</p><ul><li>static：元素默认定位方式，不受 top/bottom/left/right 的影响</li><li>relative：相对正常位置的偏移；原本<strong>空间依然会被预留</strong>出来，可能会与别的元素重叠</li><li>fixed：元素的位置相对于浏览器窗口是固定的，会和其它元素重叠；元素的位置和文档流无关，<strong>不占据空间</strong></li><li>absolute：绝对定位的元素的位置是相对于最近的已定位父元素，若元素无已定位父元素，则它的位置是相对于 <html>；与文档流无关，<strong>不占据空间</strong>，会与其它元素重叠</html></li><li>sticky：粘性定位，与滚动有关，受限于浏览器</li><li>可以使用 <code>overflow</code> 指定当内容溢出时的行为（可选择是否展示滚动条），但其只可用于指定了高度的块元素上</li></ul></li><li><p>元素的浮动：</p><ul><li>会让元素向左或向右浮动，周围元素也会重新排列</li><li>元素水平浮动，意味着只能左右移动</li><li>浮动元素会尽量向左或向右移动，直到它的外边缘碰到包括框或另一个浮动框的边缘为止</li></ul></li><li><p>设置居中：</p><ul><li>元素居中：可以通过 <code>margin: auto</code> 解决，但是必须要设置元素的宽度</li><li>文本居中：可使用 <code>text-align</code></li></ul></li><li><p>组合选择器：</p><ul><li>后代选择器：<code>div p</code></li><li>子元素选择器：<code>div&gt;p</code></li><li>相邻兄弟选择器：<code>div+p</code></li><li>普通兄弟选择器：<code>div~p</code></li></ul></li><li><p>伪类（pseudo-classes）：</p><ul><li>用于添加一些选择器的特殊效果</li><li>伪类选择的元素是<strong>基于当前元素所处的状态</strong>，或者是元素所具有的特性，而非静态标志（如 class, id, 属性）。而状态是动态的，所以当一个元素到达一个特定状态的时候，可能得到一个伪类的样式；当状态改变时，它会失去这个样式。基于文档之外的抽象，故称为伪类。</li><li>语法：<ul><li><code>selector:psedudo-class { property: value }</code></li><li><code>selector.class:pseudo-class { property: value }</code></li></ul></li><li>伪类名称不区分大小写</li><li>示例：<code>a:hover { color: red }</code></li></ul></li><li><p>伪元素（pseudo-element）：</p><ul><li>用于添加一些选择器的特殊效果</li><li>语法：类似伪类</li><li>伪元素是对元素中<strong>特定内容</strong>选择并操作，操作层次要比伪类更深，动态性比伪类低。设计伪元素的目的就是选取诸如第一个字母（行）等，选取内容的前后并操作等，这些普通的选择器是无法完成的。本身是基于元素的抽象，不存在于文档中，故称为伪元素。</li></ul></li><li><p>属性选择器：</p><ul><li>语法：<code>&lt;element&gt;[attr] { }</code> 或者 <code>&lt;element&gt;[attr&lt;op&gt;value]{ }</code></li><li>选择范围：<ul><li><code>=</code>: <code>equal_word</code></li><li><code>*=</code>: 相当于 <code>contains</code>，如 <code>&lt;p title=&quot;buyfflowerrr&quot;&gt;&lt;/p&gt;</code></li><li><code>~=</code>:  相当于 <code>contains_word</code>，如 <code>&lt;p title=&quot;buy flower&quot;&gt;&lt;/p&gt;</code> 中的 flower</li><li><code>|=</code> : 相当于 <code>starts_with_word</code>，当然这里的单词应是唯一的，或者是用 <code>-</code> 分隔的</li><li><code>^=</code>: 相当于 <code>starts_with</code></li><li><code>$=</code>: 相当于 <code>ends_with</code></li></ul></li></ul></li></ul><h1 id="CSS-3-简记"><a href="#CSS-3-简记" class="headerlink" title="CSS 3 简记"></a>CSS 3 简记</h1><ul><li><p>CSS 3 被拆分成了「模块」，一些重要的模块如下：</p><ul><li>选择器</li><li>盒模型</li><li>背景和边框</li><li>文字特效</li><li>2D/3D 转换</li><li>动态</li><li>多列布局</li><li>用户界面</li></ul></li><li><p>渐变（Gradients）：</p><ul><li><strong>线性渐变</strong>（Linear Gradients）：向下/向上/向左/向右/对角线</li><li><strong>径向渐变</strong>（Radius Gradients）：由相应的中心定义</li><li>语法：<code>background: linear-gradient (direction, color-stop1, color-stop2, ...)</code></li></ul></li><li><code>box-shadow</code> 顺序：<img src="./box-shadow.png" alt=""></li><li><p>2D 转换：</p><ul><li><code>translate</code>, <code>translateX</code>, <code>translateY</code></li><li><code>rotate</code>, <code>rotateX</code>, <code>rotateY</code></li><li><code>scale</code>, <code>scaleX</code>, <code>scaleY</code></li><li><code>skew</code>, <code>skewX</code>, <code>scaleY</code></li><li><p><code>matrix</code>：</p><ul><li>接收六个参数：<code>a, b, c, d, tx, ty</code></li><li><p>对照：</p><ul><li>位移：<code>matrix(1, 0, 0, 1, tx, ty)</code> = <code>translate(tx + &quot;px&quot;, ty + &quot;px&quot;)</code></li><li>缩放：<code>matrix(sx, 0, 0, sy, 0, 0)</code> = <code>scale(sx, sy)</code></li><li>旋转：<code>matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)</code> = <code>rotate(θ + &quot;deg&quot;)</code></li><li>倾斜：<code>matrix(1, tan(θy), tan(θx), 1, 0, 0)</code> = <code>skew(θx + &quot;deg&quot;, θy + &quot;deg&quot;)</code></li></ul></li><li><p>计算方式：<img src="./matrix-calc.png" alt=""></p></li></ul></li></ul></li></ul><ul><li><p>过渡效果：<code>transition: property duration timing-function delay</code></p><ul><li>其中，默认情况下，duration 为 0，所以如果不设置该值，将看不到效果</li><li>过渡动画时间曲线：<ul><li>ease：默认值</li><li>linear</li><li>ease-in    </li><li>ease-out</li><li>ease-in-out</li><li>cubic-bezier(n, n, n, n)：贝塞尔曲线函数，可以通过指定值来实现上述效果，同时可以自定义其它值实现自定义效果</li></ul></li></ul></li><li><p>关键帧动画：</p><ul><li>使用 <code>@keyframes</code> 创建动画，可以使用 <code>n%</code> 设定处于不同阶段时的属性，而 <code>from</code> 和 <code>to</code> 分别代表 <code>0%</code> 和 <code>100%</code></li><li>使用 <code>animation</code> 属性绑定动画到选择器上，需要设定两个值：<ul><li>动画名称</li><li>动画时长</li></ul></li></ul></li><li><p>Flex 布局：</p><ul><li>当页面需要适应不同的屏幕大小及设备类型时，确保元素拥有恰当的行为布局方式</li><li>提供一种更加有效的方式对一个容器中的子元素进行排列、对齐和分配空间</li><li>组成：<ul><li>Flex container</li><li>Flex item</li></ul></li><li>属性设置：<code>display: flex/inline-flex</code></li><li>设置主轴对齐方式：<code>justify-content</code></li><li>设置侧轴对齐方式：<code>align-items</code></li><li>设置换行：<code>flex-wrap</code></li><li>设置各个行的对齐方式：<code>align-content</code></li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.runoob.com/css3" target="_blank" rel="noopener">菜鸟教程：CSS </a></li><li><a href="https://www.cnblogs.com/KeithWang/p/3139517.html" target="_blank" rel="noopener">block, inline-block 对比</a></li><li><a href="https://dev.opera.com/articles/understanding-the-css-transforms-matrix/" target="_blank" rel="noopener">Understanding the CSS Transforms Matrix</a></li><li><a href="https://www.cnblogs.com/cc156676/p/5784629.html" target="_blank" rel="noopener">CSS 2D 转换详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/67988244" target="_blank" rel="noopener">CSS 3 中 Flex 弹性布局该如何灵活运用？</a></li><li><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="noopener">30 分钟学会 Flex 布局</a></li><li><a href="https://www.zhihu.com/question/271492607/answer/364298001" target="_blank" rel="noopener">Flex 布局对性能的影响主要体现在哪方面？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;从 0 到 1 实现一个网站，前端部分自然是要了解 CSS 的。CSS 的全称是 Cascading Style Sheets，它是一种专门用于给结构化文档（如 Web HTML）添加样式的语言。我们可以通过使用 CSS 来为网页布局，设定字体的样式，设定动画等，让我们的网站更加炫酷，更加现代化。而这些通过传统的编程语言来实现会非常繁琐，使用 CSS 只需要按需定义即可，极大地提高了开发效率。本篇笔记主要是记录核心的 CSS 技巧，相关的练习位于 GitHub &lt;a href=&quot;https://www.github.com/ifaceless/learning-css&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;learning-css 仓库&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ifaceless.space/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://ifaceless.space/tags/CSS/"/>
    
      <category term="布局" scheme="http://ifaceless.space/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="样式" scheme="http://ifaceless.space/tags/%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redux 简记</title>
    <link href="http://ifaceless.space/2019/07/03/react-redux-notes/"/>
    <id>http://ifaceless.space/2019/07/03/react-redux-notes/</id>
    <published>2019-07-03T15:03:18.000Z</published>
    <updated>2019-11-24T09:45:59.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>根据官网介绍，Redux 是一个 JavaScript 状态管理容器，提供了可预测的状态管理能力。可以构建一致的应用，运行于多种环境下（客户端、服务器和原生应用等），且易于测试（甚至都不要在写界面之前进行测试）。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>Redux 的核心就是管理状态，所有的状态是在 store 对象树中维护。使用 action 来描述 state 变化，而为了能够将 action 和 state 串联在一块，就有了 reducer 函数，它负责根据不同的 action dispatch 到不同的分支，然后返回新的状态。需要注意的是，reducer 是纯函数，不应该 inplace 那种方式修改 state，而是生成新的 nextState 并返回。<br>通常一个应用中可能有多个小的 reducers ，我们可以使用 <code>combineReducers</code> 将它们组合在一起。</p><h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ul><li><strong>单一数据源</strong>：整个应用的 state 是存储在一个 obj tree 中的，并且该 obj tree 只存在于唯一一个 store 中</li><li><strong>state 是只读的</strong>：唯有触发 action 才会改变 state，使用 action 来描述发生了什么</li><li><strong>使用纯函数执行修改</strong>：需要编写 reducer 实现状态改变</li></ul><h1 id="三驾马车"><a href="#三驾马车" class="headerlink" title="三驾马车"></a>三驾马车</h1><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul><li>Action 是把数据从应用传递到 store 的有效载荷，是 store 数据的唯一来源</li><li>一般通过 <code>store.dispatch()</code> 分发 action，传递到 store</li><li>当应用规模变大时，建议将 Action 使用单独的模块存放</li><li>尽量减少在 action 中传递的数据</li><li><strong>Action 创建函数</strong>：返回 action 的函数，使用 <code>bindActionCreators()</code> 可以自动将多个 action 创建函数绑定到 <code>dispatch()</code> 方法上</li><li>Action 只是描述了<em>有事情发生了</em>这样的事实，但不会描述应用如何更新 state</li></ul><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><ul><li>在 reducer 中响应 action，并产生新的 state，达到改变 state 的目的</li><li><p>为什么叫 <strong>reducer</strong>？参考 <code>Array.prototype.reduce(reducer, ?initialValue)</code> 里面的回调函数，它们比较类似，都必须是纯函数。reducer 函数不欢迎如下操作：</p><ul><li><strong>修改传入参数</strong></li><li><strong>执行含有副作用的操作</strong>，如 API 请求和路由跳转</li><li><strong>调用非纯函数</strong>，如 <code>Date.now()</code> 或 <code>Math.random()</code></li></ul></li><li><p>可以把所有顶级 reducer 放在独立的文件中，通过 <code>export</code> 暴露每个 reducer 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(recuders)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><ul><li><p>Store 的职责如下：</p><ul><li>维持应用的 state</li><li>提供 <code>getState()</code> 读取状态</li><li>提供 <code>dispatch(action)</code> 方法更新状态<br>-提供  <code>subscribe(listener)</code> 方法注册监视器，其返回的函数用于注销监视器</li></ul></li><li><p>Redux 应用的 store 只会有一个，一般会根据业务逻辑来拆分子状态分组，可以通过 <code>reducers</code> 组合完成</p></li><li><code>createStore(reducer, ?initialState)</code>  创建应用 store</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Add todo: '</span> + action)</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                ...state,</span><br><span class="line">                todo(<span class="literal">undefined</span>, action)</span><br><span class="line">            ]</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'REMOVE_TODO'</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Remove todo: '</span> + action)</span><br><span class="line">            <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item</span>) =&gt;</span> todo(item, action))</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Toggle todo: '</span> + action)</span><br><span class="line">            <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item</span>) =&gt;</span> todo(item, action))</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todo</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                id: action.id,</span><br><span class="line">                text: action.text,</span><br><span class="line">                completed: action.completed,</span><br><span class="line">                isDeleted: <span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'REMOVE_TODO'</span>:</span><br><span class="line">            <span class="keyword">if</span> (state.id !== action.id) &#123;</span><br><span class="line">                <span class="keyword">return</span> state</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                isDeleted: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">            <span class="keyword">if</span> (state.id !== action.id) &#123;</span><br><span class="line">                <span class="keyword">return</span> state</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                completed: !state.completed</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">    todos</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(todoApp)</span><br><span class="line"><span class="keyword">let</span> nextTodoId = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoItem</span>(<span class="params">&#123; todo &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;label</span><br><span class="line">                style=&#123;&#123; <span class="attr">textDecoration</span>: todo.completed ? <span class="string">'line-through'</span> : <span class="string">'none'</span> &#125;&#125;</span><br><span class="line">                onClick=&#123;() =&gt; store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'TOGGLE_TODO'</span>, <span class="attr">id</span>: todo.id &#125;)&#125;</span><br><span class="line">            &gt;</span><br><span class="line">                &#123;todo.text&#125;</span><br><span class="line">            &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button</span></span><br><span class="line"><span class="regexp">                style=&#123;&#123; marginLeft: 10 &#125;&#125;</span></span><br><span class="line"><span class="regexp">                onClick=&#123;() =&gt; &#123; store.dispatch(&#123; type: 'REMOVE_TODO', id: todo.id &#125;) &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;移除&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function TodoApp(&#123; todos = [] &#125;) &#123;</span></span><br><span class="line"><span class="regexp">    const todoItems = todos</span></span><br><span class="line"><span class="regexp">        .filter((todo) =&gt; !todo.isDeleted)</span></span><br><span class="line"><span class="regexp">        .map((todo) =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /</span>&gt;)</span><br><span class="line">    <span class="keyword">const</span> input = useRef()</span><br><span class="line">    <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> text = input.current.value</span><br><span class="line">        <span class="keyword">if</span> (!text) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>, <span class="attr">id</span>: nextTodoId++, <span class="attr">text</span>: input.current.value &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input ref=&#123;input&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleClick&#125; style=&#123;&#123; <span class="attr">marginLeft</span>: <span class="number">10</span> &#125;&#125;&gt;添加&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                &#123;todoItems&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const state = store.getState()</span></span><br><span class="line"><span class="regexp">    ReactDOM.render(</span></span><br><span class="line"><span class="regexp">        &lt;TodoApp</span></span><br><span class="line"><span class="regexp">            todos=&#123;state.todos&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">    render()</span><br><span class="line">&#125;)</span><br><span class="line">render()</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>按照 Redux 提供的几个官方示例，可以看出编写一个简单的 Todo 应用其实要考虑的还是挺多的，尤其是需要在分散的模块中分别定义 actions, reducers, containers, dumb components 等，然后搭配 react-redux 来实现整体功能。<br>以下是一个经典的  React Redux 应用的示例的文件结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">    actions/</span><br><span class="line">    components/</span><br><span class="line">    consts/</span><br><span class="line">    containers/</span><br><span class="line">    reducers/</span><br><span class="line">    sotore.js</span><br><span class="line">    index.js</span><br></pre></td></tr></table></figure><p>看起来，分层结构很明晰。但这里有几个很大的问题：</p><ol><li>components 和 containers 可能会出现相互引用的问题；</li><li>对于某些情形，严格区分 smart components 和 dumb components 比较死板；</li><li>编写起来很复杂、啰嗦、冗余。</li></ol><p>针对这个痛点，可以借助 <a href="https://github.com/rematch/rematch" target="_blank" rel="noopener">rematch</a> 框架解决。它本质上是一个基于 Redux 封装的框架，目的是提供最佳的 Redux 实践，减少大量的样板代码编写，解放生产力！</p><p>使用 Rematch 时，有个非常重要的概念叫做 <code>model</code>。你可以在 <code>models</code> 里面将<strong>状态</strong>、引起状态变化<strong>reducers</strong> 及异步 actions 和 action creators 收敛到一起，方便维护和测试。总的来说，<code>model</code> 定义包含如下几个部分：</p><ul><li><strong>state</strong>: 初始状态是什么</li><li><strong>reducers</strong>: 如何改变状态</li><li><strong>effects</strong>: 处理异步的 actions，带有副作用的操作</li></ul><p>一个典型的 model 定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> count = &#123;</span><br><span class="line">  state: <span class="number">0</span>, <span class="comment">// initial state</span></span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="comment">// 使用同步函数，处理状态变更</span></span><br><span class="line">    increment(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> state + payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// 使用纯函数处理状态变更（异步 actions）</span></span><br><span class="line">    <span class="keyword">async</span> incrementAsync(payload, rootState) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">1000</span>))</span><br><span class="line">      dispatch.count.increment(payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 models 后，就可以创建 Redux store，并使用 <code>dispatch</code> 来触发 reducers 和 effects 调用（无需手动编写 action creators 啦~）。当然，在展示层，我们依然可以结合 react-redux 来使用。具体可以参考官方示例，更详细的文档可以参考 <a href="https://github.com/rematch/rematch/tree/master/docs" target="_blank" rel="noopener">这里</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://redux.js.org/" target="_blank" rel="noopener">Redux 官网文档</a></li><li><a href="https://cn.redux.js.org/" target="_blank" rel="noopener">Redux 中文译文</a></li><li><a href="https://egghead.io/lessons/react-redux-the-single-immutable-state-tree" target="_blank" rel="noopener">Redux 入门视频教程</a></li><li><a href="https://egghead.io/series/building-react-applications-with-idiomatic-redux" target="_blank" rel="noopener">以地道的方式使用 Redux 构建 React 应用</a></li><li><a href="https://www.fullstackreact.com/articles/redux-with-mark-erikson/" target="_blank" rel="noopener">Redux and Why it’s Good For You</a></li><li><a href="https://daveceddia.com/what-does-redux-do/" target="_blank" rel="noopener">What Does Redux Do</a></li><li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a>，<em>作者其实已经不推荐这种写法了</em></li><li><a href="https://react-redux.js.org/introduction/quick-start" target="_blank" rel="noopener">React Redux 官方文档</a></li></ul><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul><li><a href="https://css-tricks.com/react-router-4/" target="_blank" rel="noopener">All About React Router 4</a></li><li><a href="https://css-tricks.com/learning-react-redux/" target="_blank" rel="noopener">Learning React Redux</a></li><li><a href="https://css-tricks.com/learning-react-container-components/" target="_blank" rel="noopener">Leveling Up With React: Container Components</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;根据官网介绍，Redux 是一个 JavaScript 状态管理容器，提供了可预测的状态管理能力。可以构建一致的应用，运行于多种环境下（客户端、服务器和原生应用等），且易于测试（甚至都不要在写界面之前进行测试）。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ifaceless.space/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://ifaceless.space/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://ifaceless.space/tags/JavaScript/"/>
    
      <category term="Redux" scheme="http://ifaceless.space/tags/Redux/"/>
    
      <category term="React" scheme="http://ifaceless.space/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 核心概念</title>
    <link href="http://ifaceless.space/2019/07/02/react-core-concepts/"/>
    <id>http://ifaceless.space/2019/07/02/react-core-concepts/</id>
    <published>2019-07-02T11:44:22.000Z</published>
    <updated>2019-11-24T09:45:59.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>React 是一个用于构建 UI 的 JavaScript 库，它有<strong>声明式</strong>、<strong>组件化</strong>的特点。使用 JSX 的语法可以非常轻松地编写各种组件，而基于各种组件又可以构造出更加复杂的前端页面。</p><a id="more"></a><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><ul><li>JSX 可以很好地描述 UI：<code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;</code></li><li>React 中认为渲染逻辑本质上和 UI 逻辑天然耦合，并没有认为地将<strong>标记与逻辑</strong>分类到不同文件，而是将它们放在<strong>组件</strong>这种松散耦合单元中，实现<strong>关注点分离</strong></li><li>JSX 本身也是表达式，可以在 <code>{}</code> 中使用任意 JavaScript 的功能。在进行编译后，JSX 会被转换成普通的 JavaScript 函数调用，并对其取值后得到 JavaScript 对象</li><li>JSX 可以防止注入攻击，ReactDOM 在渲染所有输入内容前，默认会进行转义</li></ul><h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><ul><li>与真实的浏览器 DOM 元素相比，React 元素是非常轻量级且创建开销很小的普通对象，ReactDOM 负责更新 DOM 保持与 React 元素一致</li><li>渲染元素：<code>ReactDOM.render(element, container)</code></li><li>ReactDOM 会将元素及其子元素与之前的状态对比，只进行必要的更新保证 DOM 达到预期状态</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li><p>组件的定义有两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    reuturn &lt;h1&gt;Welcome&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 基于 ES6 class 定义的组件</span></span><br><span class="line"><span class="regexp">class Welcome2 extends Component &#123;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return &lt;h1&gt;Welcome&lt;/</span>h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个组件都有自己的属性（props）和状态（state）</p></li><li>组件的 <code>props</code> 是只读的。<strong>React 组件必须要像纯函数一样保护它们的 props 不被修改</strong></li></ul><h3 id="状态-state"><a href="#状态-state" class="headerlink" title="状态 state"></a>状态 state</h3><ul><li>组件的 <code>state</code> 是组件私有的，且完全受控于当前组件</li><li>除了在构造函数中可以直接给 <code>this.state</code> 赋值外，不要直接修改 <code>state</code>，否则不会渲染组件，要使用 <code>setState()</code> 更新状态</li><li><p><code>this.props</code> 和 <code>this.state</code> 可能是异步更新，不要依赖它们的值进行下一个状态更新。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的做法，这种可能无法得到预期结果</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.incr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法，使用一个箭头函数</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">    counter: state.counter + props.incr</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li><li><p>不管是父组件还是子组件都无法知道某个组件有无状态，且也不会关心是函数组件还是 class 组件。<strong>数据流动是单向向下的</strong>，从某个组件 <code>state</code> 产生的任何数据或 UI 只会影响树中<strong>低于</strong>它们的组件</p></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li>React 事件命名是 camelCase 风格，而非像 HTML DOM 中纯小写的风格</li><li>如果想要阻止事件的默认行为，必须显式使用 <code>e.preventDefault()</code>；这里的 <code>e</code> 是 React 根据 W3C 规范定义的合成事件，无需担心跨浏览器兼容问题</li><li>React 中自定义的方法默认不会绑定 <code>this</code>，所以有多种方式可以进行绑定：<ul><li><strong>常规</strong>：在构造函数中使用 <code>this.handleChange = this.handleChange.bind(this)</code></li><li><strong>推荐</strong>：使用 <code>public class fields</code> 语法：<code>handleChange = () =&gt; {}</code></li><li>在调用时，使用箭头函数或者 <code>bind</code> 绑定（注意，这种可能会带来性能问题，每次都会创建函数，如果是传递给子组件的，还可能会导致子组件重新渲染）</li></ul></li></ul><h2 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h2><ul><li>在列表元素或者组件中，必须要指定 Key。而如果没有设定，则默认使用索引。但是使用索引可能会带来性能问题和状态问题</li><li>Key 并不需要全局唯一，只是在相邻节点之间需要保持唯一即可</li><li>Key 会被传递给 React，但不会传递给组件</li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul><li><strong>受控组件</strong>：把 HTML 表单元素和 React state 结合起来，让渲染表单的 React 组件还控制用户输入过程中表单发生的事情</li><li>在受控组件上指定 value 的 prop 可以防止用户更改输入</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>通常，如果多个组件反映相同的数据变更，可以将状态提升到最近的公共父组件</li><li>组合优于继承</li><li>有些组件无法提前知晓它们子组件的具体内容，可以通过 <code>props.children</code> 获取子组件渲染</li></ul><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="Context（此-Context-有点特殊）"><a href="#Context（此-Context-有点特殊）" class="headerlink" title="Context（此 Context 有点特殊）"></a>Context（此 Context 有点特殊）</h2><ul><li>虽然可以通过 <code>props</code> 将属性从父组件一级级传递到子组件树，但这样毕竟比较繁琐。而有些比较全局的配置（如主题、地区等），则可以通过 <code>Context</code> 进行共享，方便组件树访问这些全局配置</li><li>创建 <code>context：</code>const ThemeContext = React.createContext(‘light’)`</li><li><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定要读取的 Context 类型</span></span><br><span class="line">  <span class="comment">// React 会自动查找最近的 theme provider</span></span><br><span class="line">  <span class="comment">// 然后使用它的值</span></span><br><span class="line">  <span class="keyword">static</span> contextType = ThemeContext</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 使用 `this.context` 可以获取值</span></span><br><span class="line">      &lt;button className=<span class="string">"Button"</span>&gt;&#123;<span class="keyword">this</span>.props.text&#125; + &#123;<span class="keyword">this</span>.context&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function ToolBar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Button text=&#123;props.text&#125;&gt;&lt;/</span>Button&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 使用 Provider 指定 ctx value</span></span><br><span class="line">    &lt;ThemeContext.Provider value=<span class="string">"yellow"</span>&gt;</span><br><span class="line">      &lt;ToolBar text=<span class="string">"工具按钮"</span>&gt;&lt;/ToolBar&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure></li><li><p>Context 使用会导致组件的复用性变差，会依赖 Context。<strong>如果只是想要避免层层传递属性，可以使用组件组合的方式</strong></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3></li><li><p><code>createContext</code>: <code>const myCtx = React.createContext(defaultValue)</code></p><ul><li>对于订阅了上述 ctx 的子组件，会自动在离自己最近的匹配 Provider 处获取设置的值</li><li>如果未能找到 Provider，则使用 defaultValue</li></ul></li><li><p><code>Provider</code></p><ul><li>允许消费组件订阅 context 的变化</li><li>可以传递 value 给消费组件，可以嵌套</li><li>Provider value 变化时，内部消费组件也会重新渲染</li><li>Provider 及消费组件不受 <code>shouldComponentUpdate</code> 函数限制</li></ul></li><li><p><code>contextType</code></p><ul><li>挂载在 <code>class</code> 对象上，指向创建的 Context 对象</li><li>可以在任意生命周期通过 <code>this.context</code> 访问到最近 Context 的值</li></ul></li><li><p><code>Consumer</code>：订阅 context 变更</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">    &#123;value =&gt; <span class="comment">/* do stuff */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Context 使用了 reference identity 来决定何时进行渲染，但也存在陷阱。当 Provider 父组件重新渲染时，也可能会导致消费组件意外被渲染</p></li></ul><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><ul><li>常见模式是一个组件要返回多个元素，使用 <code>Fragment</code> 可以将子列表分组，且无需向 DOM 添加额外节点<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Column</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;td&gt;hello <span class="number">1</span>&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">      &lt;td&gt;hello 2&lt;/</span>td&gt;</span><br><span class="line">      &lt;td&gt;hello <span class="number">3</span>&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Row</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;tr&gt;&lt;Column&gt;&lt;/Column&gt;&lt;/tr&gt;</span><br><span class="line">      &lt;tr&gt;&lt;Column&gt;&lt;/Column&gt;&lt;/tr&gt;</span><br><span class="line">      &lt;tr&gt;&lt;Column&gt;&lt;/Column&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Table(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;table&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Row&gt;&lt;/</span>Row&gt;</span><br><span class="line">    &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="高阶组件（High-Order-Component-HOC）"><a href="#高阶组件（High-Order-Component-HOC）" class="headerlink" title="高阶组件（High Order Component, HOC）"></a>高阶组件（High Order Component, HOC）</h2><ul><li>HOC 是 React 中基于组合特性而形成的设计模式，是一种复用组件逻辑的技巧</li><li>HOC 的参数是组件，返回值是新组件的函数：<code>const NewComponent = hoc(WrappedComponent)</code></li><li>面向切面编程，替代 Mixin 模式；纯函数，无副作用</li><li><p><strong>约定</strong>：HOC 应该透传与自身无关的 props，使用类似下面的方式编写 <code>render</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;level, ...props&#125; = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="built_in">console</span>.log(level)</span><br><span class="line">      <span class="built_in">console</span>.log(props)</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent level=&#123;level&#125; &#123;...props&#125;&gt;&lt;/WrappedComponent&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>约定</strong>：最大化可组合性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compose 达到的效果就是：withRouter(connect(componentSelector)(WrappedComponent)))</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">    <span class="comment">// 单纯的 HOC</span></span><br><span class="line">    withRouter,</span><br><span class="line">    connect(componentSelector)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure></li><li><p><strong>约定</strong>：返回清晰的名称，便于调试。命名习惯：HOCName(wrappedComponentName)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithLogComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent &#123;...props&#125;&gt;&lt;/WrappedComponent&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  WithLogComponent.displayName = <span class="string">`WithLogComponent(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">  <span class="keyword">return</span> WithLogComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.displayName || c.name || <span class="string">'Component'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：</p><ul><li>不要在 <code>render()</code> 中使用 HOC，避免 React 渲染性能问题（不是更新子树，而是卸载旧子树，挂载新子树，且导致组件状态也会丢失）。如果的确需要动态调用 HOC，可以在生命周期方法或构造函数中进行</li><li>静态方法需要显式拷贝，可以使用 <code>hoistNonReactStatic</code> 函数拷贝所有非 React 静态方法</li><li>Ref 不会被传递</li></ul></li></ul><h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><ul><li>对组件 props 类型进行检查，配置 <code>propTypes</code> 属性即可</li><li>考虑到性能问题，仅在开发模式下生效</li><li>可以配置 <code>defaultProps</code> 设定默认值</li></ul><h2 id="生命周期图谱"><a href="#生命周期图谱" class="headerlink" title="生命周期图谱"></a>生命周期图谱</h2><p><img src="./react-lifecycle.png" alt="react-lifecycle"></p><h1 id="合成事件（Synthetic-Event）"><a href="#合成事件（Synthetic-Event）" class="headerlink" title="合成事件（Synthetic Event）"></a>合成事件（Synthetic Event）</h1><ul><li><code>SyntheticEvent</code> 实例是传递给事件处理函数的参数，它是对浏览器事件的包装，兼容所有浏览器，同时提供了接近原生事件的接口。当然，也提供了 <code>.nativeEvent</code> 供你获取底层事件</li><li><p>重要的属性和方法：</p><ul><li><code>boolean bubbles</code></li><li><code>boolean cancelable</code></li><li><code>DOMEventTarget currentTarget</code></li><li><code>boolean defaultPrevented</code></li><li><code>number eventPhase</code></li><li><code>boolean isTrusted</code></li><li><code>DOMEvent nativeEvent</code></li><li><code>void preventDefault()</code></li><li><code>boolean isDefaultPrevented()</code></li><li><code>void stopPropagation()</code></li><li><code>boolean isPropagationStopped()</code></li><li><code>DOMEventTarget target</code></li><li><code>number timeStamp</code></li><li><code>string type</code></li></ul></li><li><p><code>SyntheticEvent</code> 在完成事件回调后，其属性会无效，无法异步访问该事件</p></li></ul><h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><ul><li>Hook 是 React 16.8 以后新增的特性，它可以让我们在不编写 <code>class</code> 组件的情况下使用 <code>state</code>, <code>props</code> 等 React 特性</li><li>Why Hook:<ul><li>原有的写法中，组件之间状态逻辑复用很困难。<strong>Hook 可以提取状态逻辑，单独测试和复用，并且无需修改原有组件的结构</strong></li><li>复杂组件变得难以理解。<strong>Hook 会将组件中相互关联的部分拆分成更小的函数，不会强制按照生命周期划分</strong></li><li>难以理解的 class。<strong>Hook 可以在非 class 的情况下使用更多的 React 特性</strong></li></ul></li><li>Hook 可以理解为在函数组件中「钩入」React State 以及生命周期等特性的函数，并且不能再 class 组件中使用</li><li>使用规则：<ul><li>只能在函数最外层调用 Hook，不要在<strong>循环、条件或嵌套函数</strong>中调用 Hook</li><li>只能在函数组件中调用 Hook</li></ul></li><li>原先我们在编写函数组件时，如果需要给其引入状态，或者添加生命周期的钩子，需要转换成 class 组件。但有了 Hook 特性后，可以使用 <code>useState</code> 和 <code>useEffect</code> 来代替了。新的写法将会更加简洁，易于抽象复用和测试</li></ul><h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><ul><li>使用 <code>useState</code> Hook 可以在函数组件中添加内部 state，React 在重复渲染时保留该 state</li><li><code>useState</code> 返回的更新 state 的函数和 <code>this.setState</code> 行为有区别，<strong>前者不会把新旧 state 合并，而后者会</strong></li><li>示例：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;点我&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;点击计数：&#123;count&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Event-Hook"><a href="#Event-Hook" class="headerlink" title="Event Hook"></a>Event Hook</h2><ul><li>使用 <code>useEffect</code> Hook 给函数组件添加操作副作用的能力。相当于 class 组件中 <code>componentDidMount</code>, <code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的合体，将副作用操作都聚集到该 Hook 中</li><li>调用 <code>useEffect</code> 时，就表明让 React 在对 DOM 完成更改后调用相应的副作用函数；同时可以返回一个回调函数，用于在清除时执行一些操作。React 会在组件卸载时执行清除操作</li><li><p>使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [userInfo, setUserInfo] = useState(&#123; <span class="attr">username</span>: <span class="string">'游客'</span>, <span class="attr">clickCount</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">"当前用户信息："</span> + userInfo.username)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"销毁组件，重新渲染"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setUserInfo(&#123; <span class="attr">username</span>: <span class="string">'iFaceless'</span>, <span class="attr">clickCount</span>: userInfo.clickCount &#125;)&#125;&gt;设置用户&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setUserInfo(&#123; clickCount: userInfo.clickCount + 1, username: userInfo.username &#125;)&#125;&gt;点击计数&lt;/</span>button&gt;</span><br><span class="line">            &lt;p&gt;你好，&#123;userInfo.username&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;点击计数 &#123;userInfo.clickCount&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>默认情况下，useEffect 会在每次渲染后都会执行（当然可以控制），我们不用关心「挂载」和「更新」这种概念</p></li><li>与 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 不同的是，<code>uesEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕，从而获得更好的响应速度。如果需要同步执行，则使用 <code>useLayoutEffect</code> Hook</li></ul><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><ul><li>自定义 Hook 需要以 <code>use</code> 开头，这是约定，可以让 React 自动检查 Hook 是否违反相关规则</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://react.docschina.org/docs" target="_blank" rel="noopener">React 官方文档</a></li><li><a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank" rel="noopener">Index as a key is an anti-pattern</a></li><li><a href="https://jaredpalmer.com/formik/" target="_blank" rel="noopener">Formik</a></li><li><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">组件生命周期图谱</a></li><li><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">How to fetch data with React Hooks?</a></li><li><a href="https://www.robinwieruch.de/react-fetching-data/" target="_blank" rel="noopener">How to fetch data in React</a></li><li><a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener">Making Sense of React Hooks</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;React 是一个用于构建 UI 的 JavaScript 库，它有&lt;strong&gt;声明式&lt;/strong&gt;、&lt;strong&gt;组件化&lt;/strong&gt;的特点。使用 JSX 的语法可以非常轻松地编写各种组件，而基于各种组件又可以构造出更加复杂的前端页面。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ifaceless.space/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://ifaceless.space/tags/JavaScript/"/>
    
      <category term="React" scheme="http://ifaceless.space/tags/React/"/>
    
      <category term="前端框架" scheme="http://ifaceless.space/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6 学习笔记</title>
    <link href="http://ifaceless.space/2019/06/23/javascript-es6-learning-note/"/>
    <id>http://ifaceless.space/2019/06/23/javascript-es6-learning-note/</id>
    <published>2019-06-23T10:02:35.000Z</published>
    <updated>2019-11-24T09:45:59.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>2015 年，ECMAScript 第六版得以发布，这就是众所周知的 ES6 标准，标志着 JavaScript 语言迎来新纪元。ES6 引入了一些新的语法糖，同时弥补了一些在 ES5 中存在的一些缺陷。</p><p>本篇笔记是在学习阮一峰老师的《ES6 入门教程》中做的笔记，主要是记录一些自己不太熟悉的或者和 ES5 差异很大的特性。在学习过程中，可以和别的语言（如 Python）进行对比，也可以看到在某些设计思想上，这些语言也是相通的。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>ES5 其实是 ES3 的升级版本，也就是 ES3.1</li><li>ES4 其实并没有发布，但是增加的一些功能在 ES6 中发布了</li><li>每年 6 月发布新的标准，ES6 泛指下一代 JavaScript 标准</li><li>Babel 转码器：将 ES6 代码转换成 ES5 代码</li><li>Google 的 <code>Traceur</code> 转码器也可以将 ES6 代码转为 ES5 代码</li></ul><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><ul><li>暂时性死区本质：只要一进入当前作用域，所需要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li><li>块作用域可以任意嵌套</li><li>块作用域内可以声明函数，但是只能在该作用域下使用</li><li>浏览器为了兼容历史代码，在块作用域中声明的函数会提升到全局，类似 <code>var</code> 声明的变量了</li><li><p>ES6 支持 6 中声明关键字：</p><ul><li><code>var</code></li><li><code>function</code></li><li><code>let</code></li><li><code>const</code></li><li><code>import</code></li><li><code>class</code></li></ul></li><li><p><code>var</code>, <code>function</code> 命令声明的全局变量，依然是顶层对象的属性；<code>let</code>, <code>const</code>, <code>class</code> 声明的全局变量，则不再属于顶层对象的属性。二者需要脱钩</p></li><li>JavaScript 中的顶层对象在各个环境下都是需要存在的，但是在 Node 和浏览器环境中用一套代码想要拿到顶层对象还是有些费劲的。可行的方案如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><ul><li><p>解构（类似 Python 中的用法，或者 Rust 中的模式匹配）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 将接收剩余的数组元素</span></span><br><span class="line">[a, b, ...c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[, , c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 不完全解构也是支持的</span></span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值必须要是可迭代的，即实现了 Iterator 接口，否则会出错</span></span><br><span class="line">[a, b] = <span class="literal">NaN</span> <span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure></li><li><p>可设置默认值：<code>let [foo = true] = [];</code>，只有数组成员严格等于 <code>undefined</code> 才会让默认值生效</p></li><li>解构失败，变量值为 <code>undefined</code></li><li><p>对象也可以解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">name</span>: <span class="string">"chris"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = o</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将对象赋值给某个已有的变量</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span></span><br><span class="line">log(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以有别名，name 是模式，n 才是被赋值的变量</span></span><br><span class="line">(&#123;<span class="attr">name</span>: n, <span class="attr">age</span>: a&#125; = o)</span><br></pre></td></tr></table></figure></li><li><p>对象解构的本质是，先找到同名属性，再赋值给对应的变量</p></li><li>解构赋值的原则是，只要右值不是对象或数组，都要先转为对象（如数字会转成 Number）；而 <code>undefined</code> 和 <code>null</code> 无法转换为对象，所以会报错</li><li><strong>函数的参数也支持解构赋值</strong></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><code>&quot;\u{xxxx}&quot;</code> 可以表示超过两个字节的 Unicode 字符</li><li><code>for (let c of &#39;foo&#39;)</code> 可以直接遍历字符串，并且可以识别大于 <code>0xFFFF</code> 的码点</li><li><p><code>String.raw</code> 返回转义字符串：</p></li><li><p><code>String.includes()</code> 是否存在子串</p></li><li><code>String.startsWith()</code> + <code>String.endsWith()</code></li><li><code>String.repeat()</code></li></ul><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ul><li><p>多种进制写法：</p><ul><li>二进制：<code>0b010101</code></li><li>八进制：<code>0o123</code></li><li>十六进制：<code>0x1234</code></li></ul></li><li><p>将字符串的多种进制转换成十进制：<code>Number(target)</code></p></li><li>新增了 <code>Number.isFinite</code> 和 <code>Number.isNaN</code> 方法，但这两种方法只对数值有效，其它一律为 false。注意也有一对全局的函数 <code>isFinite</code> 和 <code>isNaN</code>，它们则会尝试先将输入的参数转换为 Number 后再进行判断，这是最重要的区别</li><li>ES6 将 <code>parseInt</code> 和 <code>parseFloat</code> 挪到 <code>Number</code> 上了，这样会更加统一</li><li><code>Number.EPSILON</code> 浮点数计算会有精度损失，这个极小值可以用来指定误差范围</li><li>指数运算符 <code>**</code>，采用的是右结合的模式</li><li>V8 引擎中，指数运算符和 <code>Math.pow</code> 算法实现是不同的，对于特别大的结果，二者会有细微差别</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>默认参数：<ul><li><code>function say(word = &#39;hi&#39;) { console.log(word) }</code></li><li>同一作用域中，不能出现同名函数的声明</li><li>默认参数是<strong>惰性计算</strong>，每次调用都会重新计算，这点和 Python 非常不同！！</li></ul></li></ul><ul><li>函数参数支持解构，且支持默认值</li><li>指定了参数默认值后，函数的 <code>length</code> 属性只会返回未设置默认值的参数个数</li><li>如果设置了参数，且不是尾参数，则其之后的参数都不算到 <code>length</code> 了：<code>(function (a = 0, b, c) {}).length // 0</code></li><li><p>函数如果设置了默认值，则在初始化时会形成一个特殊的作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">100</span></span><br><span class="line"><span class="comment">// 这里的参数 `x` 和 `y` 处于一个作用域中，故 `y` 的默认值就是指向参数 `x`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">200</span>) <span class="comment">//200, 200</span></span><br></pre></td></tr></table></figure></li><li><p>ES6 规定，只要函数使用了默认值、解构和扩展运算符，就不能在内部显式指定为<strong>严格模式</strong></p></li><li>箭头函数（更简洁的匿名函数写法）：<ul><li>如果直接返回一个对象，需要将对象用圆括号包围，否则会被解释为代码块：<code>let getObj = id =&gt; ({ id: id })</code></li><li><strong>函数体内的 <code>this</code> 是定义时所在的对象，而非使用时所在的对象</strong>，也就是在箭头函数中，<code>this</code> 是固定的。本质上是因为在箭头函数中，根本就没有 <code>this</code>，它指向的是外层的 <code>this</code></li></ul></li></ul><pre><code>- 不可以作为构造函数，不能对它使用 `new` 命令- 没有 `arguments` 对象- 不能使用 `yield`，不可以作为 `Generator`</code></pre><ul><li><p>尾调用：</p><ul><li>函数式编程中的一个重要概念，指的是函数的最后一步操作（不一定是最后一行，逻辑上是最后一步）是<strong>直接调用</strong>另一个函数并返回其结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> bar(x) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下不符合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">let</span> y = bar(x); <span class="keyword">return</span> y &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123; bar(x) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> bar(x) + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>尾调用优化：只保留内层函数的调用帧，节约内存</p></li><li>ES6 中只要使用了尾递归，就不会出现调用栈溢出，因为只需要维护一个调用帧即可。但其实这个优化只有在严格模式下才会启用。正常模式下，需要通过变量 <code>arguments</code>, <code>func.caller</code> 来跟踪函数的调用栈</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组复制：<code>const a2 = [...a1]</code> 或者 <code>const [...a2] = a1</code></li><li>可以将字符串转换为数组：<code>const a = [...&#39;hello&#39;]</code></li><li>扩展运算符 <code>...</code> 可以将任何实现了 <code>Iterator</code> 接口的对象转换成数组</li><li><code>Array.from</code> 可以接受任意实现了 <code>Iterator</code> 接口的对象，转换成数组；也支持 array-like 对象</li><li><code>Array.of</code> 将一组值转换为数组，弥补 <code>Array</code> 构造函数在参数个数不同时，行为也不同的毛病。完全可以替代 <code>Array()</code> 或者 <code>new Array()</code></li><li><p>提供了几个遍历的接口：</p><ul><li><code>keys()</code> 实际就是索引</li><li><code>values()</code> 值</li><li><code>entries()</code> 键值</li></ul></li><li><p><code>includes()</code> 判断是否包含元素</p></li><li><code>flat</code> 用于将嵌套数组展开，拉平，默认只展开一层，可指定多层或者 <code>Infinity</code></li><li><code>flatMap</code> 和 <code>flat</code> 类似，但是会对每个元素执行一次回调函数，但它只能展开一层</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>属性或者方法都可以简写啦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> a = &#123;x, y&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的简写</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    doSomething() &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="comment">// 常规写法</span></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>允许使用表达式作为对象的属性名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [properKey]: <span class="literal">true</span>,</span><br><span class="line">    [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ES6 中属性遍历的方法：</p><ul><li><code>for...in</code>：遍历对象自身和继承的<strong>可枚举属性</strong>（不含 Symbol 属性）</li><li><code>Object.keys(obj)</code>：对象自身<strong>可枚举属性</strong>（不含 Symbol 属性）</li><li><code>Object.getOwnPropertyNames(obj)</code>：对象自身的<strong>所有属性</strong>的键名（不含 Symbol 属性）</li><li><code>Object.getOwnPropertySymbols(obj)</code>：对象自身所有 <code>Symbol</code> 属性的键名</li><li><code>Reflect.ownKeys(obj)</code>：对象自身所有的键名（无论是 Symbol 属性或者是别的属性，不关心可否枚举）</li></ul></li><li><p><code>super</code>：</p><ul><li>指向对象的原型对象，在这种用法下，只能在<strong>对象方法</strong>中使用</li><li>对象方法：必须采用 ES6 方法简写的方式，才会被认定为对象方法</li></ul></li><li><p>对象解构赋值：</p><ul><li><code>let { x, y, ...z }  = { x: 1, y: 2, a: 10, b: 20 }</code></li><li>解构赋值必须是最后一个参数</li><li>右值必须是对象</li><li>采用的是浅拷贝</li></ul></li><li><p><code>Object.is()</code>：</p><ul><li>更加明确的比较对象是否符合 <strong>Same-value equlity</strong></li><li><code>Object.is(NaN, NaN) // true</code> </li><li><code>Object.is(+0, -0) // false</code></li></ul></li><li><p><code>Object.assign()</code> 用于对象合并，就是将源对象所有可枚举的属性复制到目标对象（包括 <code>Symbol</code> 属性）。注意点：</p><ul><li>浅拷贝</li><li>同名属性直接替换，不考虑嵌套</li><li>由于 <code>Object.assign</code> 只能进行值复制，对于取值函数，则会先取值再复制</li></ul></li><li><p><code>Object.assign()</code> 常见用途：</p><ul><li>为对象添加属性：<code>Object.assign(this, { x, y })</code></li><li>为对象添加方法：<code>Object.assign(Foo.prototype, { barMethod() { ... } })</code></li><li>对象克隆：<code>Object.assign(Object.create(originProto), origin)</code></li><li>属性提供默认值：<code>Object.assign({}, DEFAULTS, options)</code></li></ul></li></ul><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul><li><p>ES6 引入 Symbol 的原因：</p><ul><li>ES5 中，属性名是字符串，容易造成属性名冲突</li><li>Symbol 可以保证每个属性独一无二</li></ul></li><li><p><code>Symbol</code> 是新增的原始类型，表示独一无二的值。用于对象的属性。使用 <code>Symbol()</code> 函数构造</p></li><li><code>Symbol</code> 接收一个字符串作为参数，表示对 <code>Symbol</code> 实例的描述。如果是一个对象参数，则会调用 <code>obj.toString()</code> 得到对象的字符串，再生成一个 Symbol 值</li><li>注意点：<ul><li>不可以直接与其它类型值运算，不会隐式转换为 string</li><li>可以显式转换为 string</li></ul></li><li><code>symbol.description</code> 可以获取 Symbol 的描述信息</li><li><p>作为对象的属性（只能是公开属性）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种定义方式</span></span><br><span class="line">person[name] = <span class="string">"Foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取的方式</span></span><br><span class="line">person[name]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种定义方式</span></span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">    [name]: <span class="string">'Bar'</span> <span class="comment">// 必须要放在方括号中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种定义方式</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>可以作为常量，保证值不同</p></li><li>可以类似我们在 Python 中那样定义 Enum：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userType = &#123;</span><br><span class="line">    guest: <span class="built_in">Symbol</span>(),</span><br><span class="line">    org: <span class="built_in">Symbol</span>(),</span><br><span class="line">    member: <span class="built_in">Symbol</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于不会被常规的方法如 <code>getOwnPropertyNames</code> 等遍历到，但其实又是公开。这种特性可以用来创建一些非私有、仅希望内部调用的方法</li><li><p><code>Symbol.for</code> 和 <code>Symbol.keyFor</code>：复用相同参数构建的 <code>Symbol</code>，它会在全局注册参数，并在创建前进行搜索，如果存在则返回，否则新建。注意这个全局是全局环境，可以在不同的 <code>iframe</code> 和 <code>service worker</code> 中取到同样的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'s1'</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'s1'</span>) === s1 <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// 's1'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>内置的 Symbol 值，指向语言内部使用的方法：</p><ul><li><code>Symbol.hasInstance</code>，每个对应可以自定义这个 Symbol 方法，从而让 <code>instanceof</code> 运算符按照期望的表现</li><li><code>Symbol.isConcatSpreadable</code> 属性，表示在 <code>Array.prototype.concat()</code> 时，能否展开</li><li><code>Symbol.species</code> 属性，指向一个构造函数。在创建衍生对象时，会使用该属性</li><li><code>Symbol.iterator</code> 指向对象的默认遍历器</li><li><code>Symbol.toPrimitive</code> 指向转换成原始类型的方法</li></ul></li></ul><h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><ul><li><code>Set</code> 构造函数可接受任意 <code>Iterable</code> 的对象</li><li><p>来看下消除数组中重复元素的方法与 Python 的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Python 中的写法</span><br><span class="line">list(set([1, 1, 2]))</span><br><span class="line"></span><br><span class="line">// JS ES6 中的写法</span><br><span class="line">[...new Set([1, 1, 2])]</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">Array.from(new Set([1, 1, 2)])</span><br></pre></td></tr></table></figure></li><li><p><code>WeakSet</code> 弱引用计数，只能存放对象。不可遍历</p></li><li><p><code>Map</code> 的构造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先看看 Python 中一个类似的构造方式</span></span><br><span class="line">dict(zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'chris'</span>, <span class="number">22</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么在 ES6 中的写法</span></span><br><span class="line"><span class="comment">// 实际上任意 Iterable 的对象，且成员均为双元素的数组的数据结构都可以作为 Map 的构造函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'chris'</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p><code>WeakMap</code></p></li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul><li>属于元编程范畴，可以拦截一些操作，并进行重定义</li><li>构造函数：<code>var proxy = new Proxy(target, handler)</code></li><li><p>要想让 <code>Proxy</code> 起作用，必须要针对其实例进行操作，而非目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get (target, name, receiver) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">"name"</span> || name == <span class="string">"age"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name, receiver)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">ReferenceError</span>(<span class="string">`property '<span class="subst">$&#123;name&#125;</span>' not found`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    name: <span class="string">"Chris"</span>,</span><br><span class="line">    age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, handler)</span><br><span class="line"><span class="built_in">console</span>.log(proxy)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.age)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo)</span><br></pre></td></tr></table></figure></li><li><p><code>Proxy.revocable</code> 可以返回一个可取消的 Proxy 实例</p></li></ul><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ul><li><code>Reflect</code> 也是为了操作对象而提供的新的 API，设计目标：<ul><li>将 <code>Object</code> 对象中明显属于内部的方法剥离出来，放到 <code>Reflect</code> 对象上</li><li>修改某些 <code>Object</code> 方法的返回结果，更加方便使用</li><li>将某些命令式的操作，变成函数，如：<code>name in obj =&gt; Reflect.has(obj, name)</code>，<code>delete obj[name] =&gt; Reflect.deleteProperty(obj, name)</code></li><li>与 <code>Proxy</code> 中拦截方法一样，可以替代执行对象的默认行为</li><li><code>Reflect.apply(Math.floor, undefined, [1])</code></li></ul></li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>异步编程解决方案。所谓 Promise，就是一个简单的容器，保存着未来才会结束的事情（通常是一个异步结果）</li><li><p>特点：</p><ul><li>对象的状态不受外界影响（pending, fulfilled, rejected）</li><li>一旦状态改变，就不会再变，任何时候都可以得到结果</li><li>以更加同步的方式编程，易于提供统一的接口，便于维护</li></ul></li><li><p>缺点：</p><ul><li>无法取消</li><li>若不设置回调，Promise 内部抛出错误不会反馈到外部</li><li>pending 状态时，无法得知具体进展情况</li></ul></li><li><p><code>Promise.prototype.then()</code> 可接受两个回调，一个是 <code>resolved</code> 时的 回调，还有一个是 <code>rejected</code>  时的回调。第二个回调可选</p></li><li><code>Promise.prototype.then()</code> 返回的是一個新的 <code>Promise</code> 實例</li><li><code>Promise.prototype.catch()</code> 是 <code>.then(undefined, rejection)</code> 或 <code>.then(null, rejection)</code> 的别名，用于指定发生错误时的回调函数</li><li>Promise 对象的错误具有冒泡的性质，会一直向后传递，直到被捕获为止。错误总是会被下一个 <code>catch</code> 捕获</li><li><code>Promise.prototype.finally</code> 用于指定不管 <code>Promise</code> 对象最终如何，都会执行的操作，ES2018 引入。无法在 finally 中获取 Promise 的状态，它的执行与状态无关</li><li><p><code>Promise.all</code>：</p><ul><li>参数必须是 Iterable 的对象，元素应当是 Promise 实例</li><li>状态由成员决定，只有都是 <code>fulfilled</code> 时，整体的状态才会变成 <code>fulfilled</code></li><li>如果任何一个 <code>rejcted</code> ，则整体整体就是 <code>rejected</code>，并且返回第一个被 <code>reject</code> 的实例的返回值</li></ul></li><li><p><code>Promise.race</code>，类似 <code>Promise.any</code> 的感觉，就是只要有一个状态改变，整体状态就变化；率先变化的 Promise 实例返回值会传递给 <code>p</code> 的回调函数</p></li></ul><h2 id="Iterator-amp-for…of"><a href="#Iterator-amp-for…of" class="headerlink" title="Iterator &amp; for…of"></a>Iterator &amp; for…of</h2><ul><li><p>Iterator 遍历过程：</p><ul><li>创建一个指向可迭代对象的指针对象</li><li>调用 <code>next</code>，可得到第一个成员（返回结果包括两个属性：<code>value</code> + <code>done</code>，可分别省略）</li><li>不断调用 <code>next</code> 直到消费完</li></ul></li><li><p>实现了 <code>Iterator</code> 接口的数据结构，就是可遍历的（Iterable）。示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(start = 0, stop = 100) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = start</span><br><span class="line">        <span class="keyword">this</span>._stop = stop</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">this</span>._value</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="keyword">this</span>._stop) &#123;</span><br><span class="line">            <span class="keyword">this</span>._value++</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: val&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="keyword">new</span> RangeIterator()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>何时触发 Iterator （即 <code>Symbol.iterator</code>）接口调用？</p><ul><li>解构赋值</li><li>扩展运算符</li><li><code>yield*</code></li><li><code>for...of</code></li><li><code>Array.from()</code></li><li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code></li><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li></ul></li><li><p>可以使用 Generator 函数实现可迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(start = 0, stop = 10) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = start</span><br><span class="line">        <span class="keyword">this</span>._stop = stop</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>._value &lt; <span class="keyword">this</span>._stop) &#123;</span><br><span class="line">            <span class="keyword">this</span>._value++</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>._value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="keyword">new</span> RangeIterator()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历器对象除了有 <code>next</code> 方法外，还可以添加一个 <code>return</code> 方法，用于处理 <code>for...of</code> 提前退出（如出错，或者 <code>break</code>）时要做的事情。而 <code>throw</code> 方法一般是配合 Generator 函数使用</p></li></ul><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><ul><li>定义方式：<code>function* funcName() { yield 1; return &quot;end&quot; }</code></li><li>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数内部指针</li><li><code>yield</code> 只能用于 Generator 函数中（这个和 Python 不同。在 Python 中，Generator 函数从表明上看和普通函数定义是一样的，只是实现不同）</li><li><code>yield</code> 表达式本身无返回值，或者总返回 <code>undefined</code>。<code>next</code> 方法可以带参数，作为 <code>yield</code> 表达式的返回值</li><li>第一次带参数调用 <code>next</code> 方法时，参数是无效的。因为 <code>next</code> 方法的参数表示上一个 <code>yield</code> 表达式的返回值</li><li>语义上，第一次调用 <code>next</code> 是启动遍历器对象</li><li><code>Generator.prototype.throw()</code> 可以在函数体外向 Generator 函数抛错。如果生成器中没有 <code>try...catch</code> 块，错误会传递到外部</li><li>如果一个 Generator 执行过程中出错，且没有内部捕获，则会认为它已经执行结束了</li><li><code>Generator.prototype.return()</code> 可以终止 Generator，如果 <code>return</code> 带参数，则会作为最后的返回值。如果 Generator 中含有 <code>try...finally</code> 语句块，则会优先执行 <code>finally</code>，延迟返回</li><li><code>yield*</code> 表达式可以参考 Python 中的 <code>yield from</code></li><li>异步编程模式：<ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise 对象</li></ul></li></ul><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><ul><li><code>async</code> 是 Generator 语法糖，写异步执行的函数更加便捷</li><li><p>改进点：</p><ul><li><strong>内置执行器</strong>，无需 <code>co</code> 之类的模块控制 Generator 执行流程了</li><li><strong>更好的语义</strong></li><li><strong>更广的适用性</strong>。<code>await</code> 可以是 Promise 对象，如果是原始类型值，则会自动转换为 resolved Promise 对象</li><li><strong>返回值是 Promise</strong></li></ul></li><li><p>定义方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> o = &#123; <span class="keyword">async</span> foo() &#123; &#125; &#125;</span><br><span class="line"><span class="comment">// 类中定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">"avatars"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> getAvatar(name) &#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise</span><br><span class="line">        <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Storage()</span><br><span class="line">store.getAvatar(<span class="string">"jake"</span>).then().cach()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>错误处理：如果 <code>await</code> 后面的异步操作出错，等同于 <code>async</code> 函数返回的 Promise 对象被 reject。捕获错误的两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> doSomething()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一种</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="built_in">console</span>.error(e) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于不相互依赖的独立操作，不建议分别 await，那样和同步有毛线区别。建议用下面的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([foo(), bar()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一种写法</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = foo()</span><br><span class="line"><span class="keyword">let</span> bar <span class="built_in">Promise</span> = bar()</span><br><span class="line"><span class="keyword">let</span> fooResult = <span class="keyword">await</span> fooPromise</span><br><span class="line"><span class="keyword">let</span> barResult = <span class="keyword">await</span> barPromise</span><br></pre></td></tr></table></figure></li><li><p>实现原理：就是将 Generator 函数和自动执行器包装在一起：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spaw(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul><li>ES6 中的 class 本质上还是 <code>Function</code> 对象，所有定义的新方法都是在 <code>prototype</code> 上。但是，类内部定义的所有方法都是不可枚举的，这点和 ES5 中直接给 <code>prototype</code> 挂载方法不同</li><li>每个类都必要有 <code>constructor</code>，如果没有会有一个空的 <code>constructor</code> 存在</li><li>类必须使用 <code>new</code> 调用，否则会报错</li><li><p>this 指向：</p><ul><li>类的方法内部如果含有 <code>this</code>，默认指向类的实例。但是如果单独使用，可能出错</li><li>解决方法有两种，固定 <code>this</code>：<ul><li>采用 <code>bind</code></li><li>使用箭头函数</li></ul></li></ul></li><li><p>静态方法：</p><ul><li>使用 <code>static</code> 关键字修饰</li><li>不会被实例继承和调用（这点和 Python 不同，在 Python 中 static 方法可以被实例调用，而不需要通过类名）</li><li>如果静态方法中包含 <code>this</code>，<strong>其指向的不是实例，而是类</strong></li><li>静态方法可以和非静态方法重名</li><li>父类的静态方法可以被子类继承</li></ul></li><li><p>继承：</p><ul><li>使用 <code>extends</code> 关键字</li><li>单继承</li><li>子类必须要在自定义的 <code>constructor</code> 方法中调用 <code>super</code>，触发父类构造函数调用后，才可以使用 <code>this</code></li></ul></li><li><p>判断一个类是否继承自某个类实例：<code>Reflect.getPrototypeOf(ColoredPoint) === Point</code></p></li><li><p><code>super</code> 关键字：</p><ul><li>当作函数使用，代表调用父类的构造函数（注意，此时 <code>super</code> 调用后返回的是基类的实例），只能用于构造函数</li><li>当作对象，在普通方法中指向父类的原型对象；在静态方法中，指向父类</li><li>ES6 规定，在子类普通方法中调用 <code>super.xxx()</code> 时，方法中的 <code>this</code> 指向的是<strong>当前的子类实例</strong></li><li>在子类静态方法中通过 <code>super</code> 调用父类方法时，内部的 <code>this</code> 指向当前的子类，而非子类的实例</li></ul></li><li><p>ES5 原生构造函数无法继承（子类无法获得原生构造函数的内部属性）。具体原因是 ES5 中，是新建子类的实例对象 <code>this</code>，再将父类的属性添加都子类上；而父类的内部属性无法获取，故无法继承：</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul></li><li><p>ES6 则允许继承上述原生构造函数了。原因是 ES6 中，是先新建父类的实例对象 <code>this</code>，再用子类的构造函数修饰 <code>this</code>，使得父类的行为可以继承</p></li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>早期 JS 无模块管理机制，不利于开发大型项目</li><li>社区提供了 CommonJS 和 AMD 两种方案，分别用于服务端和浏览器端；二者都是运行时确定模块依赖</li><li>ES6 模块的设计思想是尽可能静态化，编译时确定模块依赖关系及输入输出变量</li><li><p><code>import</code> 使用注意：</p><ul><li><code>import { foo } from &#39;mod&#39;</code></li><li>导入的变量都是只读的</li><li>导入的路径既可以是相对路径，也可以是绝对路径</li><li><code>.js</code> 后缀可省略</li><li>如果只是模块名称，无路径则需要配置文件告知 JS 引擎具体的模块位置</li><li>具有提升的效果</li><li>静态执行，无法使用表达式和变量</li><li>Single 模式，有缓存机制</li><li>整体加载带别名：<code>import * as mod from &#39;longNameMod&#39;</code></li></ul></li><li><p><code>export default</code> 本质上是输出一个叫做 <code>default</code> 的变量和方法，然后系统允许重名</p></li><li>在一条语句中同时输入默认方法和其它接口：<code>import _, { each } from &#39;lodash&#39;</code></li><li>复合写法：<code>export { foo, bar } from &#39;my_mod&#39;</code>，注意不会在当前模块导入这两个变量，而只是转发到外面了</li></ul><h2 id="模块加载规则"><a href="#模块加载规则" class="headerlink" title="模块加载规则"></a>模块加载规则</h2><ul><li><p>浏览器中可使用的方式：</p><ul><li><code>&lt;script src=&quot;path/to/foo.js&quot; [async/defer]/&gt;</code></li><li>ES6 模块加载（默认就是 defer 模式）：<code>&lt;script type=&quot;module&quot; src=&quot;./mod.js&quot;/&gt;</code></li><li><code>&lt;script type=&quot;model&quot;&gt;</code> /<em>可以正常写 import xx from xxx 这种，模块作用域</em>/`</li></ul></li><li><p>ES6 与 CommonJS</p><ul><li>前者输出是<strong>值引用</strong>，后者输出的是<strong>值拷贝</strong></li><li>前者是编译时输出接口，后者是运行时加载</li><li>前者是动态引用，后者会缓存值</li><li>在 Node 中 <code>import</code> 是异步加载</li><li>ES6 模块中，顶层 <code>this</code> 指向 <code>undefined</code>；后者则指向当前模块</li></ul></li></ul><h2 id="二进制数组（类数组）"><a href="#二进制数组（类数组）" class="headerlink" title="二进制数组（类数组）"></a>二进制数组（类数组）</h2><ul><li><p>二进制数组组成对象：</p><ul><li><code>ArrayBuffer</code> 对象：代表内存中的一段二进制数据，可通过「视图」操作</li><li><p><code>TypedArray</code> 视图：可用于读写简单的二进制数据，包括 9 种类型视图：</p><ul><li><code>Int8</code></li><li><code>Uint8</code></li><li><code>Uint8C</code>：自动过滤溢出，<code>DataView</code> 视图不支持</li><li><code>Int16</code></li><li><code>Uint16</code></li><li><code>Int32</code></li><li><code>Uint32</code></li><li><code>Float32</code></li><li><code>Float64</code></li></ul></li><li><p><code>DateView</code> 视图：可自定义复合格式的视图，读写复杂类型的二进制数据</p></li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener">ECMAScript 6 入门</a></li><li><a href="http://keenwon.com/1524.html" target="_blank" rel="noopener">ES5 和 ES6 中的继承</a></li><li><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;2015 年，ECMAScript 第六版得以发布，这就是众所周知的 ES6 标准，标志着 JavaScript 语言迎来新纪元。ES6 引入了一些新的语法糖，同时弥补了一些在 ES5 中存在的一些缺陷。&lt;/p&gt;
&lt;p&gt;本篇笔记是在学习阮一峰老师的《ES6 入门教程》中做的笔记，主要是记录一些自己不太熟悉的或者和 ES5 差异很大的特性。在学习过程中，可以和别的语言（如 Python）进行对比，也可以看到在某些设计思想上，这些语言也是相通的。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ifaceless.space/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://ifaceless.space/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://ifaceless.space/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ifaceless.space/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES5 入门笔记</title>
    <link href="http://ifaceless.space/2019/06/23/javascript-es5-learning-note/"/>
    <id>http://ifaceless.space/2019/06/23/javascript-es5-learning-note/</id>
    <published>2019-06-23T10:02:26.000Z</published>
    <updated>2019-11-24T09:45:59.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近抽空学习了下 JavaScript 语言，当然还是入门级别的那种。学习过程中也做了些笔记。总的来说，ES5 学完后，对 JavaScript 本身了解了大概，语言本身设计上也存在一些坑，所以搭配《JavaScript 精粹》这本书看看，可以进一步了解有哪些比较好的写法避免踩坑。</p><a id="more"></a><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><ul><li><p>判断是否为未定义的变量：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">"undefined"</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>typeof null</code> 也是 <code>object</code></p></li><li>使用 <code>instanceof</code> 可以判断是否为数组：<code>v instanceof Array</code></li><li><p><code>null</code> 和 <code>undefined</code> 非常类似，甚至 <code>null == undefined</code> 都成立，但是它们在 JavaScript 中还是有区别：</p><ul><li><code>null</code> 表示空对象，可转换为数值 0：<code>Number(null) //0</code></li><li><code>undefined</code> 表示没有定义的原始值，转换为数值为 NaN</li></ul></li><li><p>JS 中所有数字都是以 64 位浮点数存储的，对于某些运算，只能用整数，JS 会将数字转换为 32 位整数再做运算</p></li><li>数值计算比较需要注意，因为浮点数有精度丢失的问题。比如：<code>0.3-0.2 !== 0.2-0.</code>。</li><li>JavaScript 对 15 位的十进制数都可以精确处理。</li><li>对于码点在 U+10000 到 U+10FFFF 之间的字符，JavaScript 总是认为它们是两个字符（length 属性为 2）</li><li>base64 转换：<code>btoa</code>, <code>atob</code></li><li><p>属性删除 <code>delete</code>：</p><ul><li>不能删除对象本身</li><li>无论属性是否存在，删除总会返回 <code>true</code></li><li>继承的属性不能删除，虽然也会返回 <code>true</code></li><li>使用 <code>defineProperty</code> 定义的标记为不可删除的属性，<code>delete</code> 返回 <code>false</code></li></ul></li><li><p>对象属性存在新判断：</p><ul><li><code>in</code> 可以判断，但是不能区分是继承的还是自身拥有的</li><li><code>hasOwnProperty</code> 可以弥补上述缺点</li></ul></li><li><p><code>for...in</code> 用于遍历对象的属性：</p><ul><li>对象属性必须是可遍历的（enumerable）</li><li>对于继承的属性也会被遍历到，如果不想要，可以搭配 <code>hasOwnProperty</code> 过滤掉</li></ul></li><li><p>一般也可以使用 <code>Object.keys(o).map(k =&gt; { /*do stuff*/ }</code> </p></li><li>函数声明几种方式：<ul><li><code>function func_name(params) {}</code></li><li><code>let say = function (word) {}</code>，匿名函数</li><li><code>let say = function f(word) { console.log(f) }</code>，注意，这里的函数名 <code>f</code> 只可以在该函数内部访问到，有两个好处：<ul><li>遍历在函数内部调用自己</li><li>方便调试，排错时看到具体的函数名，而不再是匿名函数</li></ul></li><li>使用 <code>Function</code> 构造函数，注意，返回的函数的 <code>type</code> 的确也是 <code>function</code>（不推荐使用）</li></ul></li><li>JS 引擎将函数名视为变量名，所以也存在「函数名提升」的效果，因此，在函数声明位置的上方调用也不会出错</li><li>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域</li><li><p><code>arguments</code> 对象可以获取到函数传入的参数值：</p><ul><li>该对象不是数组，所以像 <code>slice</code>, <code>forEach</code> 方法就不存在</li><li>如果想要转换成数组，一种方式就是：<code>let args = Array.prototype.slice.call(arguments)</code></li><li>在严格模式下，不能通过 <code>arguments.callee</code> 调用函数自身；对 <code>arguments</code> 的修改不会对原始传入的参数产生影响</li></ul></li><li><p>立即调用函数的两种方式：</p><ul><li><code>(function () {console.log(10)})()</code></li><li><code>(function () {console.log(10)}())</code></li></ul></li><li><p>数组是特殊的对象，其键名就是一组数字，可以通过 <code>Object.keys</code> 返回所有的键名</p></li><li>数组的 <code>length</code> 属性不过滤空位。所以，使用 length 属性进行数组遍历，一定要非常小心。如 <code>delete arr[3]</code> 之后，依然不会影响 <code>length</code>，只是产生了一个空位；所以可以使用 <code>forEach</code> 替代，可以过滤空位（但空位不等同于 <code>undefined</code>）。也就是说 <code>var a = [, , ,]</code> 表示的每个位置都是空位；<code>var a = [undefined, undefined]</code> 则是可遍历到的，只是值为 <code>undefined</code> 而已</li><li>类似数组的数组（Array like object）：<ul><li>对象拥有类似下面的定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 所有的键都是数字</span><br><span class="line">// 带有 length 属性</span><br><span class="line">var obj = &#123;</span><br><span class="line">  0: &apos;a&apos;,</span><br><span class="line">  1: &apos;b&apos;,</span><br><span class="line">  2: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>函数的 <code>arguments</code>，字符串，还有多数的 DOM 元素都是 array-like 的对象。可以使用 <code>Array.prototype.slice.call(xx)</code> 转换成数组</p></li><li><p><code>void</code> 运算符：作用是执行一个表达式，不返回任何值（返回 undefined）：</p><ul><li>推荐用法：<code>void (x = 5)</code></li><li>使用场景，防止网页跳转：<code>&lt;a href=&quot;javascript: void f()&quot;&gt;文字&lt;/a&gt;</code></li></ul></li><li><p>逗号运算符返回最后一个值 <code>&#39;a&#39;, &#39;b&#39; // &quot;b&quot;</code></p></li></ul><h1 id="语法专题"><a href="#语法专题" class="headerlink" title="语法专题"></a>语法专题</h1><ul><li><code>Number</code> 用于强制转换成数值类型，与 <code>parseInt</code> 相比，转换要严格得多，只要遇到不可转换为数值的字符，转换就失败</li><li><code>Boolean</code> 所有对象（含空对象）的转换结果都是 <code>true</code>，如 <code>Boolean(new Boolean(false)) // true</code></li><li><p>JS 中所有抛出的错误都是 <code>new Error(xx)</code> 出来的，Error 的基本属性：</p><ul><li><code>message</code>：错误提示信息（必须）</li><li><code>name</code>：错误名称（非标准属性，看 JS 引擎）</li><li><code>stack</code>：错误的堆栈（非标准属性，看 JS 引擎）</li></ul></li><li><p>派生错误对象：    </p><ul><li><code>SyntaxError</code></li><li><code>ReferenceError</code></li><li><code>RangeError</code>：数组长度为负数；<code>Number</code> 对象的方法参数超出范围；函数堆栈超过最大值</li><li><code>TypeError</code></li><li><code>URIError</code></li></ul></li><li><p><code>throw</code> 可以抛出任意类型的值，并且在 <code>throw</code> 的位置就中断了执行，JS 引擎会接收到抛出的信息</p></li><li><p><code>console</code> 一些重要的方法：</p><ul><li><code>info</code></li><li><code>error</code></li><li><code>debug</code></li><li><code>warn</code></li><li><code>table</code></li><li><code>log</code></li><li><code>dir</code>：类似 <code>inspect</code></li></ul></li><li><p>可以在需要的地方加 <code>debugger</code> 作为断点，用于调试</p></li></ul><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><ul><li><code>Object()</code> 函数可以将任意值转换成对象，如果传入的参数是原始类型值，则会转换成其包装对象的实例；如果入参已经是对象了，则不会转换</li><li>可以利用上述特性判断变量是否为对象：<code>value === Object(value)</code></li><li><code>Object.keys()</code> 静态方法可以返回对象的所有属性名（非继承，且可枚举），该遍历方法优先</li><li><code>Object.getOwnPropertyNames()</code> 静态方法则会返回对象的所有属性名（包括不可枚举的）</li><li><p><code>Object.prototype.xxx</code> 实例方法：</p><ul><li><code>valueOf()</code>：返回对象的值，默认为自身</li><li><code>toString()</code>：返回对象的字符串表示</li><li><code>Object.prototype.toString.call(value)</code> 返回 <code>[object &lt;TypeName&gt;]</code>，第二个元素可以得到具体的值类型</li></ul></li><li><p>JS 提供了内部数据结构，描述对象的属性，控制其行为，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    writeable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    get: <span class="literal">undefined</span>,</span><br><span class="line">    set: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.getOwnPropertyDescriptor(obj, &#39;a&#39;)</code> 可以获取属性描述对象</p></li><li>默认情况下，如果属性被设置为 <code>writeable=false</code> 后，继承者将无法重新定义同名属性；除非可以通过覆盖属性描述对象来绕过限制 </li><li><p>如果属性的 <code>enumerable</code> 为 <code>false</code>，则有三种操作不能取到该属性：</p><ul><li><code>for...in</code> </li><li><code>Object.keys</code>：无法获取对象继承的属性，此时可以用 <code>getOwnPropertyNames</code></li><li><code>JSON.stringify</code></li></ul></li><li><p><code>configurable</code>：控制是否可以修改描述符属性，并且当 <code>configurable=fasle</code> 时，无法删除</p></li><li>判断对象是否为数组：<code>Array.isArray</code></li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul><li>JavaScript 中的对象体系，是基于构造函数 <code>constructor</code> 和原型链 <code>prototype</code> 的。构造函数就是对象生成的「模板」</li><li><p>构造函数特点：</p><ul><li>内部使用 <code>this</code>，指向生成的对象实例</li><li>需要配合 <code>new</code> 关键字</li></ul></li><li><p><code>new</code> 干了什么：</p><ul><li>新建空对象，作为要返回的对象</li><li>将空对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code></li><li>将该空对象赋值给函数内部的 <code>this</code> 关键字</li><li>执行构造函数中的代码</li></ul></li><li><p>函数内部可使用 <code>new.target</code> 判断是否使用了 <code>new</code> 调用构造函数</p></li><li><code>this</code> 在函数体内部，指向当前的运行环境</li><li>如果 <code>this</code> 所在的方法不在对象的第一层，这时 <code>this</code> 只是指向当前一层的对象，而不会继承更上面的层</li><li>函数实例的 <code>call</code> 方法可以指定 <code>this</code> 指向的环境，此外可以跳过同名函数覆盖，直接使用原始的函数；<code>appy</code> 和 <code>call</code> 类似，只是接收一个列表参数</li><li><code>bind</code> 也可以绑定对象，变换 <code>this</code> 指向</li><li>JS 继承机制的核心：原型中所有属性和方法都可以被多个实例共享</li><li><code>instanceof</code> 运算符：<ul><li>只能用于非原始类型对象</li><li>对象的原型 <code>prototype</code> 均为 null 时失效</li><li><code>undefined instanceof Object</code> 和 <code>null instanceof Object</code> 均为 <code>false</code></li></ul></li></ul><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><ul><li>Promise 的回调函数不是正常的异步任务，而是<strong>微任务</strong>。前者会追加到下一轮事件循环，而微任务则追加到本轮事件循环。所以微任务执行要早于常规异步任务。</li><li><code>setTimeout(f, 0)</code> 可以让任务在下轮事件循环中执行</li></ul><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul><li>元素的 <code>hidden</code> 属性只有在 CSS 没有明确设定当前元素的可见性时才会生效，也就是 CSS 的 <code>display</code> 用于可见性控制的优先级高于元素自身的 <code>hidden</code> 属性</li><li>网页元素可以自定义 <code>data-*</code> 属性，添加数据，可以使用 <code>.dataset</code> 返回数据对象</li><li>为防止遭受攻击，对于文本内容，建议使用 <code>textContent</code> 替代 <code>innerHTML</code> 设置文本</li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li>CSS 负责视觉效果；JavaScript 负责与用户的行为互动</li><li>可以通过 <code>style</code> 属性设置 CSS 样式</li><li><p><code>CSSStyleDeclaration</code> 对象用于操作元素的样式，包括：</p><ul><li>元素的 <code>style</code> 属性</li><li><code>CSSStyle</code> 实例的 <code>style</code> 属性</li><li><code>window.getComputedStyle()</code> 返回值（元素的全部样式需要它获取到）</li></ul></li><li><p>需要注意的是，<code>CSSStyleDeclaration</code> 的属性名和原生 CSS 还是有点区别，命名需要修改，如 <code>backgroud-color</code> -&gt; <code>backgroudColor</code>；如果是 JS 的保留字，则需要加上 <code>css</code> 前缀</p></li><li>属性操作：<ul><li><code>setProperty</code></li><li><code>removeProperty</code></li></ul></li></ul><h2 id="DOM-变动监控"><a href="#DOM-变动监控" class="headerlink" title="DOM 变动监控"></a>DOM 变动监控</h2><ul><li>Mutation Observer API：DOM 的变动（节点增减、属性变动、文本内容变动），都可以通过该 API 获得通知</li><li>与事件的区别：<ul><li>MO 事件是在 DOM 变动时异步触发，并且是等到当前所有 DOM 操作都结束才触发</li><li>事件则是同步触发，DOM 变动立刻触发</li></ul></li><li><p>总结来说：</p><ul><li>等待所有脚本任务完成后，才会触发</li><li>把 DOM 变动记录封装成一个数组处理，而非每条都分别处理</li><li>既可以观察 DOM 所有类型变动，也可以指定观察某类变动</li></ul></li><li><p>用法：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutations, observer</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定监听的元素和类型</span></span><br><span class="line"><span class="keyword">const</span> article = <span class="built_in">document</span>.querySelector(<span class="string">"article"</span>)</span><br><span class="line">observer.observe(article, &#123;<span class="string">'childList'</span>: <span class="literal">true</span>, <span class="string">'attritubes'</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><ul><li><p>DOM 的事件操作（监听、触发），都是 <code>EventTarget</code> 中定义的。主要接口如下：</p><ul><li><code>addEventListener</code></li><li><code>removeEventListener</code></li><li><code>dispatchEvent</code></li></ul></li><li><p>HTML 中可以直接在元素属性中，定义某些监听代码。如 <code>onload</code>，这类监听代码只在冒泡阶段触发</p></li><li>元素的 <code>onclick</code> 属性，也可以指定监听函数，并且在冒泡阶段触发</li><li>事件传播：<ul><li>第一阶段：从 <code>window</code> 对象传导到目标节点（上层传到底层），即为「捕获阶段」（capture phase）</li><li>第二阶段：从目标节点上触发，叫做「目标阶段」（target phase）</li><li>第三阶段：从目标节点传导回 <code>window</code> 对象（从底层传回上层），叫做「冒泡阶段」（bubbling phase）</li></ul></li><li><code>e.StopPropagation</code> 则是会阻止事件传播，但不会处理其它的监听事件</li><li><code>e.stopImmediatePropagation</code> 会彻底取消同名的时间</li><li>网页中除了元素节点默认不可以拖拉，其它（图片、链接、选中的文字）都是可以拖拉的，可通过将元素节点的 <code>draggable</code> 属性设置为 <code>true</code> 实现</li><li>一旦某个元素节点被设置为可拖拽后，就无法通过鼠标选中节点内部的文字或子节点了</li></ul><h1 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h1><ul><li>嵌入脚本时，<code>&lt;script&gt;</code> 元素的 <code>type</code> 属性默认为 <code>text/javascript</code>，新浏览器可以写成 <code>application/javascript</code>。当然，也可以不填写。另外，<code>integrity</code> 属性可以设置脚本的 SHA256 签名，对于非法脚本浏览器会拒绝加载</li><li><code>async</code> 和 <code>defer</code> 同时存在，则后者不起作用</li><li><code>window.navigator</code> 指向包含浏览器和系统信息的 <code>Navigator</code> 对象，可以了解用户的环境信息</li><li>Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不超过 4KB，每次请求服务器，都会附带该信息</li><li><p>Cookie 包括的信息：</p><ul><li>名字</li><li>值</li><li>到期时间</li><li>所属域名（默认当前域名）</li><li>生效的路径（默认当前网站）</li></ul></li><li><p><strong>浏览器的安全基础是「同源政策」（same-origin policy）</strong></p></li><li><p>同源的含义：</p><ul><li>相同的协议</li><li>相同的域名</li><li>相同的端口</li></ul></li><li><p>非同源的限制：</p><ul><li>无法读取非同源网页的 Cookie, LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求（即便发送，浏览器也会拒绝接受响应）</li></ul></li><li><p><code>document.domain</code> 设置可共享 Cookie，适用于 ifame 和 Cookie，对于 LocalStorage 和 IndexedDB 无效；此外，服务器可以在设置 Cookie 时就指定好所属一级域名：<code>.example.com</code>，也可以对子域名达到共享 Cookie 的目的</p></li><li><p>对于完全不同源的窗口，想要通信有两种方式：</p><ul><li><code>fragment identifier</code>：片段标识符。<code>http://example.com/x.html#fragment</code> 只是改变 <code>#fragment</code> 不会导致网页刷新，属于破解无法通信之法</li><li>H5 提供了新的 <code>postMessage</code> 方法发送消息，监听方可以监听 <code>message</code> 事件获取消息</li></ul></li><li><p>AJAX 突破同源限制的方法：</p><ul><li>JSONP</li><li>WebSocket</li><li>CORS (Cross-Origin Resource Sharing)</li></ul></li><li><p>CORS 通信：</p><ul><li>W3C 标准，允许浏览器跨域请求</li><li><a href="https://wangdoc.com/javascript/bom/cors.html" target="_blank" rel="noopener">详细介绍</a></li><li>区分简单请求和非简单请求，流程不同</li><li>简单请求中，Origin Header 很重要</li><li>非简单请求，先进行 <code>/OPTIONS</code> 预先检查，然后后续流程类似简单请求</li></ul></li><li><p>Storage 接口：</p><ul><li><code>sessionStorage</code>：保存的数据用于浏览器一次会话，结束后会被清理</li><li><code>localStorage</code> 保存数据长期存在</li><li>只有同域名下的网页才可以读取，跨域会报错</li><li><code>length</code> 返回数据项个数</li><li><code>setItem</code> 保存 key + value</li><li><code>getItem</code> 返回保存的 key 对应的 value</li><li><code>clear</code></li><li><code>key</code> 返回对应位置的键值 </li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://wangdoc.com/javascript/events/eventtarget.html" target="_blank" rel="noopener">JavaScript 入门</a></li></ul><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">MDN JavaScript</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近抽空学习了下 JavaScript 语言，当然还是入门级别的那种。学习过程中也做了些笔记。总的来说，ES5 学完后，对 JavaScript 本身了解了大概，语言本身设计上也存在一些坑，所以搭配《JavaScript 精粹》这本书看看，可以进一步了解有哪些比较好的写法避免踩坑。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ifaceless.space/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://ifaceless.space/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://ifaceless.space/tags/JavaScript/"/>
    
      <category term="ES5" scheme="http://ifaceless.space/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Rocket Web 框架入门</title>
    <link href="http://ifaceless.space/2019/02/24/rust-rocket-quick-start/"/>
    <id>http://ifaceless.space/2019/02/24/rust-rocket-quick-start/</id>
    <published>2019-02-24T15:23:30.000Z</published>
    <updated>2019-06-24T00:49:40.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="https://rocket.rs/" target="_blank" rel="noopener">Rocket 框架</a> 是 Rust 生态中比较流行的 Web 框架之一，其最大的特点是拥有类似 Flask 那样比较简洁的写法，可以非常轻松地编写 RESTful API，同时还支持中间件等机制，易于扩展。当然，目前该框架最大的缺点是使用了很多 rust-nightly 版本中的特性，导致无法在 rust-stable 分支下编译。这对于一个需要长期维护的较大的项目来说，就存在一定的升级风险。不过鉴于目前我们不大可能在生产环境中使用 Rust 来编写 Web API，暂且还不用担心这些问题。</p><a id="more"></a><h1 id="你好，Rocket"><a href="#你好，Rocket" class="headerlink" title="你好，Rocket"></a>你好，Rocket</h1><p><em>需要说明的是，下面的示例代码是在 <code>rustc 1.34.0-nightly</code> 环境下编译并运行的~</em></p><p>首先，需要新建项目 <code>hello-rocket</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello-rocket --bin</span><br></pre></td></tr></table></figure></p><p>由于需要使用 rust-nightly 版本，所以这里需要切换版本并更新工具链。方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将当前项目环境切到 nightly 版本</span><br><span class="line">rustup override set nightly &amp;&amp; rustup update</span><br></pre></td></tr></table></figure></p><p>准备工作完成后，我们就需要给项目添加 <code>rocket</code> crate 依赖啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo add rocket</span><br></pre></td></tr></table></figure><p>可以在 <code>Cargo.toml</code> 中看到添加的依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rocket</span> = <span class="string">"0.4.0"</span></span><br></pre></td></tr></table></figure><p>接下来，我们在 <code>main.rs</code> 中编写一个最简单的 API，负责在访问对应路由时打印出 <code>Hello, Rocket</code>。可以将下面的代码粘贴到你的文件中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(proc_macro_hygiene, decl_macro)]</span></span><br><span class="line"><span class="comment">// 我们需要使用 rocket 中定义的路由创建宏 `routes!`</span></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rocket;</span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="string">"Hello, Rocket"</span>.to_string()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    rocket::ignite().mount(<span class="string">"/"</span>, routes![index]).launch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就完成了一个最简单的 API 编写。最后编译并启动 Web 服务后，可以在终端中看到下面的输出。你可以在浏览器中访问 <code>localhost:8000</code> 来查看响应内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Configured for development.</span><br><span class="line">    =&gt; address: localhost</span><br><span class="line">    =&gt; port: 8000</span><br><span class="line">    =&gt; log: normal</span><br><span class="line">    =&gt; workers: 8</span><br><span class="line">    =&gt; secret key: generated</span><br><span class="line">    =&gt; limits: forms = 32KiB</span><br><span class="line">    =&gt; keep-alive: 5s</span><br><span class="line">    =&gt; tls: disabled</span><br><span class="line">Mounting /:</span><br><span class="line">    =&gt; GET / (index)</span><br><span class="line">Rocket has launched from http://localhost:8000</span><br></pre></td></tr></table></figure><h1 id="Rocket-的特性"><a href="#Rocket-的特性" class="headerlink" title="Rocket 的特性"></a>Rocket 的特性</h1><p>在其官网的 Overview 中，可以看到 Rocket 框架的主要特性。</p><h2 id="路由（Routing）"><a href="#路由（Routing）" class="headerlink" title="路由（Routing）"></a>路由（Routing）</h2><p>Rocket 的主要任务便是路由请求到合适的请求处理 Handler。路由是通过 <code>get</code> 属性声明的，看起来像是 Python 中的装饰器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; &amp;<span class="symbol">'static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="string">"Hello, Rocket!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的代码块为例，这个路由的名称为 <code>index</code>，和 <code>HTTP GET /</code> 匹配。请求处理函数会返回一个字符串作为 HTTP 响应的 body。</p><h2 id="动态参数（Dynamic-Params）"><a href="#动态参数（Dynamic-Params）" class="headerlink" title="动态参数（Dynamic Params）"></a>动态参数（Dynamic Params）</h2><p>Rocket 可以动态地识别请求路径多个部分，并和处理函数的参数一一匹配，示例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[get(<span class="meta-string">"/hello/&lt;name&gt;/&lt;age&gt;"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: <span class="built_in">String</span>, age: <span class="built_in">u8</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Hello, &#123;&#125; year old, named &#123;&#125;!"</span>, age, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例表示，<code>hello</code> 路由会动态匹配到路径中的 <code>&lt;name&gt;</code> 和 <code>&lt;age&gt;</code> 部分。每个动态参数都要有具体的类型，Rocket 会尝试将 <code>path</code> 中对应位置的参数转换为目标类型。只有参数正确转换后，才会调用相应的路由处理函数。为了解析字符串，Rocket 会使用 <code>FromParam</code> trait，你也可以为自定义类型实现该 trait。</p><h2 id="请求数据处理（Handling-Data）"><a href="#请求数据处理（Handling-Data）" class="headerlink" title="请求数据处理（Handling Data）"></a>请求数据处理（Handling Data）</h2><p>请求的 body 数据是通过 <code>FromData</code> trait 来处理的。请求的 body 数据可以派生任何实现了 <code>FromData</code> 的类型。你可以像下面这样指定期望通过哪个参数使用请求的 body：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[post(<span class="meta-string">"/login"</span>, data = <span class="meta-string">"&lt;user_form&gt;"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">login</span></span>(user_form: Form&lt;UserLogin&gt;) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, user_form.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Form</code> 类型是 Rocket 内建的类型，它可以将 Web 表单转换成结构体。Rocket 会自动尝试将请求的 body 数据转换成 <code>Form</code>，然后在转换成功后调用 <code>login</code> 处理函数。其它内建的 <code>FormData</code> 类型还有 <code>Data</code>、<code>Json</code> 和 <code>Flash</code>。</p><h2 id="请求护卫（Request-Guards）"><a href="#请求护卫（Request-Guards）" class="headerlink" title="请求护卫（Request Guards）"></a>请求护卫（Request Guards）</h2><p>除了动态路径和数据参数外，请求处理函数还可以包含第三种类型的参数：<em>request guards</em>。<em>Request guards</em> 不用在路由属性中声明，而是出现在请求处理函数的参数签名中，并且支持任意多个。</p><p><em>Request guards</em> 的作用是对请求的元信息进行判断，如果满足指定条件，才运行处理函数，起到保护作用。比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[get(<span class="meta-string">"/sensitive"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sensitive</span></span>(key: ApiKey) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中 <code>ApiKey</code> 用于保护 <code>sensitive</code> 处理函数，只有在请求头中的 API 密钥认证通过后，才会执行。<code>ApiKey</code> 类型需要过实现 <code>FromRequest</code> trait，然后在实现逻辑中检查 API 密钥头。<em>Request guards</em> 是 Rocket 中非常强大且独特的概念。</p><h2 id="响应（Responder）"><a href="#响应（Responder）" class="headerlink" title="响应（Responder）"></a>响应（Responder）</h2><p>请求处理函数的返回类型可以是任何实现了 <code>Responder</code> 的类型：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>() -&gt; T &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>上述例子中，<code>T</code> 必须要实现 <code>Responder</code>。Rocket 已经为标准库中很多类型实现了 <code>Responder</code>：<code>&amp;str</code>、<code>String</code>、<code>File</code>、<code>Option</code> 以及 <code>Result</code>。Rocket 也实现了一些自定义的 <code>Responder</code>，如 <code>Redirect</code>、<code>Flash</code> 和 <code>Template</code>。</p><p><code>Responder</code> 的任务就是尽可能生成 <code>Response</code>，它也可以在失败时提供状态码。如果指定了状态码，Rocket 就会调用相应的错误捕获函数。<code>catch</code> 路由的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[catch(404)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">not_found</span></span>() -&gt; T &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="运行（Launching）"><a href="#运行（Launching）" class="headerlink" title="运行（Launching）"></a>运行（Launching）</h2><p>为了运行 Rocket 应用，首先需要挂载路由；然后才可以启动。示例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rocket::ignite()</span><br><span class="line">    .mount(<span class="string">"/base"</span>, routes![index, another])</span><br><span class="line">    .launch();</span><br></pre></td></tr></table></figure><p>调用 <code>launch</code> 后会启动服务器，开发环境中，Rocket 会打印出一些比较有用的状态信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">🚀  Rocket has launched from http:<span class="comment">//localhost:8000</span></span><br></pre></td></tr></table></figure><h1 id="Rocket-是如何工作的？"><a href="#Rocket-是如何工作的？" class="headerlink" title="Rocket 是如何工作的？"></a>Rocket 是如何工作的？</h1><p>每一个 Rocket Web 应用从接受到请求到进行响应，都会经历标准的三个步骤（这也是常规 Web 框架都会做的事情）。</p><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>首先，Rocket 会校验匹配的请求，确保处理函数中的每个类型都可以派生自当前请求。如果某个类型无法派生，则会定向到下一个匹配的路由，直到所有类型校验都没问题或者没有任何可尝试的路由为止。如果所有的路由都不匹配，则会返回自定义的 404 错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[post(<span class="meta-string">"/user"</span>, data = <span class="meta-string">"&lt;new_user&gt;"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_user</span></span>(admin: AdminUser, new_user: Form&lt;User&gt;) -&gt; T &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上述例子来说明：</p><ol><li>请求方法必须是 <code>POST</code></li><li>请求路径必须是 <code>/user</code></li><li>请求中必须包含 <code>body</code> 数据</li><li>请求的元信息必须是通过认证的 <code>AdminUser</code></li><li>请求体必须能够转换成 <code>User</code> 结构体</li></ol><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>接下来，请求会被任意的 Handler 处理。这里就是执行具体的业务逻辑了。Rocket 中的 Handler 就是简单的函数，唯一要注意的是返回值必须要是实现了 <code>Responder</code> trait 的类型。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>最后，Rocket 会将 Handler 返回值转换成 HTTP 响应，然后给客户端发送响应：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>() -&gt; T &#123;&#125;</span><br></pre></td></tr></table></figure><p>上述例子中的 <code>T</code> 必须是实现了 <code>Responder</code> 的类型，Rocket 目前提供了很多常用的响应类型：</p><ol><li><code>Json&lt;T&gt;</code>: 将类型 <code>T</code> 转换成 JSON 并返回</li><li><code>Template</code>: 渲染模板并返回</li><li><code>Redirect</code>: 返回合适的重定向响应</li><li><code>NamedFile</code>: 向客户端流传输指定的文件，<code>Content-Type</code> 设置为文件夹的扩展名</li><li><code>Stream</code>: 向客户端流传输任意 <code>Read</code> 值</li></ol><h1 id="更多扩展功能"><a href="#更多扩展功能" class="headerlink" title="更多扩展功能"></a>更多扩展功能</h1><p>Rocket 框架可插拔的特性能能够给你带来很多额外的特性，这些特性在其文档中有详细的介绍。</p><ol><li><a href="https://rocket.rs/v0.4/guide/responses/#templates" target="_blank" rel="noopener">模板</a></li><li><a href="https://rocket.rs/v0.4/guide/requests/#cookies" target="_blank" rel="noopener">Cookies</a></li><li><a href="https://rocket.rs/v0.4/guide/requests/#streaming" target="_blank" rel="noopener">流传输</a></li><li><a href="https://rocket.rs/v0.4/guide/configuration/#environment" target="_blank" rel="noopener">易于配置的开发环境</a></li><li><a href="https://rocket.rs/v0.4/guide/testing#testing" target="_blank" rel="noopener">内建单元测试工具</a></li><li><a href="https://rocket.rs/v0.4/guide/responses/#typed-uris" target="_blank" rel="noopener">类型安全的 URIs</a></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://rocket.rs/v0.4/overview/" target="_blank" rel="noopener">Rocket Overview</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://rocket.rs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rocket 框架&lt;/a&gt; 是 Rust 生态中比较流行的 Web 框架之一，其最大的特点是拥有类似 Flask 那样比较简洁的写法，可以非常轻松地编写 RESTful API，同时还支持中间件等机制，易于扩展。当然，目前该框架最大的缺点是使用了很多 rust-nightly 版本中的特性，导致无法在 rust-stable 分支下编译。这对于一个需要长期维护的较大的项目来说，就存在一定的升级风险。不过鉴于目前我们不大可能在生产环境中使用 Rust 来编写 Web API，暂且还不用担心这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Web 开发" scheme="http://ifaceless.space/categories/Web-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web" scheme="http://ifaceless.space/tags/Web/"/>
    
      <category term="Rust" scheme="http://ifaceless.space/tags/Rust/"/>
    
      <category term="Rocket" scheme="http://ifaceless.space/tags/Rocket/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 初探</title>
    <link href="http://ifaceless.space/2019/02/18/explore-thrift/"/>
    <id>http://ifaceless.space/2019/02/18/explore-thrift/</id>
    <published>2019-02-18T09:27:18.000Z</published>
    <updated>2019-11-28T09:41:31.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>知乎使用的 RPC 框架是基于 Thrift 构建的。自然就很有必要了解下 Thrift 是什么？如何使用？以及有什么最佳实践？</p><p>Thrift 官方是这样介绍自己的：</p><blockquote><p>Thrift is a software framework for scalable cross-language services development. It combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml.<br><a id="more"></a></p></blockquote><p>以下是 Thrift 协议栈示意图：</p><p><img src="./thrift-proto-stack.png" alt=""></p><ul><li><code>Input Code</code>：是依照 Thrift 语法编写的服务（包含变量、服务方法、异常等定义）</li><li><code>Generated Code</code>：使用 <code>thrift gen</code> 编译生成的指定某种语言的客户端代码，以便于在业务中调用服务的 RPC 接口<ul><li><code>Service Client</code></li><li><code>write()/read()</code></li></ul></li><li><code>TProtocol</code>：提供了可选的协议层</li><li><code>TTransport</code>：提供了满足不同需求的传输层服务</li></ul><h2 id="运行时库（Runtime-Library）"><a href="#运行时库（Runtime-Library）" class="headerlink" title="运行时库（Runtime Library）"></a>运行时库（Runtime Library）</h2><p>整个协议层和传输层都是运行时库的一部分。这就意味着，我们可以在上层定义好服务后，在需要的时候随时替换协议层或传输层，而无需重新编译生成客户端代码。</p><h3 id="协议层（Protocol-Layer）"><a href="#协议层（Protocol-Layer）" class="headerlink" title="协议层（Protocol Layer）"></a>协议层（Protocol Layer）</h3><p>协议层的主要作用是提供序列化和反序列化的能力，目前支持的类型如下：</p><ul><li><code>TBinaryProtocol</code>：直接二进制格式，数字会被编码成二进制，而非文本</li><li><code>TCompactProtocol</code>：异常高效、紧凑的数据编码格式</li><li><code>TDenseProtocol</code>：类似于 <code>TCompactProtocol</code>，但是在传输时会移除 meta 信息，而在接收时补回 meta 信息</li><li><code>TJSONProtocol</code>：使用 JSON 格式进行编码</li><li><code>TSimpleJSONProtocol</code>：使用 JSON 编码，且只用于写的协议。适用于脚本语言解析</li><li><code>TDebugProtocol</code>：使用人类友好的文本格式，便于调试</li></ul><h3 id="服务端支持"><a href="#服务端支持" class="headerlink" title="服务端支持"></a>服务端支持</h3><p>传输层负责读取和写入。目前支持的几种方式如下：</p><ul><li><code>TSocket</code>：使用阻塞式网络 IO 传输</li><li><code>TFramedTransport</code>：逐帧发送数据，每帧数据都在前面加上长度信息。对于使用非阻塞式的服务来说，需要使用这种传输方法</li><li><code>TFileTransport</code>：使用文件作为传送媒介</li><li><code>TMemoryTransport</code>：借助内容传输。Java 的实现中使用了一个简单的 <code>ByteArrayOutputStream</code> 来实现</li><li><code>TZlibTransport</code>：使用 <code>zlib</code> 压缩，可以和其它传输方式组合在一块</li></ul><h2 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h2><p><code>Processor</code> 将输入和输出协议作为参数。它负责从输入读取数据，通过用户自定义的 Handler 处理数据，然后再将数据写到输出。</p><h2 id="支持的服务模式（Supported-Servers）"><a href="#支持的服务模式（Supported-Servers）" class="headerlink" title="支持的服务模式（Supported Servers）"></a>支持的服务模式（Supported Servers）</h2><p>服务器自然是用于在指定端口监听请求，并将接收到的数据发送到 <code>Processor</code> 处理。有这么几种服务可以用使用：</p><ul><li><code>TSimpleServer</code>：单线程阻塞 IO，方便测试</li><li><code>ThreadPoolServer</code>：多线程阻塞 IO</li><li><code>TNonblockingServer</code>：多线程非阻塞 IO，需要使用 <code>TFramedTransport</code> 传输方式</li></ul><h1 id="Thrift-语言指南"><a href="#Thrift-语言指南" class="headerlink" title="Thrift 语言指南"></a>Thrift 语言指南</h1><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>Thrift 类型系统主要包括如下几个部分：</p><ul><li>预定义的基本类型</li><li>用户定义的结构体</li><li>容器类型</li><li>异常</li><li>服务</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li><code>bool</code>：布尔类型（可选值 <code>true</code> 或 <code>false</code>），占用一个字节</li><li><code>byte</code>：有符号单字节</li><li><code>i16</code>：16 位有符号整型</li><li><code>i32</code>：32 位有符号整型</li><li><code>i64</code>：64 位有符号整型</li><li><code>double</code>：64 位浮点数类型</li><li><code>binary</code>：字节串</li><li><code>string</code>：编码未知文本或二进制字符串</li></ul><p>需要注意的是，Thrfit 并不支持无符号整数，因为在很多编程语言中并没有直接的映射。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li><code>list&lt;T&gt;</code>：列表，类似 Python 中的 <code>list</code></li><li><code>set&lt;T&gt;</code>：无序集合</li><li><code>map&lt;K, V&gt;</code>：字典，类似 Python 中的 <code>dict</code></li></ul><p>容器使用的类型可以是任意合法的 Thrfit 类型（如结构体、异常等），但「服务」除外。</p><h3 id="结构体与异常"><a href="#结构体与异常" class="headerlink" title="结构体与异常"></a>结构体与异常</h3><p>Thrift 结构体定义类似 C 语言中的 <code>struct</code>，对于某些 OO 语言，结构体会被翻译成 Class。</p><p>异常的定义类似结构体，可以包含不同的字段组成，但是用 <code>exception</code> 关键字。我们在定义服务 RPC 时，可以让某些方法抛出异常（如资源未找到）。</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务的定义类似 OO 编程中定义的 <code>interface</code>，或者 Rust 中的 <code>trait</code>。Thrift 编译器会生成完整的实现了接口的客户端和服务端桩（Stub）。</p><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef i32 int</span><br><span class="line">typedef Tweet ReTweet</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>类 C 的枚举定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum TweetType &#123;</span><br><span class="line">    TWEET,</span><br><span class="line">    RETWEET = 2,</span><br><span class="line">    DM = 0xa,</span><br><span class="line">    REPLY </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，不像 Protocol Buffers，Thrift 还不支持嵌套 Enum 定义（或者嵌套结构体），枚举值必须是 32 位正整数。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是合法的注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 多行注释，类似 C 语言支持的那样</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 单行注释</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>Thrift 中的命名空间类似 C++ 中的那样，或者 Java 中的包的概念。由于每种语言都有自己的包管理机制（如 Python 有模块的概念），Thrift 允许针对不同的语言定制命名空间行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 翻译成 C++ `namespace com &#123; namespace example &#123; namespace project &#123;`</span><br><span class="line">namespace cpp com.example.project</span><br><span class="line"></span><br><span class="line">// 翻译成 Java 包就是 `package com.example.project`</span><br><span class="line">namespace java com.example.project</span><br></pre></td></tr></table></figure><h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><p>我们通常可以将 Thrift 定义拆分到多个文件中以便维护、复用，使用模块化的方式进行组织。Thrift 运行在一个文件中 <code>include</code> 其它文件。被 <code>include</code> 的文件会在当前目录或者使用 <code>-I</code> 编译标志指定的目录中查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include &quot;tweet.thrift&quot; // 注意没有 `;` 结尾</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">struct TweetSearchResult &#123;</span><br><span class="line">    1: list&lt;tweet.Tweet&gt; tweets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const i32 MAX_PROCS = 120;  // 分号是可选的</span><br><span class="line"></span><br><span class="line">// 也可以定义复杂类型的常量，支持结构体、字典等</span><br><span class="line">// 使用 JSON 的格式初始化</span><br><span class="line">const map&lt;string, string&gt; MAP_CONST = &#123;&quot;hello&quot;: &quot;world&quot;&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><p>在 Thrfit IDL (Interface Defenition Language) 中，结构体是基本的构建基石。结构体组合了多个字段，每个字段有独立的标识符，类型，名称以及可选的默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Location &#123;</span><br><span class="line">    1: required double latitude;</span><br><span class="line">    2: required double longitude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Tweet &#123;</span><br><span class="line">    1: required i32 user_id;</span><br><span class="line">    2: required string user_name;</span><br><span class="line">    3: required: string description;</span><br><span class="line">    4: optional: Location loc;</span><br><span class="line">    5: optional: string contry = &quot;China&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用 <code>required</code> 标记的字段，实例化时必须要赋值，否则会报错。对于 <code>optional</code> 字段，如果没有设置值，就不会在序列化时传输。如果 <code>optional</code> 字段设置了默认值，当解析结构体的时候会给相应字段赋予默认值。</p><p>不同于服务，结构体是不允许继承的，也就是说不允许扩展自其它结构体。</p><blockquote><h4 id="Required-Is-Forever"><a href="#Required-Is-Forever" class="headerlink" title="Required Is Forever"></a>Required Is Forever</h4><p>在将一个字段设置为 <code>required</code> 之前一定要三思啊！如果你想在什么时候停止发送某个 <code>required</code> 字段时（如设置为 <code>optional</code>），就很容易出问题：旧版本的读取器会认为没有原先 <code>required</code> 字段的消息是不完整的，可能会拒绝甚至无意中丢弃掉。所以这时可能就需要编写特定的自定义校验逻辑来解决问题。有些人认为使用 <code>required</code> 弊大于利；他们更喜欢只用 <code>optional</code>。然而，这个也是因人而异，看场景需要的了。</p></blockquote><h3 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h3><p>虽然已经有很多流行的<strong>序列化/反序列化</strong>框架（如 Protocol Buffers）了，但很少有框架提供开箱即用的跨语言 RPC 服务的支持，这也是 Thrift 最主要的亮点之一。</p><p>可以把服务定义当做 Java 中的接口定义，你需要提供相应的方法名称、签名等；此外，服务也可以扩展自其它服务（使用 <code>extends</code> 关键字）。</p><p>Thrift 编译器会根据选择的目标编程语言生成相应的接口代码（Server 端）以及 Stubs（客户端）。Thrift 为大多数语言提供了用于运行客户端和服务端的 RPC 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service Twitter &#123;</span><br><span class="line">    // 方法定义格式类似 C 语言。需要指定返回类型、参数列表，可能会抛的异常列表</span><br><span class="line">    // 需要注意的是参数列表和异常列表使用的定义方式类似结构体字段定义</span><br><span class="line">    void ping();</span><br><span class="line">    // 看到没，也可以使用逗号结尾</span><br><span class="line">    // 不过还是建议使用分号吧</span><br><span class="line">    bool post_tweet(1: Tweet tweet) throws (1: TwitterUnavailable unavailable), </span><br><span class="line">    TweetSearchResult search_tweets(1: string query);</span><br><span class="line">    </span><br><span class="line">    // `async` 表示客户端尽管请求，而无需等待其响应。这种方法必须是 `void`</span><br><span class="line">    async void zip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h1><p>在前面的 <a href="#thrift-protocol-stack-overview">协议栈</a> 小节对整个 Thrift 协议栈有了概括性的了解，接下来将从代码生成的角度讲讲 Thrift 协议栈。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>以下是 Thrift 网络栈的概念图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">| cGRE                                      |</span><br><span class="line">| Server                                    |</span><br><span class="line">| (single-threaded, event-driven etc)       |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| cBLU                                      |</span><br><span class="line">| Processor                                 |</span><br><span class="line">| (compiler generated)                      |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| cGRE                                      |</span><br><span class="line">| Protocol                                  |</span><br><span class="line">| (JSON, compact etc)                       |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| cGRE                                      |</span><br><span class="line">| Transport                                 |</span><br><span class="line">| (raw TCP, HTTP etc)                       |</span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p>传输层提供了网络读写的简单抽象，这样可以将底层的传输和系统其它部分解耦开来（如序列化、反序列化等）。<br>以下是 <code>Transport</code> 接口提供的方法：</p><ul><li><code>open</code></li><li><code>close</code></li><li><code>read</code></li><li><code>write</code></li><li><code>flush</code></li></ul><p>除了 <code>Transport</code> 接口，Thrift 也使用了 <code>ServerTransport</code> 接口接收或创建原始的传输对象。顾名思义，<code>ServerTransport</code> 主要用于服务端为进入的连接创建 <code>Transport</code> 对象。其提供的方法如下：</p><ul><li><code>open</code></li><li><code>listen</code></li><li><code>accept</code></li><li><code>close</code></li></ul><p>以下是大部分 Thrift 支持的语言都会提供的传输方式：</p><ul><li><code>file</code>: 从磁盘这两个读取或写入</li><li><code>http</code></li></ul><h3 id="协议层（Protocol-Layer）-1"><a href="#协议层（Protocol-Layer）-1" class="headerlink" title="协议层（Protocol Layer）"></a>协议层（Protocol Layer）</h3><p>协议抽象提供了将内存数据结构映射成传输格式的机制，也就是说，协议定义了数据类型如何利用底层的 Transport 层来编解码自己。因此，协议层实现负责 Schema 编码以及序列化/反序列化。常用的协议包括：JSON、XML、纯文本和压缩二进制等。</p><p>以下是 <code>Protocol</code> 接口定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">writeMessageBegin(name, type, seq)</span><br><span class="line">writeMessageEnd()</span><br><span class="line">writeStructBegin(name)</span><br><span class="line">writeStructEnd()</span><br><span class="line">writeFieldBegin(name, type, id)</span><br><span class="line">writeFieldEnd()</span><br><span class="line">writeFieldStop()</span><br><span class="line">writeMapBegin(ktype, vtype, size)</span><br><span class="line">writeMapEnd()</span><br><span class="line">writeListBegin(etype, size)</span><br><span class="line">writeListEnd()</span><br><span class="line">writeSetBegin(etype, size)</span><br><span class="line">writeSetEnd()</span><br><span class="line">writeBool(bool)</span><br><span class="line">writeByte(byte)</span><br><span class="line">writeI16(i16)</span><br><span class="line">writeI32(i32)</span><br><span class="line">writeI64(i64)</span><br><span class="line">writeDouble(double)</span><br><span class="line">writeString(string)</span><br><span class="line"></span><br><span class="line">name, type, seq = readMessageBegin()</span><br><span class="line">                  readMessageEnd()</span><br><span class="line">name = readStructBegin()</span><br><span class="line">       readStructEnd()</span><br><span class="line">name, type, id = readFieldBegin()</span><br><span class="line">                 readFieldEnd()</span><br><span class="line">k, v, size = readMapBegin()</span><br><span class="line">             readMapEnd()</span><br><span class="line">etype, size = readListBegin()</span><br><span class="line">              readListEnd()</span><br><span class="line">etype, size = readSetBegin()</span><br><span class="line">              readSetEnd()</span><br><span class="line">bool = readBool()</span><br><span class="line">byte = readByte()</span><br><span class="line">i16 = readI16()</span><br><span class="line">i32 = readI32()</span><br><span class="line">i64 = readI64()</span><br><span class="line">double = readDouble()</span><br><span class="line">string = readString()</span><br></pre></td></tr></table></figure><p>Thrift 协议层采用面向流（Stream Oriented）的设计。例如，没必要在知道字符串或列表中的元素数量的长度的情况下，才可以序列化它们。</p><p>以下是 Thrift 支持的语言中通常会提供的协议：</p><ul><li><code>binary</code></li><li><code>compact</code></li><li><code>json</code></li></ul><h3 id="处理器（Processor）"><a href="#处理器（Processor）" class="headerlink" title="处理器（Processor）"></a>处理器（Processor）</h3><p>Processor 对于从输入流读取数据和写出到输出流操作做了封装，输入和输出流使用 <code>Protocol</code> 对象表示。接口定义非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface TProcessor &#123;</span><br><span class="line">    bool process(TProtocol in, TProtocol out) throws TException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器（Server）"><a href="#服务器（Server）" class="headerlink" title="服务器（Server）"></a>服务器（Server）</h3><p>服务器包含如下功能：</p><ol><li>创建 Transport</li><li>为 Transport 创建输入、输出 Protocols</li><li>基于输入输出 Protocols 创建一个 Processor</li><li>等待连接，并将它们丢给 Processor 处理</li></ol><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="版本化、兼容性考量"><a href="#版本化、兼容性考量" class="headerlink" title="版本化、兼容性考量"></a>版本化、兼容性考量</h2><p>协议随着时间会不断进化的。如果现有的消息类型不再满足当前需求（例如希望给某个结构体新增一个字段）时，但是希望旧版本格式生成的代码继续兼容（向前兼容），不要担心！你可以非常轻松地更新协议而不用担心破坏之前的任何代码。不过，前提是需要遵循一些规则：</p><ol><li>对于任何已有的字段，<strong>不要修改前面的 Tag Number</strong></li><li><p><strong>任何新增的字段都应标记为可选的</strong>。也就是说，使用旧版本消息格式生成的代码序列化的消息是可以被新生成的代码正确解析的，因为它们不会丢失任何必须的字段。对于这些字段应当设置合理的默认值，这样新的代码可以正确地与旧代码生成的消息交互。同样地，使用新代码生成的消息也可以被旧代码正确解析，只是忽略掉新增的字段。然而，未知字段并不会被遗弃，如果消息之后被序列化，未知字段还是会参与序列化的。因此，如果消息被发送到新版本代码，新增字段依然可用。</p></li><li><p>非必须的字段可以被移除掉，前提是 Tag Number 不要再次使用（推荐重命名废弃字段，可以添加 <code>OBSOLETE_</code> 前缀）</p></li></ol><h2 id="可能造成版本不匹配的情况分析"><a href="#可能造成版本不匹配的情况分析" class="headerlink" title="可能造成版本不匹配的情况分析"></a>可能造成版本不匹配的情况分析</h2><p><img src="./version-change-cases.jpg" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://thrift-tutorial.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">Thrift Tutorial</a></li><li><a href="https://diwakergupta.github.io/thrift-missing-guide/" target="_blank" rel="noopener">Thrift The Missing Guide</a></li><li><a href="https://thrift.apache.org/tutorial/" target="_blank" rel="noopener">Thrift docs</a></li><li><a href="http://thrift.apache.org/static/files/thrift-20070401.pdf" target="_blank" rel="noopener">Paper: Scalable Cross-Language Services Implementation</a></li><li><a href="http://jnb.ociweb.com/jnb/jnbJun2009.html" target="_blank" rel="noopener">Paper: Apache Thrift</a></li></ol><h1 id="竞争对手"><a href="#竞争对手" class="headerlink" title="竞争对手"></a>竞争对手</h1><ol><li><a href="https://labs.criteo.com/2017/05/serialization/" target="_blank" rel="noopener">Data Serialization Comparison</a></li><li><a href="https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html" target="_blank" rel="noopener">Schema evolution in Avro, Protocol Buffers and Thrift</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;知乎使用的 RPC 框架是基于 Thrift 构建的。自然就很有必要了解下 Thrift 是什么？如何使用？以及有什么最佳实践？&lt;/p&gt;
&lt;p&gt;Thrift 官方是这样介绍自己的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thrift is a software framework for scalable cross-language services development. It combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml.&lt;br&gt;
    
    </summary>
    
      <category term="Thrift" scheme="http://ifaceless.space/categories/Thrift/"/>
    
    
      <category term="Thrift" scheme="http://ifaceless.space/tags/Thrift/"/>
    
      <category term="RPC" scheme="http://ifaceless.space/tags/RPC/"/>
    
      <category term="序列化" scheme="http://ifaceless.space/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="反序列化" scheme="http://ifaceless.space/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Beanstalkd 源码初探</title>
    <link href="http://ifaceless.space/2019/02/04/learning-beanstalkd-source-code/"/>
    <id>http://ifaceless.space/2019/02/04/learning-beanstalkd-source-code/</id>
    <published>2019-02-04T10:22:05.000Z</published>
    <updated>2019-11-24T09:45:59.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Beanstalkd 是一个比较轻量级的消息队列服务，对于性能和稳定性要求不是特别高（相对于 RabbitMQ, Redis, Kafka 等），并且需要延迟执行任务的场景非常合适；此外，它也支持给任务设置不同的优先级、执行超时时间等。<br><a id="more"></a><br>在我们的业务中，经常会借助 Beanstalkd 执行队列任务，常见的用例如下：</p><ol><li>用户完成会员购买并激活后，发送私信通知、重置账号重命名状态等；</li><li>用户完成评论后，异步更新评论计数；</li><li>用户对私家课收听记录上报后，异步更新最近收听的小节、累积收听时长、同步到其它系统等；</li><li>用户记录添加后，会同步至 Redis，为保证数据库和 Redis 的数据最终一致性，会提前启动一个延迟校验的任务（如 5s 后），检查 Redis 中与数据库记录是否一致。</li></ol><h1 id="Beanstalkd-初识"><a href="#Beanstalkd-初识" class="headerlink" title="Beanstalkd 初识"></a>Beanstalkd 初识</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>基于 TCP 并采用 ASCII 编码的文本协议。详细定义参见：<a href="https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt" target="_blank" rel="noopener">protocol.txt</a>：<ol><li>客户端负责与服务端的交互：<strong>连接</strong>、<strong>发送命令和数据</strong>、<strong>等待响应</strong>、<strong>关闭连接</strong></li><li>服务端串行处理每个客户端连接</li><li>协议由两个部分组成：文本行（用于客户端命令和服务端响应）和非结构化的数据块（用于传送任务 body 和 stats 信息）</li></ol></li></ol><ol><li>队列消息是存储在内存中的，但用户可以选择开启 WAL 机制（binlog），这样重启后可以回放任务，提高了可用性</li><li>采用类似 Redis 的单线程模型（IO 多路复用机制），因此不必考虑多线程环境下线程同步、加锁等，简化实现</li></ol><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ol><li>Tube：类似 Kafka 中的 Topic，或者其它队列系统中的 Channel</li><li>Job：客户端生产和消费的基本单元。每个任务都有特定的 id，可设定优先级，超时时间，延迟执行时间等</li><li>WAL (Write Ahead Log)：负责 binlog 管理（写入、压缩、日志文件清理、任务恢复等）</li><li>Server：Beanstalkd 服务端</li><li>Conn：Beanstalkd 客户端连接处理</li></ol><h2 id="任务状态流转"><a href="#任务状态流转" class="headerlink" title="任务状态流转"></a>任务状态流转</h2><p><img src="./任务状态流转.png" alt="image.png"></p><h3 id="任务典型生命周期"><a href="#任务典型生命周期" class="headerlink" title="任务典型生命周期"></a>任务典型生命周期</h3><p><img src="./任务典型生命周期.png" alt="image.png"></p><h2 id="工作方式描述"><a href="#工作方式描述" class="headerlink" title="工作方式描述"></a>工作方式描述</h2><ol><li><strong>服务端</strong>会有一到多个 tubes（在数组中维护）。每个 tube 都会包含一个<strong>就绪队列</strong>（在最小堆维护）以及一个<strong>延迟队列</strong>（也在最小堆维护）。每个任务都会在一个特定的 tube 中度过全部的生命周期</li><li><strong>客户端</strong>可以使用 <code>watch</code> 指令订阅某个 tube，也可以使用 <code>ignore</code> 取消订阅，消费者可以同时订阅多个 tube，当消费者 <code>reserve</code> 任务时，该任务可能来自其 <code>watch list</code> 中的任意一个 tube</li><li>当客户端连接时，默认会使用 <code>default</code> tube，可以使用 <code>use</code> 切换 tube</li><li>tube 是会根据需要随时创建的，当没有客户端引用时，就会被删除</li></ol><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>借助 Docker 启动一个 Beanstalkd 服务非常轻松，请运行下面的命令行即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 11300:11300 schickling/beanstalkd</span><br></pre></td></tr></table></figure><p>如果上述命令行执行正常，则 Beanstalkd 服务应该启动了，其默认监听的端口号为 <code>11300</code>，运行 <code>docker ps</code> 可以查看服务是否正常启动并运行：</p><p><img src="./启动 beansktalkd.png" alt="image.png"></p><h1 id="编译-amp-运行-amp-调试"><a href="#编译-amp-运行-amp-调试" class="headerlink" title="编译 &amp; 运行 &amp; 调试"></a>编译 &amp; 运行 &amp; 调试</h1><p>首先，需要前往 <a href="https://github.com/beanstalkd/beanstalkd" target="_blank" rel="noopener">beanstalkd</a> 仓库克隆 Master 分支源码至本地。</p><p>为了方便管理 C 项目，这里使用了 JET BRAINS 家族的 <a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">Clion</a>。当然，你也可以使用自己喜欢的工具打开。</p><p>由于 Clion 使用了 <a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a> 管理 C&amp;C++ 项目，所以打开项目时需要在其根目录下创建一个 CMakeLists.txt 文件，并填写如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(beanstalkd C)</span><br><span class="line">set(BUILD_DIR .)</span><br><span class="line">add_custom_target(beanstalkd ALL COMMAND make WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)</span><br><span class="line">add_custom_command(TARGET beanstalkd POST_BUILD</span><br><span class="line">        COMMAND echo copy $&#123;PROJECT_NAME&#125; to $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">        COMMAND cp $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/beanstalkd $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>🎉 至此，准备工作已经做完啦。接下来，可以尝试点击「构建」按钮，进行编译。编译结束后，就可以点击运行启动 Beanstalkd 服务啦。哦，对了，如果需要调试支持的话，直接在需要的地方打上断点，并点击「调试」按钮即可开始。</p><p><img src="./编译与调试.png" alt="image.png"></p><h2 id="关于-Makefile"><a href="#关于-Makefile" class="headerlink" title="关于 Makefile"></a>关于 Makefile</h2><p>查看 Makefile 文件，可以看到有如下几个命令可以执行：</p><ol><li><code>make all</code>: 编译、链接并生成可执行的二进制文件 <code>beanstalkd</code>。由于我们已经将该命令放到 <code>CMakeLists.txt</code> 文件中，在使用 Clion 构建时可自动触发</li><li><code>make install</code>: 将生成的可执行文件 <code>beanstalkd</code> 安装到 <code>BINDIR=$(DESTDIR)/usr/local/bin</code> 目录下</li><li><code>make clean</code>: 清理生成的 <code>*.o</code> 文件</li><li><code>make bench</code>: 跑 Benchmark 用</li></ol><h1 id="客户端使用示例"><a href="#客户端使用示例" class="headerlink" title="客户端使用示例"></a>客户端使用示例</h1><p>下面看一个简单的例子。生产者负责将一组待抓取的 URLs 放到队列中，再由一组消费者并发访问队列中的 URLs。主流程的示例代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会首先启动 NUM_WORKERS 个消费者在不同的线程中监听</span></span><br><span class="line"><span class="comment">// 然后让生产者向队列中填充 URLs，供消费者使用</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> NUM_WORKERS: <span class="built_in">isize</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..NUM_WORKERS &#123;</span><br><span class="line">        <span class="comment">// 启动 NUM_WORKERS 个消费者</span></span><br><span class="line">        <span class="keyword">let</span> hd = thread::spawn(<span class="keyword">move</span> || consume_urls(i));</span><br><span class="line">        handles.push(hd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    produce_urls();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待消费者结束</span></span><br><span class="line">    <span class="keyword">for</span> hd <span class="keyword">in</span> handles &#123;</span><br><span class="line">        hd.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">produce_urls</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> client = Beanstalkd::localhost().unwrap();</span><br><span class="line">    client.tube(<span class="string">"urls"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> urls = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/ifaceless.github.io"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/gic"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/rust-exercises"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/learning-rust"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/fixture"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/rest"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/bigcache"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/leetgogo"</span>,</span><br><span class="line">        <span class="string">"https://github.com/iFaceless/freecache"</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls &#123;</span><br><span class="line">        client.put(url, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1000</span>).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consume_urls</span></span>(id: <span class="built_in">isize</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"[Consumer &#123;&#125;] started..."</span>, id);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> client = Beanstalkd::localhost().unwrap();</span><br><span class="line">    client.watch(<span class="string">"urls"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (job_id, url) = <span class="keyword">match</span> client.reserve() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(job) =&gt; job,</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"[Consumer &#123;&#125;] error happens: &#123;&#125;"</span>, id, e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"[Consumer &#123;&#125;] got job &lt;&#123;&#125;&gt;: &#123;&#125;"</span>, id, job_id, url);</span><br><span class="line">        client.delete(job_id).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码探索"><a href="#源码探索" class="headerlink" title="源码探索"></a>源码探索</h1><h2 id="模块分类图"><a href="#模块分类图" class="headerlink" title="模块分类图"></a>模块分类图</h2><p>为了方便阅读源码，粗略地根据自己的理解给各个文件做了简单的分类：</p><p><img src="./模块分类.png" alt="image.png"></p><h2 id="模块-UML-图"><a href="#模块-UML-图" class="headerlink" title="模块 UML 图"></a>模块 UML 图</h2><p>虽说 Beanstalkd 的源码是使用 C 编写的，但是其中的设计思想依然可以从面向对象的角度来解释。比如模块化设计、接口设计、多态等。根据自己的理解，对其中的一些核心模块做了梳理，并绘制了一个简单的 UML 图来加深理解：</p><p><img src="./模块 UML.png" alt="image.png"></p><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p><strong>二叉堆（Heap）</strong> 是一种很常见的数据结构，本质上是一棵完全二叉树。其分为<strong>最大堆（也叫大根堆）</strong> 和 <strong>最小堆（也叫小根堆）</strong>：</p><ol><li>最大堆：根结点的键值是所有堆结点键值中最大者的堆</li><li>最小堆：根结点的键值是所有堆结点键值中最小者的堆</li></ol><p>在 <a href="https://github.com/beanstalkd/beanstalkd/blob/master/heap.c" target="_blank" rel="noopener">beanstalkd/heap.c</a> 是对最小堆的实现。那么，beanstalkd 中哪些地方用到了最小堆呢？</p><ol><li>Tube 中的延迟任务队列（最先到期的任务会在堆顶，这样可以在 O(1) 时间复杂度获取到）</li><li>Tube 中的就绪任务队列（基于优先级排列，优先级最高的任务会在堆顶）</li><li>Server 中的客户端连接队列（基于 tickat 时间排列）</li></ol><p>接下来，我们看看最小堆的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">heapinsert(Heap *h, <span class="keyword">void</span> *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容策略：2 倍长度</span></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;len == h-&gt;cap) &#123;</span><br><span class="line">        <span class="keyword">void</span> **ndata;</span><br><span class="line">        <span class="keyword">int</span> ncap = (h-&gt;len+<span class="number">1</span>) * <span class="number">2</span>; <span class="comment">/* allocate twice what we need */</span></span><br><span class="line"></span><br><span class="line">        ndata = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span>*) * ncap);</span><br><span class="line">        <span class="keyword">if</span> (!ndata) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(ndata, h-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)*h-&gt;len);</span><br><span class="line">        <span class="built_in">free</span>(h-&gt;data);</span><br><span class="line">        <span class="comment">// 指向新的位置</span></span><br><span class="line">        h-&gt;data = ndata;</span><br><span class="line">        <span class="comment">// 更新容量</span></span><br><span class="line">        h-&gt;cap = ncap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k = h-&gt;len;</span><br><span class="line">    h-&gt;len++;</span><br><span class="line">    <span class="built_in">set</span>(h, k, x);</span><br><span class="line">    siftdown(h, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">heapremove(Heap *h, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= h-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x = h-&gt;data[k];</span><br><span class="line">    h-&gt;len--;</span><br><span class="line">    <span class="comment">// 用原来的数组最后一位覆盖被删除的位置</span></span><br><span class="line">    <span class="built_in">set</span>(h, k, h-&gt;data[h-&gt;len]);</span><br><span class="line">    siftdown(h, k);</span><br><span class="line">    siftup(h, k);</span><br><span class="line">    h-&gt;rec(x, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">set</span>(Heap *h, <span class="keyword">int</span> k, <span class="keyword">void</span> *x)</span><br><span class="line">&#123;</span><br><span class="line">    h-&gt;data[k] = x;</span><br><span class="line">    <span class="comment">// 这里会去调用相应的回调函数</span></span><br><span class="line">    h-&gt;rec(x, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断位置 a 指向的对象是否小于 b 指向的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">less(Heap *h, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// h-&gt;less 是一个判断大小的回调</span></span><br><span class="line">    <span class="comment">// 其实要在面向对象的语言中，完全可以自定一个实现了比较大小的接口</span></span><br><span class="line">    <span class="comment">// 比如在 Rust 中，可以使用 `PartialEq` 限定...</span></span><br><span class="line">    <span class="keyword">return</span> h-&gt;less(h-&gt;data[a], h-&gt;data[b]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>在 C 语言标准库中是没有可变长度的数组实现的，所以在 <a href="https://github.com/beanstalkd/beanstalkd/blob/master/ms.c" target="_blank" rel="noopener">beanstalkd/ms.c</a> 实现了一种类似的数据结构，它具有如下特点：</p><ol><li><code>ms</code> 结构体维护一个可动态扩容的数组（**items）</li><li>扩容策略很粗暴，直接扩充为原来容量的两倍</li><li>插入的平均时间复杂度为 O(1)</li><li>删除的平均时间复杂度为 O(1)</li><li>由于删除时，会将尾部 item 替换掉被删除的 item，所以不能依赖数组中的元素顺序（顺序不保证和添加时一致）</li><li>删除 item 后，其实数组占用的内存空间还在（并没有动态缩容的策略）</li></ol><p>那具体在哪些地方用到了 <code>ms</code> 这种数据结构呢？梳理后，主要发现以下几处：</p><ol><li>全局的 <a href="https://github.com/beanstalkd/beanstalkd/blob/b5a6f7a23a368ffb31fbf48cdffe95541166d3fa/tube.c#L6" target="_blank" rel="noopener">Tube 列表</a></li><li>客户端连接的 <code>Conn</code> 中维护的 <a href="https://github.com/beanstalkd/beanstalkd/blob/b5a6f7a23a368ffb31fbf48cdffe95541166d3fa/dat.h#L296" target="_blank" rel="noopener">watch list</a></li><li>与 Tube 关联的<a href="https://github.com/beanstalkd/beanstalkd/blob/b5a6f7a23a368ffb31fbf48cdffe95541166d3fa/dat.h#L161" target="_blank" rel="noopener">等待连接（conns）列表</a></li></ol><p>下面看看其具体的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数组，并注册插入和移除的回调函数</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove)</span><br><span class="line">&#123;</span><br><span class="line">    a-&gt;used = a-&gt;cap = a-&gt;last = <span class="number">0</span>;</span><br><span class="line">    a-&gt;items = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;oninsert = oninsert;</span><br><span class="line">    a-&gt;onremove = onremove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制数组增长</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">grow(ms a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> **nitems;</span><br><span class="line">    <span class="comment">// 倍速增长：1, 2, 4, ...</span></span><br><span class="line">    <span class="keyword">size_t</span> ncap = (a-&gt;cap &lt;&lt; <span class="number">1</span>) ? : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    nitems = <span class="built_in">malloc</span>(ncap * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (!nitems) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧的数据拷贝到新开辟的空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(nitems, a-&gt;items, a-&gt;used * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="comment">// 释放旧的内存空间</span></span><br><span class="line">    <span class="built_in">free</span>(a-&gt;items);</span><br><span class="line">    <span class="comment">// 指向新的位置</span></span><br><span class="line">    a-&gt;items = nitems;</span><br><span class="line">    <span class="comment">// 更新数组容量</span></span><br><span class="line">    a-&gt;cap = ncap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组尾部插入新的 item</span></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">ms_append(ms a, <span class="keyword">void</span> *item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 按需扩展容量</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;used &gt;= a-&gt;cap) grow(a);</span><br><span class="line">    <span class="comment">// 扩容失败，就返回，也就是不能再新增 item 了</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;used &gt;= a-&gt;cap) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;items[a-&gt;used++] = item;</span><br><span class="line">    <span class="comment">// 如果有回调，则触发回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;oninsert) a-&gt;oninsert(a, item, a-&gt;used - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的 item</span></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">ms_delete(ms a, <span class="keyword">size_t</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= a-&gt;used) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    item = a-&gt;items[i];</span><br><span class="line">    <span class="comment">// 相当于把尾部 item 写到被删除的位置，并「缩容」</span></span><br><span class="line">    a-&gt;items[i] = a-&gt;items[--a-&gt;used];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* it has already been removed now */</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;onremove) a-&gt;onremove(a, item, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><img src="./字典.png" alt="image.png"></p><p>在 <a href="https://github.com/beanstalkd/beanstalkd/blob/master/job.c" target="_blank" rel="noopener">beanstalkd/job.c</a> 中，为了方便基于 <code>job_id</code> 快速定位到具体的任务，作者实现了一个字典数据结构。这里是和 job 耦合在一起实现的，根据对源码的分析，可以得出该字典数据结构的特点如下：</p><ol><li>采用基于 <code>job_id</code> 哈希取模的方式计算 <code>slot_id</code></li><li>使用链地址法解决哈希冲突</li><li>根据负载因子自动进行 rehash（进行扩容或缩容），扩容或者缩容的系数根据 <a href="https://github.com/beanstalkd/beanstalkd/blob/master/primes.c" target="_blank" rel="noopener">beanstalkd/primes.c</a> 设置</li><li>rehash 过程并没有采用类似 Redis 中渐进式 rehash 机制，而是阻塞式完成整个哈希表的 rehash 后才可以进行后续操作</li></ol><p>存放 job 及 rehash 的详细源码分析如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 存放一个 job</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">store_job(job j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    index = _get_job_hash_index(j-&gt;r.id);</span><br><span class="line"></span><br><span class="line">    j-&gt;ht_next = all_jobs[index]; <span class="comment">// 如果存在冲突，就采用链地址法</span></span><br><span class="line">    all_jobs[index] = j;</span><br><span class="line">    all_jobs_used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* accept a load factor of 4 */</span></span><br><span class="line">    <span class="comment">// 负载因子设置为 4，超过阈值时就会进行 rehash</span></span><br><span class="line">    <span class="comment">// 看起这里是阻塞的方式来进行 rehash 了，如果 hash 表太大，会被阻塞</span></span><br><span class="line">    <span class="comment">// 并没有使用类似 redis 那样渐进式 rehash 思路</span></span><br><span class="line">    <span class="keyword">if</span> (all_jobs_used &gt; (all_jobs_cap &lt;&lt; <span class="number">2</span>)) rehash(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持扩容和缩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">rehash(<span class="keyword">int</span> is_upscaling)</span><br><span class="line">&#123;</span><br><span class="line">    job *old = all_jobs;</span><br><span class="line">    <span class="comment">// 记录下旧的 hash 表容量，元素个数</span></span><br><span class="line">    <span class="keyword">size_t</span> old_cap = all_jobs_cap, old_used = all_jobs_used, i;</span><br><span class="line">    <span class="keyword">int</span> old_prime = cur_prime;</span><br><span class="line">    <span class="keyword">int</span> d = is_upscaling ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_prime + d &gt;= NUM_PRIMES) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur_prime + d &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_upscaling &amp;&amp; hash_table_was_oom) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cur_prime += d;</span><br><span class="line"></span><br><span class="line">    all_jobs_cap = primes[cur_prime];</span><br><span class="line">    all_jobs = <span class="built_in">calloc</span>(all_jobs_cap, <span class="keyword">sizeof</span>(job));</span><br><span class="line">    <span class="keyword">if</span> (!all_jobs) &#123; <span class="comment">// 针对扩容失败的处理，恢复原来的不变，但是标记 OOM</span></span><br><span class="line">        twarnx(<span class="string">"Failed to allocate %zu new hash buckets"</span>, all_jobs_cap);</span><br><span class="line">        hash_table_was_oom = <span class="number">1</span>;</span><br><span class="line">        cur_prime = old_prime;</span><br><span class="line">        all_jobs = old;</span><br><span class="line">        all_jobs_cap = old_cap;</span><br><span class="line">        all_jobs_used = old_used;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置 hash 表状态</span></span><br><span class="line">    all_jobs_used = <span class="number">0</span>;</span><br><span class="line">    hash_table_was_oom = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实就是把 Hash 表上所有的 jobs 全部映射到新的空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; old_cap; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (old[i]) &#123;</span><br><span class="line">            job j = old[i];</span><br><span class="line">            old[i] = j-&gt;ht_next;</span><br><span class="line">            j-&gt;ht_next = <span class="literal">NULL</span>;</span><br><span class="line">            store_job(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后把原来的内存空间释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (old != all_jobs_init) &#123;</span><br><span class="line">        <span class="built_in">free</span>(old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表这种数据结构在 Beanstalkd 实现中用得比较频繁，比如</p><ol><li><a href="https://github.com/beanstalkd/beanstalkd/blob/master/walg.c" target="_blank" rel="noopener">beanstalkd/walg.c</a> 中使用了单向链表的串联了一些列的日志文件（参见三个游标指针：<code>head</code>, <code>cur</code>, <code>tail</code>）</li><li><a href="https://github.com/beanstalkd/beanstalkd/blob/master/conn.c" target="_blank" rel="noopener">beanstalkd/conn.c</a> 使用双向链表连接了一些列被 <code>reserve</code> 的任务</li></ol><p>在 <a href="https://github.com/beanstalkd/beanstalkd/blob/master/job.c" target="_blank" rel="noopener">beastalkd/job.c</a>，可以看到任务双向链表实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">job_list_any_p(job head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next != head || head-&gt;prev != head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job</span><br><span class="line">job_remove(job j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!job_list_any_p(j)) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not in a doubly-linked list */</span></span><br><span class="line"></span><br><span class="line">    j-&gt;next-&gt;prev = j-&gt;prev;</span><br><span class="line">    j-&gt;prev-&gt;next = j-&gt;next;</span><br><span class="line"></span><br><span class="line">    j-&gt;prev = j-&gt;next = j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">job_insert(job head, job j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (job_list_any_p(j)) <span class="keyword">return</span>; <span class="comment">/* already in a linked list */</span></span><br><span class="line"></span><br><span class="line">    j-&gt;prev = head-&gt;prev;</span><br><span class="line">    j-&gt;next = head;</span><br><span class="line">    head-&gt;prev-&gt;next = j;</span><br><span class="line">    head-&gt;prev = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部分模块源码学习"><a href="#部分模块源码学习" class="headerlink" title="部分模块源码学习"></a>部分模块源码学习</h2><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">// 存放任务的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> <span class="title">list</span> = &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    progname = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 设置使用行缓存，表使用标准输出作为打印目标</span></span><br><span class="line">    <span class="comment">// 详细文档参见：https://linux.die.net/man/3/setlinebuf</span></span><br><span class="line">    <span class="comment">// 意思是，只有在满足一行（换行）时才输出</span></span><br><span class="line">    setlinebuf(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="comment">// 命令行处理</span></span><br><span class="line">    optparse(&amp;srv, argv + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pid %d\n"</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器端 socket 初始化等，返回一个指向 socket 的 file descriptor</span></span><br><span class="line">    r = make_server_socket(srv.addr, srv.port);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>) twarnx(<span class="string">"make_server_socket()"</span>), <span class="built_in">exit</span>(<span class="number">111</span>);</span><br><span class="line">    srv.sock.fd = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协议处理模块初始化</span></span><br><span class="line">    prot_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srv.user) su(srv.user);</span><br><span class="line">    set_sig_handlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srv.wal.use) &#123;</span><br><span class="line">        <span class="comment">// We want to make sure that only one beanstalkd tries</span></span><br><span class="line">        <span class="comment">// to use the wal directory at a time. So acquire a lock</span></span><br><span class="line">        <span class="comment">// now and never release it.</span></span><br><span class="line">        <span class="comment">// WAL 即 Write Ahead Log Directory，主要是记录日志用</span></span><br><span class="line">        <span class="comment">// 这里是要保证每次只能有一个 beanstalkd 实例使用 WAL 目录，防止相互写入冲突</span></span><br><span class="line">        <span class="comment">// 那估计以后就没法从 binlog 恢复任务了。。。</span></span><br><span class="line">        <span class="keyword">if</span> (!waldirlock(&amp;srv.wal)) &#123;</span><br><span class="line">            twarnx(<span class="string">"failed to lock wal dir %s"</span>, srv.wal.dir);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化任务链表（双向链表）</span></span><br><span class="line">        <span class="built_in">list</span>.prev = <span class="built_in">list</span>.next = &amp;<span class="built_in">list</span>;</span><br><span class="line">        <span class="comment">// 初始化 WAL，如果 log 中有任务，还要恢复回来，挂载到 job list</span></span><br><span class="line">        walinit(&amp;srv.wal, &amp;<span class="built_in">list</span>);</span><br><span class="line">        <span class="comment">// 回放任务执行</span></span><br><span class="line">        r = prot_replay(&amp;srv, &amp;<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (!r) &#123;</span><br><span class="line">            twarnx(<span class="string">"failed to replay log"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式启动 server，并监听请求，处理请求了</span></span><br><span class="line">    srvserve(&amp;srv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./启动流程.png" alt="image.png"></p><h3 id="serv-c"><a href="#serv-c" class="headerlink" title="serv.c"></a>serv.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">srvserve(Server *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    Socket *sock;</span><br><span class="line">    int64 period;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sockinit() == <span class="number">-1</span>) &#123;</span><br><span class="line">        twarnx(<span class="string">"sockinit"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;sock.x = s;</span><br><span class="line">    <span class="comment">// 指定回调，当接收到 `r` 事件后，就会触发这个回调</span></span><br><span class="line">    s-&gt;sock.f = (Handle)srvaccept;</span><br><span class="line">    <span class="comment">// Server 维护了关联的客户端连接（最小堆）</span></span><br><span class="line">    s-&gt;conns.less = (Less)connless;</span><br><span class="line">    s-&gt;conns.rec = (Record)connrec;</span><br><span class="line"></span><br><span class="line">    r = listen(s-&gt;sock.fd, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">        twarn(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    r = sockwant(&amp;s-&gt;sock, <span class="string">'r'</span>);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">        twarn(<span class="string">"sockwant"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 执行周期性的任务</span></span><br><span class="line">        <span class="comment">// 如果 tick 中执行的任务时间过久，会阻塞后面的 socket connection 处理</span></span><br><span class="line">        <span class="comment">// 严重会导致超时，而如果客户端重试过多，则回增加服务端负载</span></span><br><span class="line">        period = prottick(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮询是否有就绪的请求（rw），其实就是个适配器，将具体平台下返回的状态</span></span><br><span class="line">        <span class="comment">// 转换成统一的 `r`, `w`, `h`</span></span><br><span class="line">        <span class="comment">// Linux 使用 epoll 封装（参见 `linux.c`）</span></span><br><span class="line">        <span class="comment">// Unix 使用 kqueue 封装（参见 `darwin.c`）</span></span><br><span class="line">        <span class="keyword">int</span> rw = socknext(&amp;sock, period);</span><br><span class="line">        <span class="keyword">if</span> (rw == <span class="number">-1</span>) &#123;</span><br><span class="line">            twarnx(<span class="string">"socknext"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rw) &#123;</span><br><span class="line">            <span class="comment">// 如果轮询到需要处理的请求，则执行相应的回调 Handle</span></span><br><span class="line">            <span class="comment">// 注意，这里的回调依然在主线程中执行的，所以如果主线程被阻塞，就呵呵哒了</span></span><br><span class="line">            sock-&gt;f(sock-&gt;x, rw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tube-c"><a href="#tube-c" class="headerlink" title="tube.c"></a>tube.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 tube，这里需要给定 tube 名称</span></span><br><span class="line"><span class="comment">// 这里可以看到一个 tube 有几个比较重要的组成：</span></span><br><span class="line"><span class="comment">// 1. 维护就绪任务的堆</span></span><br><span class="line"><span class="comment">// 2. 维护延迟执行任务的堆</span></span><br><span class="line"><span class="comment">// 3. 维护处于 buried 状态的任务链表</span></span><br><span class="line"><span class="comment">// 4. 维护一个等待列表</span></span><br><span class="line">tube</span><br><span class="line">make_tube(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    tube t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间，用于存储 tube 结构体值</span></span><br><span class="line">    t = <span class="keyword">new</span>(struct tube);</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 tube 名称</span></span><br><span class="line">    t-&gt;name[MAX_TUBE_NAME_LEN - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(t-&gt;name, name, MAX_TUBE_NAME_LEN - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;name[MAX_TUBE_NAME_LEN - <span class="number">1</span>] != <span class="string">'\0'</span>) twarnx(<span class="string">"truncating tube name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ready 堆维护着一些已经就绪的 jobs，这里是指定按照 job 优先级的方式比较大小</span></span><br><span class="line">    <span class="comment">// 这样，这个堆顶就是优先级最高的 job</span></span><br><span class="line">    t-&gt;ready.less = job_pri_less;</span><br><span class="line">    <span class="comment">// delay 堆维护着一些被延迟执行的 jobs，这里是按照 job delay 时间比较大小</span></span><br><span class="line">    <span class="comment">// 这样，这个堆顶就是延迟时间最短的 job</span></span><br><span class="line">    t-&gt;delay.less = job_delay_less;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录 job 在堆上的位置</span></span><br><span class="line">    t-&gt;ready.rec = job_setheappos;</span><br><span class="line">    t-&gt;delay.rec = job_setheappos;</span><br><span class="line">    t-&gt;buried = (struct job) &#123; &#125;;</span><br><span class="line">    <span class="comment">// 使用链表维护着被 bury 掉的 job</span></span><br><span class="line">    t-&gt;buried.prev = t-&gt;buried.next = &amp;t-&gt;buried;</span><br><span class="line">    <span class="comment">// 初始化排队列表</span></span><br><span class="line">    ms_init(&amp;t-&gt;waiting, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 tube</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tube_free(tube t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实际就是从全局的 tubes 列表中移除该 tube</span></span><br><span class="line">    prot_remove_tube(t);</span><br><span class="line">    <span class="comment">// 释放就绪的任务</span></span><br><span class="line">    <span class="built_in">free</span>(t-&gt;ready.data);</span><br><span class="line">    <span class="comment">// 释放延迟的任务</span></span><br><span class="line">    <span class="built_in">free</span>(t-&gt;delay.data);</span><br><span class="line">    <span class="comment">// 清空等待列表</span></span><br><span class="line">    ms_clear(&amp;t-&gt;waiting);</span><br><span class="line">    <span class="comment">// 释放 tube 指向的内存</span></span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数：减引用</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">tube_dref(tube t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;refs &lt; <span class="number">1</span>) <span class="keyword">return</span> twarnx(<span class="string">"refs is zero for tube: %s"</span>, t-&gt;name);</span><br><span class="line"></span><br><span class="line">    --t-&gt;refs;</span><br><span class="line">    <span class="comment">// 没有引用后就可以释放该 tube 了</span></span><br><span class="line">    <span class="keyword">if</span> (t-&gt;refs &lt; <span class="number">1</span>) tube_free(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数：增加引用</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">tube_iref(tube t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">    ++t-&gt;refs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个 tube，然后注册到全局 tubes 列表</span></span><br><span class="line"><span class="keyword">static</span> tube</span><br><span class="line">make_and_insert_tube(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    tube t = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    t = make_tube(name);</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want this global tube list to behave like "weak" refs, so don't</span></span><br><span class="line"><span class="comment">     * increment the ref count. */</span></span><br><span class="line">    <span class="comment">// 这里是想让全局 tube 列表表现为弱引用，所这里并没有做增加引用的操作</span></span><br><span class="line">    r = ms_append(&amp;tubes, t);</span><br><span class="line">    <span class="comment">// 如果注册 tube 失败，减引用，必要的话会被释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> tube_dref(t), (tube) <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="job-c"><a href="#job-c" class="headerlink" title="job.c"></a>job.c</h3><p>在 Tube 中有两个最小堆数据结构分别存放被延迟的任何和就绪的任务，这两种使用的排序方式是不同的。我们看到在上面的 Tube 初始化时，给两个堆绑定了不同的比较大小的回调：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;ready.less = job_pri_less;</span><br><span class="line">t-&gt;delay.less = job_delay_less;</span><br></pre></td></tr></table></figure><p>以下可以看到具体的排序方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数，先基于优先级比较哪个小，再基于 id 比较哪个小</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">job_pri_less(<span class="keyword">void</span> *ax, <span class="keyword">void</span> *bx)</span><br><span class="line">&#123;</span><br><span class="line">    job a = ax, b = bx;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;r.pri &lt; b-&gt;r.pri) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;r.pri &gt; b-&gt;r.pri) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;r.id &lt; b-&gt;r.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，先基于到期时间比较哪个小，再基于 id 比较哪个小</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">job_delay_less(<span class="keyword">void</span> *ax, <span class="keyword">void</span> *bx)</span><br><span class="line">&#123;</span><br><span class="line">    job a = ax, b = bx;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;r.deadline_at &lt; b-&gt;r.deadline_at) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;r.deadline_at &gt; b-&gt;r.deadline_at) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;r.id &lt; b-&gt;r.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>整个 Beanstalkd 的核心的代码不过五千行左右，但这就实现了一个生产级别的消息队列，的确是很厉害。不过，也正因为其实现比较简单，所以也没有提供类似 Redis 的主从机制等。当然，在这篇文章中，并没有完整地剖析所有的模块实现，只是列出了个人比较感兴趣的模块；关于 binlog 管理的源码（比如垃圾回收，压缩，预留空间申请，任务恢复等）只是粗略地阅读了下，就不在此处献丑啦~</p><p>总的来说，对于单机消息队列实现感兴趣的同学还是推荐阅读下该系统的源码，可以学习其中的一些设计思想，实现思路等~</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.hulkdev.com/posts/think_in_beanstalkd" target="_blank" rel="noopener">beanstalkd 的一些看法</a></li><li><a href="https://github.com/beanstalkd/beanstalkd" target="_blank" rel="noopener">beanstalkd repo</a></li><li><a href="https://beanstalkd.github.io/" target="_blank" rel="noopener">beanstalkd docs</a></li><li><a href="https://segmentfault.com/a/1190000016067218" target="_blank" rel="noopener">消息队列 beanstalkd 源码详解</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86" target="_blank" rel="noopener">最大—最小堆</a></li></ol><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ol><li><a href="https://www.cnblogs.com/FG123/p/5256553.html" target="_blank" rel="noopener">Kqueue 与 Epoll 机制</a></li><li><a href="https://juejin.im/entry/59376d450ce4630057427d53" target="_blank" rel="noopener">从 0到 100——知乎架构变迁史</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;Beanstalkd 是一个比较轻量级的消息队列服务，对于性能和稳定性要求不是特别高（相对于 RabbitMQ, Redis, Kafka 等），并且需要延迟执行任务的场景非常合适；此外，它也支持给任务设置不同的优先级、执行超时时间等。&lt;br&gt;
    
    </summary>
    
      <category term="消息队列" scheme="http://ifaceless.space/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码阅读" scheme="http://ifaceless.space/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="消息队列" scheme="http://ifaceless.space/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="Beanstalkd" scheme="http://ifaceless.space/tags/Beanstalkd/"/>
    
  </entry>
  
</feed>
