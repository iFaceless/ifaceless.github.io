<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="referrer" content="no-referrer">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Rust,Async,">





  <link rel="alternate" href="/atom.xml" title="黑白之院" type="application/atom+xml">






<meta name="description" content="引言最近打算基于 Rust async-std 造轮子，自然是要熟悉下这个库。以下内容是根据 Rust async-std 官方文档翻译整理，当然也加入了部分自己的理解，有不到位的地方还请指点。 async-std 旨在简化异步编程，由于是模拟 Rust 标准库接口，所以熟悉标准库的话，使用起来也会非常舒服。目前 async-std 给我们提供了很多接口：文件系统、网络、计时器等等；它还提供了一个">
<meta name="keywords" content="Rust,Async">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust async-std 入门">
<meta property="og:url" content="http://ifaceless.space/2020/01/20/rust-async-std-intro/index.html">
<meta property="og:site_name" content="黑白之院">
<meta property="og:description" content="引言最近打算基于 Rust async-std 造轮子，自然是要熟悉下这个库。以下内容是根据 Rust async-std 官方文档翻译整理，当然也加入了部分自己的理解，有不到位的地方还请指点。 async-std 旨在简化异步编程，由于是模拟 Rust 标准库接口，所以熟悉标准库的话，使用起来也会非常舒服。目前 async-std 给我们提供了很多接口：文件系统、网络、计时器等等；它还提供了一个">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-01-21T03:45:37.518Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rust async-std 入门">
<meta name="twitter:description" content="引言最近打算基于 Rust async-std 造轮子，自然是要熟悉下这个库。以下内容是根据 Rust async-std 官方文档翻译整理，当然也加入了部分自己的理解，有不到位的地方还请指点。 async-std 旨在简化异步编程，由于是模拟 Rust 标准库接口，所以熟悉标准库的话，使用起来也会非常舒服。目前 async-std 给我们提供了很多接口：文件系统、网络、计时器等等；它还提供了一个">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ifaceless.space/2020/01/20/rust-async-std-intro/">





  <title>Rust async-std 入门 | 黑白之院</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黑白之院</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Valar Morghulis</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-收藏">
          <a href="/collection" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-star"></i> <br>
            
            收藏
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifaceless.space/2020/01/20/rust-async-std-intro/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iFaceless">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑白之院">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Rust async-std 入门</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-20T18:00:40+08:00">
                2020-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index">
                    <span itemprop="name">Rust</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近打算基于 Rust <a href="https://github.com/async-rs/async-std" target="_blank" rel="noopener">async-std</a> 造轮子，自然是要熟悉下这个库。以下内容是根据 Rust <a href="https://github.com/async-rs/async-std" target="_blank" rel="noopener">async-std</a> 官方文档翻译整理，当然也加入了部分自己的理解，有不到位的地方还请指点。</p>
<p><a href="https://github.com/async-rs/async-std" target="_blank" rel="noopener">async-std</a> 旨在简化异步编程，由于是模拟 Rust 标准库接口，所以熟悉标准库的话，使用起来也会非常舒服。目前 <code>async-std</code> 给我们提供了很多接口：文件系统、网络、计时器等等；它还提供了一个 <code>task</code> 模型，有点类似 Rust 标准库中的 <code>thread</code> 模块。此外，还有 <code>async/await</code> 风格的 <code>Mutex</code> 原语。</p>
<a id="more"></a>
<p>Rust 中有两种类型的 <code>Future</code>：</p>
<ol>
<li>源自<a href="https://doc.rust-lang.org/std/future/trait.Future.html" target="_blank" rel="noopener">标准库</a>的 <code>std::future::Future</code></li>
<li>源自 <a href="https://docs.rs/futures/0.3/futures/prelude/trait.Future.html" target="_blank" rel="noopener">futures-rs crate</a>  的 <code>futures::future::Future</code></li>
</ol>
<p>背景是这样的，<a href="https://docs.rs/futures/0.3/futures/prelude/trait.Future.html" target="_blank" rel="noopener">futures-rs crate</a>  中定义的 future 是 Future 类型最初的实现。Rust 为了支持 <code>async/await</code> 语法，就把核心的 <code>trait Future</code> 转移到了标准库中，也就是现在的 <code>std::future::Future</code>。所以，我们可以把 <code>std::future::Future</code> 看作是 <code>futures::future::Future</code> 的最小子集。</p>
<p>我们需要严格区分 <code>std::future::Future</code> 和 <code>futures::future::Future</code>，以及 <code>async-std</code> 是如何使用它们的。总的来说，普通的用户一般是不会和 <code>std::future::Future</code> 打交道的（除了使用 <code>.await</code> 调用）。通常只有实现 <code>Future</code> 的开发者才会关注 <code>std::future::Future</code> 的内部工作机制。过去很多在 <code>Future</code> 中定义的功能都被移动到了 <code>FuturesExt</code> 扩展 trait 中。所以，可以将 <code>futures</code> 库当作是核心 Rust 异步功能的扩展。</p>
<p>那么，上面一直提到的 Futures 究竟是何方神圣？又是怎么被执行的呢？简单来说，<strong>Futures 就是对于代码是如何运行的一种抽象</strong>，它们其实什么也不做。那么怎么推进执行并获得结果呢？答案是依靠执行器 <code>executor</code>，它会决定<strong>何时</strong>及<strong>如何</strong>执行你的 Futures。<code>async-std::task</code> 模块就为我们提供了这样的执行器接口。</p>
<h1 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h1><p>Rust 有个非常亮眼的特性叫<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">「无谓并发」</a>，也就是说我们在编写多线程应用时，可以在获得并发特性的同时，不用担心数据竞争的问题（编译器会在编译时就能检查到数据竞争的问题）。</p>
<p>Futures 是对<strong>计算</strong>的抽象，它们描述了「做什么（what）」，但是与「在哪儿（where）」、「什么时候（when）」执行是分开的。因此，我们的目标是将代码打散成小段的、可组合的行为，这样可以作为系统的一部分执行。接下来我们来看看什么是<strong>计算</strong>（compute things），并找到可以抽象的地方。</p>
<h2 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a>Send 和 Sync</h2><p>Rust 安全并发中有两个重要的抽象（Markers）：<code>Send</code> 和 <code>Sync</code>。下面来看看简单的介绍：</p>
<ul>
<li><code>Send</code> 标记的数据类型是可以安全地从一个计算（computation）<strong>转移到（moved）</strong>另外一个并发计算（所有权也同样被转移了，发送方将不能再访问它）。</li>
<li><code>Sync</code> 是指我们可以在并发环境中<strong>共享（sharing）</strong>数据。</li>
</ul>
<p>以上没有使用 <code>thread</code> 即线程这样的字眼，而是使用了抽象的 <code>computation</code>。<code>Send</code> 和 <code>Sync</code> 最强大的特点在于它为我们减轻了知道共享什么的负担。在实现时，我们只需要知道对于相应的数据类型采用什么分享方式即可。</p>
<p>关于 <code>Send</code> 和 <code>Sync</code> 的组合还有更多有趣的特性，可以参考 <a href="https://doc.rust-lang.org/stable/book/ch16-04-extensible-concurrency-sync-and-send.html" target="_blank" rel="noopener">Rust Book</a> 了解更多。</p>
<h2 id="什么是计算（computation）"><a href="#什么是计算（computation）" class="headerlink" title="什么是计算（computation）"></a>什么是计算（computation）</h2><p>所谓的计算（computation）是指一个可组合的操作序列，可以基于决策分支，可以一直推进运行到结束，最终返回结果或者错误。</p>
<h2 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h2><p>如上所述，<code>Send</code> 和 <code>Sync</code> 都是描述数据的；但应用程序可不止数据，我们还要知道如何计算出数据，由此引入了 <code>Futures</code>。我们可以看看 <code>Futures</code> 是怎么允许我们用自然语言表达要做的事情的，<code>Futures</code> 从这样的计划：</p>
<ul>
<li>Do X</li>
<li>If X succeeded, do Y</li>
</ul>
<p>变成了：</p>
<ul>
<li>Start doing X</li>
<li>Once X succeeds, start doing Y</li>
</ul>
<p>相比于告诉计算机要做什么，并且根据当前结果决定下一步做什么；延迟计算就是让我们告诉计算机要开始做什么，并响应<strong>未来</strong>可能发生的事件。</p>
<h2 id="从简单的例子开始"><a href="#从简单的例子开始" class="headerlink" title="从简单的例子开始"></a>从简单的例子开始</h2><p>下面的例子是从指定的文件中读取内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在任意时刻调用上面的函数，也很直观。问题是，一旦调用上述函数，控制权就会转移至被调用的函数直到其返回。需要说明的是，上述返回值描述的是过去。而过去存在的问题是：所有的决策都已经确定了。但也不是没有优点：返回的结果很明显，我们可以直接将程序过去计算的结果解包（unwrap）出来，然后决定如何使用它。</p>
<p>但我们还是想要抽象计算，并让别人选择如何运行它。所以我们需要一种类型，可以描述计算过程，但是又不执行它。👆 上面的函数只能让我们在调用前或者调用后执行操作。这其实并非预期的，我们希望能够在在运行的时候做点别的事情（实际上就是能够打断执行流）。当在并行编程时，这也剥夺了我们在第一个任务运行时启动另外一个并行任务的能力（这时控制权已经转移给正在执行的函数了）。</p>
<p>此处虽然可以引入线程，但是线程本身是非常特定的并发原语，而我们需要寻找的是一种<strong>抽象</strong>。具体来说，这样的抽象就是用来表示一个进行中的工作，会在未来产生结果。下面看看非完整定义的 <code>Future</code> trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="comment">// Ouput 是一个泛型，表示输出结果的泛型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="comment">// poll 方法会返回当前计算的状态，poll 方法会返回两种结果：</span></span><br><span class="line">    <span class="comment">// 1. `Poll::Ready`，表示计算结束</span></span><br><span class="line">    <span class="comment">// 2. `Poll::Pending`，表示计算尚未结束</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，我们可以通过 <code>poll()</code> 方法检查 <code>Future</code> 是否完成，如果已经完成，则返回对应的结果。显然，最简单的机制就是在循环中不断轮询；不过我们通常使用成熟的 runtime 来执行。<em>需要注意的是，在 <code>poll()</code> 返回 <code>Poll::Ready</code> 后，继续调用可能会有令人困惑的行为产生，具体可以参见 <a href="https://doc.rust-lang.org/std/future/trait.Future.html" target="_blank" rel="noopener">futures-docs</a></em>。</p>
<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p>实际上 <code>Future</code> 在 Rust 中已经存在一段时间了，只是直接构建和描述它们比较麻烦。因此，<code>async</code> 关键词就是我们的救星，下面的例子中演示了 <code>async-std</code> 搭配 <code>async/await</code> 重构上面的函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 标记函数体是一个延迟计算对象，当函数调用时，会产生一个 `Future&lt;Output = io::Result&lt;string&gt;&gt;`，</span></span><br><span class="line"><span class="comment">// 该值并非立即返回的结果 `io::Result&lt;String&gt;`，</span></span><br><span class="line"><span class="comment">//（准确地说，是产生了实现了 `Future&lt;Output = io::Result&lt;String&gt;&gt;` 的类型）。</span></span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(path).await?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents).await?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="await-干了什么"><a href="#await-干了什么" class="headerlink" title=".await 干了什么"></a><code>.await</code> 干了什么</h2><p>顾名思义，<code>.await</code> 表示等待请求行为（requested action）直到完成，然后才会继续后续的执行。准确的来说，<code>.await</code> 是一个标记，表示此处的代码将会等待直到 <code>Future</code> 产生结果。至于 Future 是怎么结束的，我们不用关心。<code>.await</code> 会让运行时掌控这段代码的执行，至于在计算结束时要执行哪些操作都由运行时来操心。当你编写的操作在后台完成时，它会回到标记点，继续后续的操作。所以这种模式也称为 <strong>事件驱动编程（evented programming）</strong>，因为我们在等待某些事件发生（如打开文件），并据此作出响应（比如开始读取内容）。</p>
<p>当有 2 个及以上这样的函数在同时运行时，我们的运行时系统就能够处理当前所有进行的事件了，避免了傻傻地等待。</p>
<h1 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h1><p>我们已经知道什么是 Futures 了，那具体怎么运行它们呢？这就是接下来要介绍的 <code>tasks</code> 模块要做的事情。下面看个简单的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::&#123;fs::File, io, prelude::*, task&#125;;</span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file: File = File::open(path).await?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents).await?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// `spawn` 方法接收一个 `Future`，并且在一个任务中执行它。</span></span><br><span class="line">    <span class="comment">// 该函数会返回 `JoinHanle`。</span></span><br><span class="line">    <span class="keyword">let</span> reader_task = task::spawn(async &#123;</span><br><span class="line">        <span class="comment">// 这里是一个异步块，必须要使用异步块才能调用异步函数，同时</span></span><br><span class="line">        <span class="comment">// 也会引导编译器将所有相关的指令包含进来。Rust 中所有的块</span></span><br><span class="line">        <span class="comment">// 都会返回一个值，而 `async` 块则返回的是类型为 </span></span><br><span class="line">        <span class="comment">// `Future` 的值</span></span><br><span class="line">        <span class="keyword">let</span> result = read_file(<span class="string">"data.csv"</span>).await;</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="literal">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s),</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">"Error reading &#123;:?&#125;"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Started task!"</span>);</span><br><span class="line">    task::block_on(reader_task);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Stopped task!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 的 Futures 有时也叫「冷（cold）」Futures，你需要运行它们的东西。为了运行一个 Future，可能还需要一些额外的记账工具：比如当前 Future 是否在运行中还是已经结束，在内存中的位置和当前的状态。这种记账逻辑就被抽象到了 <code>Task</code> 中。</p>
<p><code>Task</code> 类似于 <code>Thread</code>，但也有些许不同：它是由应用程序（用户空间）被调度，操作系统内核不会感知；一旦到了某个点需要等待，应用程序自己需要负责唤醒任务。<code>async_std</code> 的任务可以拥有名称和 ID。</p>
<p>当通过 <code>spawn</code> 生成任务后，会一直在后台运行。返回的 <code>JoinHandle</code> 本身是一个 Future，它会在 <code>Task</code> 运行结束后（run to conclusion）也会结束。类似 <code>threads</code> 和 <code>join</code> 函数，我们可以调用对 <code>JoinHandle</code> 调用 <code>block_on</code> 函数，从而阻塞程序（准确来说是调用线程被阻塞）直到其运行结束。</p>
<h2 id="Task-中是如何推进-Future-完成计算的呢？"><a href="#Task-中是如何推进-Future-完成计算的呢？" class="headerlink" title="Task 中是如何推进 Future 完成计算的呢？"></a>Task 中是如何推进 Future 完成计算的呢？</h2><p>通过简单阅读源码，可以在 <a href="https://github.com/async-rs/async-std/blob/d283352a9add80f722c272238c6f9e122976aedb/src/task/block_on.rs#L129" target="_blank" rel="noopener">src/task/block_on.rs</a> 看到执行的逻辑，当 Task 被调度执行时，对应的  <code>run</code> 函数也会被执行，进而推进 Future 中的计算逻辑直到完成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Blocks the current thread on a future's result.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;F, T&gt;(future: F) -&gt; T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: Future&lt;Output = T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    CACHE.with(|cache| &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> Poll::Ready(t) = future.as_mut().poll(cx) &#123;</span><br><span class="line">                <span class="comment">// Save the parker for the next invocation of `block`.</span></span><br><span class="line">                cache.set(<span class="literal">Some</span>(arc_parker));</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Yield a few times or park the current thread.</span></span><br><span class="line">            <span class="keyword">if</span> step &lt; <span class="number">3</span> &#123;</span><br><span class="line">                thread::yield_now();</span><br><span class="line">                step += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arc_parker.park();</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JoinHandle-是如何将任务结果返回的呢？"><a href="#JoinHandle-是如何将任务结果返回的呢？" class="headerlink" title="JoinHandle 是如何将任务结果返回的呢？"></a>JoinHandle 是如何将任务结果返回的呢？</h2><p>翻阅 <a href="https://github.com/async-rs/async-std/blob/d283352a9add80f722c272238c6f9e122976aedb/src/task/join_handle.rs#L15" target="_blank" rel="noopener">src/task/join_handle.rs</a> 源码得知，它其实也是一个实现了 <code>Future trait</code> 的对象，具体逻辑如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">JoinHandle</span></span>&lt;T&gt;(async_task::JoinHandle&lt;T, Task&gt;);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Future <span class="keyword">for</span> JoinHandle&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> Pin::new(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span>).poll(cx) &#123;</span><br><span class="line">            Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">            <span class="comment">// 如果是 None，表示任务 panic 或者被取消了</span></span><br><span class="line">            Poll::Ready(<span class="literal">None</span>) =&gt; <span class="built_in">panic!</span>(<span class="string">"cannot await the result of a panicked task"</span>),</span><br><span class="line">            <span class="comment">// 当任务结束，自然会拿到具体结果</span></span><br><span class="line">            Poll::Ready(<span class="literal">Some</span>(val)) =&gt; Poll::Ready(val),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>async_std</code> 中的 <code>JoinHandle</code> 实际是对 <code>async_task::JoinHandle</code> 的包装，我们可以深入看下具体是怎么从 Task 中取到结果的：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-task-1.1.0/src/join_handle.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A handle that awaits the result of a task.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// * `None` 表示任务被取消或者 panic 了</span></span><br><span class="line"><span class="comment">/// * `Some(result)` 表示任务结束，返回的结果 `result` 类型为 `R`</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">JoinHandle</span></span>&lt;R, T&gt; &#123;</span><br><span class="line">    <span class="comment">/// A raw task pointer.</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) raw_task: NonNull&lt;()&gt;,</span><br><span class="line">    <span class="comment">/// A marker capturing generic types `R` and `T`.</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) _marker: PhantomData&lt;(R, T)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Future <span class="keyword">for</span> JoinHandle&lt;R, T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">Option</span>&lt;R&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> ptr = <span class="keyword">self</span>.raw_task.as_ptr();</span><br><span class="line">        <span class="keyword">let</span> header = ptr <span class="keyword">as</span> *<span class="keyword">const</span> Header;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> state = (*header).state.load(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// If the task has been closed, notify the awaiter and return `None`.</span></span><br><span class="line">                <span class="keyword">if</span> state &amp; CLOSED != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">return</span> Poll::Ready(<span class="literal">None</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If the task is not completed, register the current task.</span></span><br><span class="line">                <span class="keyword">if</span> state &amp; COMPLETED == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务完成，提取结果</span></span><br><span class="line">                <span class="keyword">match</span> (*header).state.compare_exchange(</span><br><span class="line">                    state,</span><br><span class="line">                    state | CLOSED,</span><br><span class="line">                    Ordering::AcqRel,</span><br><span class="line">                    Ordering::Acquire,</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="literal">Ok</span>(_) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 从这里把任务结果获取出来（挺 Hack 的），就是下面的 output.read()</span></span><br><span class="line">                        <span class="keyword">let</span> output = ((*header).vtable.get_output)(ptr) <span class="keyword">as</span> *<span class="keyword">mut</span> R;</span><br><span class="line">                        <span class="keyword">return</span> Poll::Ready(<span class="literal">Some</span>(output.read()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">Err</span>(s) =&gt; state = s,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="async-std-中的-Task"><a href="#async-std-中的-Task" class="headerlink" title="async_std 中的 Task"></a>async_std 中的 Task</h2><p>Task 是 <code>async_std</code> 中最核心的抽象之一，和 Rust 中的 <code>thread</code> 类似。<code>Tasks</code> 和运行时虽然也有关联，但它们是分开的。<code>async_std</code> Task 有如下几个特性：</p>
<ul>
<li>所有任务是单次分配的（in one single allocation）；</li>
<li>所有任务都有一个 <code>backchannel</code>，这样可以通过 <code>JoinHandle</code> 将结果和错误传递到对应的任务（spawning task）；</li>
<li>它们携带用于调试的元信息；</li>
<li>它们支持 任务级别的 local storage。</li>
</ul>
<p><code>async_std</code> 任务 API 会处理背后的 runtime 初始化（setup）和清理（teardown）工作，作为用户，我们不需要显式地启动运行时（这个和 Python 3 有丢丢区别）。</p>
<h2 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h2><p>一般我们认为 Tasks 都是并发执行的，可能它们会共享同一个执行线程（在该线程上切换任务执行）。这同时也意味着如果在某个执行线程上调用了阻塞 API（比如 <code>std::thread::sleep</code> 或者标准库的 IO 函数），会导致对应执行线程阻塞，从而导致<strong>该执行线程上的所有任务都停止运行了</strong>。其它的一些库（如 db drivers）也会有类似的行为。</p>
<p>需要注意的是，阻塞当前线程本身并非坏事情，只是不要和 <code>async_std</code> 并发执行的模型搞混淆即可。总之，不要这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    task::block_on(async &#123;</span><br><span class="line">        <span class="comment">//  标准库 std::fs，会导致阻塞</span></span><br><span class="line">        std::fs::read_to_string(<span class="string">"test_file"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要混合阻塞 API 调用，建议另起一个线程执行这样的阻塞操作。</p>
<h2 id="关于错误和-Panic"><a href="#关于错误和-Panic" class="headerlink" title="关于错误和 Panic"></a>关于错误和 Panic</h2><p>常规模式下，如果任务可能出错，那么任务的输出 <code>Output</code> 应该是  <code>Result&lt;T, E&gt;</code> 类型。但是在 <code>panic</code> 的时候，具体的表现则取决于有没有合理处理 panic 的地方，如果没有的话，则会退出。</p>
<p>实践中，意味着 <code>block_on</code> 会传递 panic 到阻塞调用的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    task::block_on(async &#123;</span><br><span class="line">        panic!(&quot;test&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread &apos;async-task-driver&apos; panicked at &apos;test&apos;, examples/panic.rs:8:9</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.</span><br></pre></td></tr></table></figure></p>
<p>而对于 spwan 出去的任务如果 panic，则会导致退出（abort）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task::spawn(async &#123;</span><br><span class="line">    panic!(&quot;test&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">task::block_on(async &#123;</span><br><span class="line">    task::sleep(Duration::from_millis(10000)).await;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">thread &apos;async-task-driver&apos; panicked at &apos;test&apos;, examples/panic.rs:8:9</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>上面的行为最初看上去有点奇怪，但另外一种选项是对于 spawn 出去的任务如果发生 panic，则简单忽略掉。当前的行为可以被修改为捕获 spawn 出去的任务中发生的 panic，并且根据不同的情况做出不同的响应，这样我们就可以根据需要采取不同的 panic 处理策略。</p>
<h1 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h1><p>在 <a href="https://github.com/async-rs/async-std/tree/master/examples" target="_blank" rel="noopener">这里</a> 有不少示例代码可以参考，下面是一个简单的 UDP 客户端例子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::io;</span><br><span class="line"><span class="keyword">use</span> async_std::net::UdpSocket;</span><br><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    task::block_on(async &#123;</span><br><span class="line">        <span class="keyword">let</span> socket = UdpSocket::bind(<span class="string">"127.0.0.1:8081"</span>).await?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Listening on &#123;&#125;"</span>, socket.local_addr()?);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> msg = <span class="string">"hello world"</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&lt;- &#123;&#125;"</span>, msg);</span><br><span class="line">        socket.send_to(msg.as_bytes(), <span class="string">"127.0.0.1:8080"</span>).await?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buf = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">let</span> (n, _) = socket.recv_from(&amp;<span class="keyword">mut</span> buf).await?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"-&gt; &#123;&#125;\n"</span>, <span class="built_in">String</span>::from_utf8_lossy(&amp;buf[..n]));</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://book.async.rs/introduction.html" target="_blank" rel="noopener">Async programming in Rust with async-std</a></li>
<li><a href="https://rust-lang.github.io/async-book/" target="_blank" rel="noopener">Asynchronous Programming in Rust</a></li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    iFaceless
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://ifaceless.space/2020/01/20/rust-async-std-intro/" title="Rust async-std 入门">http://ifaceless.space/2020/01/20/rust-async-std-intro/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Rust/" rel="tag"><i class="fa fa-tag"></i> Rust</a>
          
            <a href="/tags/Async/" rel="tag"><i class="fa fa-tag"></i> Async</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/15/elasticsearch-intro/" rel="next" title="初识 Elasticsearch">
                <i class="fa fa-chevron-left"></i> 初识 Elasticsearch
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/02/go-rest-api-for-beginners/" rel="prev" title="Go RESTful API 项目模板介绍">
                Go RESTful API 项目模板介绍 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="iFaceless">
            
              <p class="site-author-name" itemprop="name">iFaceless</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ifaceless" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:me#ifaceless.space" target="_blank" title="邮箱">
                      邮箱</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://zhuanlan.zhihu.com/0xe8551ccb" target="_blank" title="专栏">
                      专栏</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                常用链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xieyuanpeng.com" title="Lingering Fragments" target="_blank">Lingering Fragments</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.acolyer.org/" title="The Morning Paper" target="_blank">The Morning Paper</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.freecodecamp.org" title="freeCodeCamp" target="_blank">freeCodeCamp</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://draveness.me/" title="Draveness's Blog" target="_blank">Draveness's Blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Futures"><span class="nav-number">2.</span> <span class="nav-text">Futures</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Send-和-Sync"><span class="nav-number">2.1.</span> <span class="nav-text">Send 和 Sync</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是计算（computation）"><span class="nav-number">2.2.</span> <span class="nav-text">什么是计算（computation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟计算"><span class="nav-number">2.3.</span> <span class="nav-text">延迟计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从简单的例子开始"><span class="nav-number">2.4.</span> <span class="nav-text">从简单的例子开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Async"><span class="nav-number">2.5.</span> <span class="nav-text">Async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#await-干了什么"><span class="nav-number">2.6.</span> <span class="nav-text">.await 干了什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tasks"><span class="nav-number">3.</span> <span class="nav-text">Tasks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-中是如何推进-Future-完成计算的呢？"><span class="nav-number">3.1.</span> <span class="nav-text">Task 中是如何推进 Future 完成计算的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JoinHandle-是如何将任务结果返回的呢？"><span class="nav-number">3.2.</span> <span class="nav-text">JoinHandle 是如何将任务结果返回的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-std-中的-Task"><span class="nav-number">3.3.</span> <span class="nav-text">async_std 中的 Task</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞（Blocking）"><span class="nav-number">3.4.</span> <span class="nav-text">阻塞（Blocking）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于错误和-Panic"><span class="nav-number">3.5.</span> <span class="nav-text">关于错误和 Panic</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更多示例"><span class="nav-number">4.</span> <span class="nav-text">更多示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黑白之院（iFaceless）</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
